{
  "title": {
    "text": "RFC 4493 - The AES-CMAC Algorithm",
    "ja": "RFC 4493 - AES-CMACアルゴリズム"
  },
  "number": 4493,
  "created_at": "2020-08-14 19:55:28.329976+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           JH. Song\nRequest for Comments: 4493                                 R. Poovendran\nCategory: Informational                         University of Washington\n                                                                  J. Lee\n                                                     Samsung Electronics\n                                                                T. Iwata\n                                                       Nagoya University\n                                                               June 2006",
      "raw": true
    },
    {
      "indent": 25,
      "text": "The AES-CMAC Algorithm",
      "ja": "AES-CMACアルゴリズム"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準も規定していません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC), which is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa. This memo specifies an authentication algorithm based on CMAC with the 128-bit Advanced Encryption Standard (AES). This new authentication algorithm is named AES-CMAC. The purpose of this document is to make the AES-CMAC algorithm conveniently available to the Internet Community.",
      "ja": "国立標準技術研究所（NIST）は最近、暗号ベースのメッセージ認証コード（CMAC）を指定しました。これは、岩田と黒沢によって提出されたOne-Key CBC MAC1（OMAC1）に相当します。このメモは、128ビットAdvanced Encryption Standard（AES）でCMACに基づく認証アルゴリズムを指定します。この新しい認証アルゴリズムの名前はAES-CMACです。このドキュメントの目的は、AES-CMACアルゴリズムをインターネットコミュニティで便利に利用できるようにすることです。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Specification of AES-CMAC .......................................3\n   2.1. Basic Definitions ..........................................3\n   2.2. Overview ...................................................4\n   2.3. Subkey Generation Algorithm ................................5\n   2.4. MAC Generation Algorithm ...................................7\n   2.5. MAC Verification Algorithm .................................9\n3. Security Considerations ........................................10\n4. Test Vectors ...................................................11\n5. Acknowledgement ................................................12\n6. References .....................................................12\n   6.1. Normative References ......................................12\n   6.2. Informative References ....................................12\nAppendix A. Test Code .............................................14",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC). CMAC [NIST-CMAC] is a keyed hash function that is based on a symmetric key block cipher, such as the Advanced Encryption Standard [NIST-AES]. CMAC is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa [OMAC1a, OMAC1b]. OMAC1 is an improvement of the eXtended Cipher Block Chaining mode (XCBC) submitted by Black and Rogaway [XCBCa, XCBCb], which itself is an improvement of the basic Cipher Block Chaining-Message Authentication Code (CBC-MAC). XCBC efficiently addresses the security deficiencies of CBC-MAC, and OMAC1 efficiently reduces the key size of XCBC.",
      "ja": "米国国立標準技術研究所（NIST）は最近、暗号ベースのメッセージ認証コード（CMAC）を指定しました。 CMAC [NIST-CMAC]は、Advanced Encryption Standard [NIST-AES]などの対称鍵ブロック暗号に基づくキー付きハッシュ関数です。 CMACは、岩田と黒沢が提出したOne-Key CBC MAC1（OMAC1）に相当します[OMAC1a、OMAC1b]。 OMAC1は、Black and Rogaway [XCBCa、XCBCb]によって提出された拡張暗号ブロックチェーンモード（XCBC）の改良版で、それ自体が基本的な暗号ブロックチェーンメッセージ認証コード（CBC-MAC）の改良版です。 XCBCはCBC-MACのセキュリティの欠陥に効率的に対処し、OMAC1はXCBCのキーサイズを効率的に削減します。"
    },
    {
      "indent": 3,
      "text": "AES-CMAC provides stronger assurance of data integrity than a checksum or an error-detecting code. The verification of a checksum or an error-detecting code detects only accidental modifications of the data, while CMAC is designed to detect intentional, unauthorized modifications of the data, as well as accidental modifications.",
      "ja": "AES-CMACは、チェックサムやエラー検出コードよりも強力なデータ整合性を保証します。チェックサムまたはエラー検出コードの検証では、データの偶発的な変更のみが検出されますが、CMACは、データの意図的な不正な変更や偶発的な変更を検出するように設計されています。"
    },
    {
      "indent": 3,
      "text": "AES-CMAC achieves a security goal similar to that of HMAC [RFC-HMAC]. Since AES-CMAC is based on a symmetric key block cipher, AES, and HMAC is based on a hash function, such as SHA-1, AES-CMAC is appropriate for information systems in which AES is more readily available than a hash function.",
      "ja": "AES-CMACは、HMAC [RFC-HMAC]と同様のセキュリティ目標を達成します。 AES-CMACは対称鍵ブロック暗号AESに基づいており、HMACはSHA-1などのハッシュ関数に基づいているため、AES-CMACは、AESがハッシュ関数よりも簡単に利用できる情報システムに適しています。"
    },
    {
      "indent": 3,
      "text": "This memo specifies the authentication algorithm based on CMAC with AES-128. This new authentication algorithm is named AES-CMAC.",
      "ja": "このメモは、AES-128でCMACに基づく認証アルゴリズムを指定します。この新しい認証アルゴリズムの名前はAES-CMACです。"
    },
    {
      "indent": 0,
      "text": "2. Specification of AES-CMAC",
      "section_title": true,
      "ja": "2. AES-CMACの仕様"
    },
    {
      "indent": 0,
      "text": "2.1. Basic Definitions",
      "section_title": true,
      "ja": "2.1. 基本的な定義"
    },
    {
      "indent": 3,
      "text": "The following table describes the basic definitions necessary to explain the specification of AES-CMAC.",
      "ja": "次の表に、AES-CMACの仕様を説明するために必要な基本的な定義を示します。"
    },
    {
      "indent": 3,
      "text": "x || y Concatenation. x || y is the string x concatenated with the string y. 0000 || 1111 is 00001111.",
      "ja": "x || y連結。 x || yは、文字列yと連結された文字列xです。 0000 || 1111は00001111です。"
    },
    {
      "indent": 3,
      "text": "x XOR y Exclusive-OR operation. For two equal length strings, x and y, x XOR y is their bit-wise exclusive-OR.",
      "ja": "x XOR y排他的OR演算。 2つの等しい長さの文字列、xとyの場合、x XOR yはビット単位の排他的ORです。"
    },
    {
      "indent": 3,
      "text": "ceil(x) Ceiling function. The smallest integer no smaller than x. ceil(3.5) is 4. ceil(5) is 5.",
      "ja": "ceil（x）シーリング関数。 x以上の最小の整数。 ceil（3.5）は4です。ceil（5）は5です。"
    },
    {
      "indent": 3,
      "text": "x << 1 Left-shift of the string x by 1 bit. The most significant bit disappears, and a zero comes into the least significant bit. 10010001 << 1 is 00100010.",
      "ja": "x << 1文字列xを1ビット左シフト。最上位ビットが消え、ゼロが最下位ビットに入ります。 10010001 << 1は00100010です。"
    },
    {
      "indent": 3,
      "text": "0^n The string that consists of n zero-bits. 0^3 means 000 in binary format. 10^4 means 10000 in binary format. 10^i means 1 followed by i-times repeated zeros.",
      "ja": "0 ^ n n個のゼロビットで構成される文字列。 0 ^ 3は、バイナリ形式の000を意味します。 10 ^ 4は、バイナリ形式で10000を意味します。 10 ^ iは、1の後にi回繰り返されるゼロが続くことを意味します。"
    },
    {
      "indent": 3,
      "text": "MSB(x) The most-significant bit of the string x. MSB(10010000) means 1.",
      "ja": "MSB（x）文字列xの最上位ビット。 MSB（10010000）は1を意味します。"
    },
    {
      "indent": 3,
      "text": "padding(x) 10^i padded output of input x. It is described in detail in section 2.4.",
      "ja": "padding（x）10 ^ i入力xのパディングされた出力。詳細はセクション2.4で説明します。"
    },
    {
      "indent": 3,
      "text": "Key 128-bit (16-octet) long key for AES-128. Denoted by K.",
      "ja": "AES-128用の128ビット（16オクテット）の長いキー。 Kによって示される"
    },
    {
      "indent": 3,
      "text": "First subkey 128-bit (16-octet) long first subkey, derived through the subkey generation algorithm from the key K. Denoted by K1.",
      "ja": "最初のサブキー128ビット（16オクテット）の最初のサブキー。キーKからサブキー生成アルゴリズムを介して導出されます。K1で示されます。"
    },
    {
      "indent": 3,
      "text": "Second subkey 128-bit (16-octet) long second subkey, derived through the subkey generation algorithm from the key K. Denoted by K2.",
      "ja": "2番目のサブキー128ビット（16オクテット）の2番目のサブキー。キーKからサブキー生成アルゴリズムを介して導出されます。K2で示されます。"
    },
    {
      "indent": 3,
      "text": "Message A message to be authenticated. Denoted by M. The message can be null, which means that the length of M is 0.",
      "ja": "メッセージ認証されるメッセージ。 Mで示されます。メッセージはnullにすることができます。これは、Mの長さが0であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Message length The length of the message M in octets. Denoted by len. The minimum value of the length can be 0. The maximum value of the length is not specified in this document.",
      "ja": "メッセージ長オクテット単位のメッセージMの長さ。 lenで示されます。長さの最小値は0にすることができます。長さの最大値は、このドキュメントでは指定されていません。"
    },
    {
      "indent": 3,
      "text": "AES-128(K,M) AES-128(K,M) is the 128-bit ciphertext of AES-128 for a 128-bit key, K, and a 128-bit message, M.",
      "ja": "AES-128（K、M）AES-128（K、M）は、AES-128の128ビットの暗号文で、128ビットの鍵Kと128ビットのメッセージMを表します。"
    },
    {
      "indent": 3,
      "text": "MAC A 128-bit string that is the output of AES-CMAC. Denoted by T. Validating the MAC provides assurance of the integrity and authenticity of the message from the source.",
      "ja": "MAC AES-CMACの出力である128ビットの文字列。 Tで示されます。MACを検証すると、ソースからのメッセージの整合性と信頼性が保証されます。"
    },
    {
      "indent": 3,
      "text": "MAC length By default, the length of the output of AES-CMAC is 128 bits. It is possible to truncate the MAC. The result of the truncation should be taken in most significant bits first order. The MAC length must be specified before the communication starts, and it must not be changed during the lifetime of the key.",
      "ja": "MACの長さデフォルトでは、AES-CMACの出力の長さは128ビットです。 MACを切り捨てることは可能です。切り捨ての結果は、最上位ビットから最初に取得する必要があります。 MACの長さは通信を開始する前に指定する必要があり、キーの有効期間中に変更しないでください。"
    },
    {
      "indent": 0,
      "text": "2.2. Overview",
      "section_title": true,
      "ja": "2.2. 概観"
    },
    {
      "indent": 3,
      "text": "AES-CMAC uses the Advanced Encryption Standard [NIST-AES] as a building block. To generate a MAC, AES-CMAC takes a secret key, a message of variable length, and the length of the message in octets as inputs and returns a fixed-bit string called a MAC.",
      "ja": "AES-CMACは、ビルディングブロックとしてAdvanced Encryption Standard [NIST-AES]を使用します。 MACを生成するために、AES-CMACは秘密鍵、可変長のメッセージ、およびメッセージの長さ（オクテット単位）を入力として取り、MACと呼ばれる固定ビット文字列を返します。"
    },
    {
      "indent": 3,
      "text": "The core of AES-CMAC is the basic CBC-MAC. For a message, M, to be authenticated, the CBC-MAC is applied to M. There are two cases of operation in CMAC. Figure 2.1 illustrates the operation of CBC-MAC in both cases. If the size of the input message block is equal to a positive multiple of the block size (namely, 128 bits), the last block shall be exclusive-OR'ed with K1 before processing. Otherwise, the last block shall be padded with 10^i (notation is described in section 2.1) and exclusive-OR'ed with K2. The result of the previous",
      "ja": "AES-CMACの中核は、基本的なCBC-MACです。認証されるメッセージMの場合、CBC-MACがMに適用されます。CMACでの操作には2つのケースがあります。図2.1は、両方の場合のCBC-MACの動作を示しています。入力メッセージブロックのサイズがブロックサイズの正の倍数（つまり、128ビット）に等しい場合、最後のブロックは、処理前にK1と排他的論理和演算されます。それ以外の場合は、最後のブロックに10 ^ i（表記についてはセクション2.1で説明）を埋め込み、K2との排他的論理和をとります。前回の結果"
    },
    {
      "indent": 3,
      "text": "process will be the input of the last encryption. The output of AES-CMAC provides data integrity of the whole input message.",
      "ja": "プロセスは、最後の暗号化の入力になります。 AES-CMACの出力は、入力メッセージ全体のデータ整合性を提供します。"
    },
    {
      "indent": 1,
      "text": "+-----+     +-----+     +-----+     +-----+     +-----+     +---+----+\n| M_1 |     | M_2 |     | M_n |     | M_1 |     | M_2 |     |M_n|10^i|\n+-----+     +-----+     +-----+     +-----+     +-----+     +---+----+\n   |           |           |   +--+    |           |           |   +--+\n   |     +--->(+)    +--->(+)<-|K1|    |     +--->(+)    +--->(+)<-|K2|\n   |     |     |     |     |   +--+    |     |     |     |     |   +--+\n+-----+  |  +-----+  |  +-----+     +-----+  |  +-----+  |  +-----+\n|AES_K|  |  |AES_K|  |  |AES_K|     |AES_K|  |  |AES_K|  |  |AES_K|\n+-----+  |  +-----+  |  +-----+     +-----+  |  +-----+  |  +-----+\n   |     |     |     |     |           |     |     |     |     |\n   +-----+     +-----+     |           +-----+     +-----+     |\n                           |                                   |\n                        +-----+                              +-----+\n                        |  T  |                              |  T  |\n                        +-----+                              +-----+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "(a) positive multiple block length (b) otherwise",
      "ja": "（a）正の複数ブロック長（b）それ以外の場合"
    },
    {
      "indent": 10,
      "text": "Figure 2.1. Illustration of the two cases of AES-CMAC",
      "ja": "図2.1 AES-CMACの2つのケースの図"
    },
    {
      "indent": 3,
      "text": "AES_K is AES-128 with key K. The message M is divided into blocks M_1,...,M_n, where M_i is the i-th message block. The length of M_i is 128 bits for i = 1,...,n-1, and the length of the last block, M_n, is less than or equal to 128 bits. K1 is the subkey for the case (a), and K2 is the subkey for the case (b). K1 and K2 are generated by the subkey generation algorithm described in section 2.3.",
      "ja": "AES_Kは、キーがKのAES-128です。メッセージMは、ブロックM_1、...、M_nに分割されます。ここで、M_iはi番目のメッセージブロックです。 M_iの長さは、i = 1、...、n-1の場合は128ビットであり、最後のブロックM_nの長さは128ビット以下です。 K1はケース（a）のサブキーで、K2はケース（b）のサブキーです。 K1およびK2は、セクション2.3で説明されているサブキー生成アルゴリズムによって生成されます。"
    },
    {
      "indent": 0,
      "text": "2.3. Subkey Generation Algorithm",
      "section_title": true,
      "ja": "2.3. サブキー生成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The subkey generation algorithm, Generate_Subkey(), takes a secret key, K, which is just the key for AES-128.",
      "ja": "サブキー生成アルゴリズムGenerate_Subkey()は、AES-128のキーである秘密キーKを使用します。"
    },
    {
      "indent": 3,
      "text": "The outputs of the subkey generation algorithm are two subkeys, K1 and K2. We write (K1,K2) := Generate_Subkey(K).",
      "ja": "サブキー生成アルゴリズムの出力は、K1とK2の2つのサブキーです。 （K1、K2）：= Generate_Subkey（K）と書きます。"
    },
    {
      "indent": 3,
      "text": "Subkeys K1 and K2 are used in both MAC generation and MAC verification algorithms. K1 is used for the case where the length of the last block is equal to the block length. K2 is used for the case where the length of the last block is less than the block length.",
      "ja": "サブキーK1およびK2は、MAC生成アルゴリズムとMAC検証アルゴリズムの両方で使用されます。 K1は、最後のブロックの長さがブロック長と等しい場合に使用されます。 K2は、最後のブロックの長さがブロック長より短い場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "Figure 2.2 specifies the subkey generation algorithm.",
      "ja": "図2.2は、サブキー生成アルゴリズムを示しています。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                    Algorithm Generate_Subkey                      +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                                                                   +\n+   Input    : K (128-bit key)                                      +\n+   Output   : K1 (128-bit first subkey)                            +\n+              K2 (128-bit second subkey)                           +\n+-------------------------------------------------------------------+\n+                                                                   +\n+   Constants: const_Zero is 0x00000000000000000000000000000000     +\n+              const_Rb   is 0x00000000000000000000000000000087     +\n+   Variables: L          for output of AES-128 applied to 0^128    +\n+                                                                   +\n+   Step 1.  L := AES-128(K, const_Zero);                           +\n+   Step 2.  if MSB(L) is equal to 0                                +\n+            then    K1 := L << 1;                                  +\n+            else    K1 := (L << 1) XOR const_Rb;                   +\n+   Step 3.  if MSB(K1) is equal to 0                               +\n+            then    K2 := K1 << 1;                                 +\n+            else    K2 := (K1 << 1) XOR const_Rb;                  +\n+   Step 4.  return K1, K2;                                         +\n+                                                                   +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 2.2. Algorithm Generate_Subkey",
      "ja": "図2.2。アルゴリズムGenerate_Subkey"
    },
    {
      "indent": 3,
      "text": "In step 1, AES-128 with key K is applied to an all-zero input block.",
      "ja": "手順1では、キーKのAES-128がすべてゼロの入力ブロックに適用されます。"
    },
    {
      "indent": 3,
      "text": "In step 2, K1 is derived through the following operation:",
      "ja": "ステップ2で、K1は次の演算によって導出されます。"
    },
    {
      "indent": 3,
      "text": "If the most significant bit of L is equal to 0, K1 is the left-shift of L by 1 bit.",
      "ja": "Lの最上位ビットが0に等しい場合、K1はLを1ビット左シフトしたものです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, K1 is the exclusive-OR of const_Rb and the left-shift of L by 1 bit.",
      "ja": "それ以外の場合、K1はconst_Rbの排他的ORとLの1ビットの左シフトです。"
    },
    {
      "indent": 3,
      "text": "In step 3, K2 is derived through the following operation:",
      "ja": "ステップ3で、K2は次の操作によって導出されます。"
    },
    {
      "indent": 3,
      "text": "If the most significant bit of K1 is equal to 0, K2 is the left-shift of K1 by 1 bit.",
      "ja": "K1の最上位ビットが0に等しい場合、K2はK1を1ビット左シフトしたものです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, K2 is the exclusive-OR of const_Rb and the left-shift of K1 by 1 bit.",
      "ja": "それ以外の場合、K2はconst_Rbの排他的ORとK1の1ビットの左シフトです。"
    },
    {
      "indent": 3,
      "text": "In step 4, (K1,K2) := Generate_Subkey(K) is returned.",
      "ja": "ステップ4では、（K1、K2）：= Generate_Subkey（K）が返されます。"
    },
    {
      "indent": 3,
      "text": "The mathematical meaning of the procedures in steps 2 and 3, including const_Rb, can be found in [OMAC1a].",
      "ja": "手順2と3の手順の数学的意味は、const_Rbを含め、[OMAC1a]にあります。"
    },
    {
      "indent": 0,
      "text": "2.4. MAC Generation Algorithm",
      "section_title": true,
      "ja": "2.4. MAC生成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The MAC generation algorithm, AES-CMAC(), takes three inputs, a secret key, a message, and the length of the message in octets. The secret key, denoted by K, is just the key for AES-128. The message and its length in octets are denoted by M and len, respectively. The message M is denoted by the sequence of M_i, where M_i is the i-th message block. That is, if M consists of n blocks, then M is written as",
      "ja": "MAC生成アルゴリズムAES-CMAC()は、秘密鍵、メッセージ、およびメッセージの長さ（オクテット単位）の3つの入力を取ります。 Kで示される秘密鍵は、AES-128の鍵にすぎません。オクテット単位のメッセージとその長さは、それぞれMとlenで示されます。メッセージMは、M_iのシーケンスで表されます。ここで、M_iはi番目のメッセージブロックです。つまり、Mがn個のブロックで構成されている場合、Mは次のように記述されます。"
    },
    {
      "indent": 4,
      "text": "- M = M_1 || M_2 || ... || M_{n-1} || M_n",
      "ja": "- M = M_1 || M_2 || ... || M_ {n-1} || M_n"
    },
    {
      "indent": 3,
      "text": "The length of M_i is 128 bits for i = 1,...,n-1, and the length of the last block M_n is less than or equal to 128 bits.",
      "ja": "M_iの長さは、i = 1、...、n-1の場合は128ビットであり、最後のブロックM_nの長さは128ビット以下です。"
    },
    {
      "indent": 3,
      "text": "The output of the MAC generation algorithm is a 128-bit string, called a MAC, which is used to validate the input message. The MAC is denoted by T, and we write T := AES-CMAC(K,M,len). Validating the MAC provides assurance of the integrity and authenticity of the message from the source.",
      "ja": "MAC生成アルゴリズムの出力は、MACと呼ばれる128ビットの文字列で、入力メッセージの検証に使用されます。 MACはTで表され、T：= AES-CMAC（K、M、len）と記述します。 MACを検証すると、送信元からのメッセージの整合性と信頼性が保証されます。"
    },
    {
      "indent": 3,
      "text": "It is possible to truncate the MAC. According to [NIST-CMAC], at least a 64-bit MAC should be used as protection against guessing attacks. The result of truncation should be taken in most significant bits first order.",
      "ja": "MACを切り捨てることは可能です。 [NIST-CMAC]によれば、推測攻撃に対する保護として少なくとも64ビットMACを使用する必要があります。切り捨ての結果は、最上位ビットから最初に取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "The block length of AES-128 is 128 bits (16 octets). There is a special treatment if the length of the message is not a positive multiple of the block length. The special treatment is to pad M with the bit-string 10^i to adjust the length of the last block up to the block length.",
      "ja": "AES-128のブロック長は128ビット（16オクテット）です。メッセージの長さがブロック長の正の倍数でない場合は、特別な扱いがあります。特別な処理は、Mにビット文字列10 ^ iをパディングして、最後のブロックの長さをブロック長に調整することです。"
    },
    {
      "indent": 3,
      "text": "For an input string x of r-octets, where 0 <= r < 16, the padding function, padding(x), is defined as follows:",
      "ja": "rオクテットの入力文字列x（0 <= r <16）の場合、パディング関数padding（x）は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "- padding(x) = x || 10^i where i is 128-8*r-1",
      "ja": "- padding（x）= x || 10 ^ i（iは128-8 * r-1）"
    },
    {
      "indent": 3,
      "text": "That is, padding(x) is the concatenation of x and a single '1', followed by the minimum number of '0's, so that the total length is equal to 128 bits.",
      "ja": "つまり、padding（x）は、xと単一の「1」と、それに続く最小数の「0」を連結したものであり、全長は128ビットに等しくなります。"
    },
    {
      "indent": 3,
      "text": "Figure 2.3 describes the MAC generation algorithm.",
      "ja": "図2.3は、MAC生成アルゴリズムを示しています。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                   Algorithm AES-CMAC                              +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                                                                   +\n+   Input    : K    ( 128-bit key )                                 +\n+            : M    ( message to be authenticated )                 +\n+            : len  ( length of the message in octets )             +\n+   Output   : T    ( message authentication code )                 +\n+                                                                   +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+   Constants: const_Zero is 0x00000000000000000000000000000000     +\n+              const_Bsize is 16                                    +\n+                                                                   +\n+   Variables: K1, K2 for 128-bit subkeys                           +\n+              M_i is the i-th block (i=1..ceil(len/const_Bsize))   +\n+              M_last is the last block xor-ed with K1 or K2        +\n+              n      for number of blocks to be processed          +\n+              r      for number of octets of last block            +\n+              flag   for denoting if last block is complete or not +\n+                                                                   +\n+   Step 1.  (K1,K2) := Generate_Subkey(K);                         +\n+   Step 2.  n := ceil(len/const_Bsize);                            +\n+   Step 3.  if n = 0                                               +\n+            then                                                   +\n+                 n := 1;                                           +\n+                 flag := false;                                    +\n+            else                                                   +\n+                 if len mod const_Bsize is 0                       +\n+                 then flag := true;                                +\n+                 else flag := false;                               +\n+                                                                   +\n+   Step 4.  if flag is true                                        +\n+            then M_last := M_n XOR K1;                             +\n+            else M_last := padding(M_n) XOR K2;                    +\n+   Step 5.  X := const_Zero;                                       +\n+   Step 6.  for i := 1 to n-1 do                                   +\n+                begin                                              +\n+                  Y := X XOR M_i;                                  +\n+                  X := AES-128(K,Y);                               +\n+                end                                                +\n+            Y := M_last XOR X;                                     +\n+            T := AES-128(K,Y);                                     +\n+   Step 7.  return T;                                              +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2.3. Algorithm AES-CMAC",
      "ja": "図2.3アルゴリズムAES-CMAC"
    },
    {
      "indent": 3,
      "text": "In step 1, subkeys K1 and K2 are derived from K through the subkey generation algorithm.",
      "ja": "ステップ1では、サブキーK1およびK2は、サブキー生成アルゴリズムを通じてKから導出されます。"
    },
    {
      "indent": 3,
      "text": "In step 2, the number of blocks, n, is calculated. The number of blocks is the smallest integer value greater than or equal to the quotient determined by dividing the length parameter by the block length, 16 octets.",
      "ja": "ステップ2では、ブロック数nが計算されます。ブロックの数は、長さパラメーターをブロック長の16オクテットで除算することにより決定される商以上の最小の整数値です。"
    },
    {
      "indent": 3,
      "text": "In step 3, the length of the input message is checked. If the input length is 0 (null), the number of blocks to be processed shall be 1, and the flag shall be marked as not-complete-block (false). Otherwise, if the last block length is 128 bits, the flag is marked as complete-block (true); else mark the flag as not-complete-block (false).",
      "ja": "手順3では、入力メッセージの長さがチェックされます。入力長が0（null）の場合、処理されるブロックの数は1で、フラグはnot-complete-block（false）としてマークされます。それ以外の場合、最後のブロック長が128ビットの場合、フラグは完全ブロック（true）としてマークされます。それ以外の場合は、フラグをnot-complete-block（false）としてマークします。"
    },
    {
      "indent": 3,
      "text": "In step 4, M_last is calculated by exclusive-OR'ing M_n and one of the previously calculated subkeys. If the last block is a complete block (true), then M_last is the exclusive-OR of M_n and K1. Otherwise, M_last is the exclusive-OR of padding(M_n) and K2.",
      "ja": "ステップ4で、M_lastは、M_nと以前に計算されたサブキーの1つを排他的論理和することによって計算されます。最後のブロックが完全なブロック（true）の場合、M_lastはM_nとK1の排他的論理和です。それ以外の場合、M_lastはpadding（M_n）とK2の排他的論理和です。"
    },
    {
      "indent": 3,
      "text": "In step 5, the variable X is initialized.",
      "ja": "ステップ5では、変数Xが初期化されます。"
    },
    {
      "indent": 3,
      "text": "In step 6, the basic CBC-MAC is applied to M_1,...,M_{n-1},M_last.",
      "ja": "ステップ6では、基本的なCBC-MACがM_1、...、M_ {n-1}、M_lastに適用されます。"
    },
    {
      "indent": 3,
      "text": "In step 7, the 128-bit MAC, T := AES-CMAC(K,M,len), is returned.",
      "ja": "ステップ7では、128ビットMAC T：= AES-CMAC（K、M、len）が返されます。"
    },
    {
      "indent": 3,
      "text": "If necessary, the MAC is truncated before it is returned.",
      "ja": "必要に応じて、MACは返される前に切り捨てられます。"
    },
    {
      "indent": 0,
      "text": "2.5. MAC Verification Algorithm",
      "section_title": true,
      "ja": "2.5. MAC検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The verification of the MAC is simply done by a MAC recomputation. We use the MAC generation algorithm, which is described in section 2.4.",
      "ja": "MACの検証は、MAC再計算によって簡単に行われます。セクション2.4で説明されているMAC生成アルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "The MAC verification algorithm, Verify_MAC(), takes four inputs, a secret key, a message, the length of the message in octets, and the received MAC. These are denoted by K, M, len, and T', respectively.",
      "ja": "MAC検証アルゴリズムVerify_MAC()は、4つの入力、秘密鍵、メッセージ、メッセージの長さ（オクテット）、および受信したMACを受け取ります。これらはそれぞれ、K、M、len、およびT 'で表されます。"
    },
    {
      "indent": 3,
      "text": "The output of the MAC verification algorithm is either INVALID or VALID.",
      "ja": "MAC検証アルゴリズムの出力は、INVALIDまたはVALIDのいずれかです。"
    },
    {
      "indent": 3,
      "text": "Figure 2.4 describes the MAC verification algorithm.",
      "ja": "図2.4は、MAC検証アルゴリズムを示しています。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                      Algorithm Verify_MAC                         +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                                                                   +\n+   Input    : K    ( 128-bit Key )                                 +\n+            : M    ( message to be verified )                      +\n+            : len  ( length of the message in octets )             +\n+            : T'   ( the received MAC to be verified )             +\n+   Output   : INVALID or VALID                                     +\n+                                                                   +\n+-------------------------------------------------------------------+\n+                                                                   +\n+   Step 1.  T* := AES-CMAC(K,M,len);                               +\n+   Step 2.  if T* is equal to T'                                   +\n+            then                                                   +\n+                 return VALID;                                     +\n+            else                                                   +\n+                 return INVALID;                                   +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2.4. Algorithm Verify_MAC",
      "ja": "図2.4アルゴリズムVerify_MAC"
    },
    {
      "indent": 3,
      "text": "In step 1, T* is derived from K, M, and len through the MAC generation algorithm.",
      "ja": "ステップ1では、T *はK、M、およびlenからMAC生成アルゴリズムを介して導出されます。"
    },
    {
      "indent": 3,
      "text": "In step 2, T* and T' are compared. If T* is equal to T', then return VALID; otherwise return INVALID.",
      "ja": "ステップ2では、T *とT 'が比較されます。 T *がT 'と等しい場合、VALIDを返します。それ以外の場合は、INVALIDを返します。"
    },
    {
      "indent": 3,
      "text": "If the output is INVALID, then the message is definitely not authentic, i.e., it did not originate from a source that executed the generation process on the message to produce the purported MAC.",
      "ja": "出力がINVALIDの場合、メッセージは間違いなく真正ではありません。つまり、メッセージに対して生成プロセスを実行してMACとされるメッセージを生成したソースから発信されたものではありません。"
    },
    {
      "indent": 3,
      "text": "If the output is VALID, then the design of the AES-CMAC provides assurance that the message is authentic and, hence, was not corrupted in transit; however, this assurance, as for any MAC algorithm, is not absolute.",
      "ja": "出力が有効である場合、AES-CMACの設計により、メッセージが本物であり、したがって転送中に破損していないことが保証されます。ただし、この保証は、MACアルゴリズムと同様に、絶対的なものではありません。"
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security provided by AES-CMAC is built on the strong cryptographic algorithm AES. However, as is true with any cryptographic algorithm, part of its strength lies in the secret key, K, and the correctness of the implementation in all of the participating systems. If the secret key is compromised or inappropriately shared, it guarantees neither authentication nor integrity of message at all. The secret key shall be generated in a way that meets the pseudo randomness requirement of RFC 4086 [RFC4086] and should be kept safe. If and only if AES-CMAC is used",
      "ja": "AES-CMACによって提供されるセキュリティは、強力な暗号化アルゴリズムAESに基づいて構築されています。ただし、どの暗号化アルゴリズムでもそうであるように、その強さの一部は、秘密鍵Kと、参加するすべてのシステムでの実装の正確さにあります。秘密鍵が危険にさらされたり不適切に共有されたりすると、認証やメッセージの整合性が保証されなくなります。秘密鍵は、RFC 4086 [RFC4086]の疑似ランダム性の要件を満たす方法で生成され、安全に保管する必要があります。 AES-CMACが使用されている場合のみ"
    },
    {
      "indent": 3,
      "text": "properly it provides the authentication and integrity that meet the best current practice of message authentication.",
      "ja": "適切に、メッセージ認証の現在のベストプラクティスを満たす認証と整合性を提供します。"
    },
    {
      "indent": 0,
      "text": "4. Test Vectors",
      "section_title": true,
      "ja": "4. テストベクトル"
    },
    {
      "indent": 3,
      "text": "The following test vectors are the same as those of [NIST-CMAC]. The following vectors are also the output of the test program in Appendix A.",
      "ja": "以下のテストベクターは[NIST-CMAC]と同じです。以下のベクトルも、付録Aのテストプログラムの出力です。"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------------\nSubkey Generation\nK              2b7e1516 28aed2a6 abf71588 09cf4f3c\nAES-128(key,0) 7df76b0c 1ab899b3 3e42f047 b91b546f\nK1             fbeed618 35713366 7c85e08f 7236a8de\nK2             f7ddac30 6ae266cc f90bc11e e46d513b\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "--------------------------------------------------\nExample 1: len = 0\nM              <empty string>\nAES-CMAC       bb1d6929 e9593728 7fa37d12 9b756746\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 2: len = 16\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\nAES-CMAC       070a16b4 6b4d4144 f79bdd9d d04a287c\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 3: len = 40\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\n               ae2d8a57 1e03ac9c 9eb76fac 45af8e51\n               30c81c46 a35ce411\nAES-CMAC       dfa66747 de9ae630 30ca3261 1497c827\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 4: len = 64\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\n               ae2d8a57 1e03ac9c 9eb76fac 45af8e51\n               30c81c46 a35ce411 e5fbc119 1a0a52ef\n               f69f2445 df4f9b17 ad2b417b e66c3710\nAES-CMAC       51f0bebf 7e3b9d92 fc497417 79363cfe\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Acknowledgement",
      "section_title": true,
      "ja": "5. 謝辞"
    },
    {
      "indent": 3,
      "text": "Portions of the text herein are borrowed from [NIST-CMAC]. We appreciate the OMAC1 authors, the SP 800-38B author, and Russ Housley for his useful comments and guidance, which have been incorporated herein. We also thank Alfred Hoenes for many useful comments. This memo was prepared while Tetsu Iwata was at Ibaraki University, Japan.",
      "ja": "本文の一部は[NIST-CMAC]から借用したものです。 OMAC1の作者、SP 800-38Bの作者、およびRuss Housleyの有益なコメントとガイダンスをここに組み込んでいただき、ありがとうございます。また、多くの有益なコメントを提供してくれたAlfred Hoenesにも感謝します。このメモは、岩田哲が茨城大学に在籍中に作成されました。"
    },
    {
      "indent": 3,
      "text": "We acknowledge the support from the following grants: Collaborative Technology Alliance (CTA) from US Army Research Laboratory, DAAD19- 01-2-0011; Presidential Award from Army Research Office, W911NF-05- 1-0491; NSF CAREER ANI-0093187. Results do not reflect any position of the funding agencies.",
      "ja": "私たちは、以下の助成金によるサポートを認めます。米国陸軍研究所、DAAD19-01-2-0011によるCollaborative Technology Alliance（CTA）。陸軍研究局からの大統領賞、W911NF-05- 1-0491; NSF CAREER ANI-0093187。結果は、資金提供機関の位置を反映していません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[NIST-CMAC] NIST, Special Publication 800-38B, \"Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication\", May 2005.",
      "ja": "[NIST-CMAC] NIST、特別刊行物800-38B、「ブロック暗号操作モードの推奨：認証のCMACモード」、2005年5月。"
    },
    {
      "indent": 3,
      "text": "[NIST-AES]  NIST, FIPS 197, \"Advanced Encryption Standard (AES)\",\n            November 2001.\n            http://csrc.nist.gov/publications/fips/fips197/fips-\n            197.pdf",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC-HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC-HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[OMAC1a] Tetsu Iwata and Kaoru Kurosawa, \"OMAC: One-Key CBC MAC\", Fast Software Encryption, FSE 2003, LNCS 2887, pp. 129- 153, Springer-Verlag, 2003.",
      "ja": "[OMAC1a]岩田哲と黒澤薫、「OMAC：One-Key CBC MAC」、Fast Software Encryption、FSE 2003、LNCS 2887、pp。129-153、Springer-Verlag、2003。"
    },
    {
      "indent": 3,
      "text": "[OMAC1b]    Tetsu Iwata and Kaoru Kurosawa, \"OMAC: One-Key CBC MAC\",\n            Submission to NIST, December 2002.  Available from the\n            NIST modes of operation web site at\n            http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/\n            omac/omac-spec.pdf",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[XCBCa]     John Black and Phillip Rogaway, \"A Suggestion for\n            Handling Arbitrary-Length Messages with the CBC MAC\",\n            NIST Second Modes of Operation Workshop, August 2001.\n            Available from the NIST modes of operation web site at\n            http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/\n            xcbc-mac/xcbc-mac-spec.pdf",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[XCBCb] John Black and Phillip Rogaway, \"CBC MACs for Arbitrary-Length Messages: The Three-Key Constructions\", Journal of Cryptology, Vol. 18, No. 2, pp. 111-132, Springer-Verlag, Spring 2005.",
      "ja": "[XCBCb]ジョンブラックとフィリップロガウェイ、「任意の長さのメッセージのためのCBC MAC：3つのキー構造」、ジャーナルオブクリプトロジー、Vol。 18、No。2、111-132ページ、Springer-Verlag、2005年春。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Code",
      "section_title": true,
      "ja": "付録A.テストコード"
    },
    {
      "indent": 2,
      "text": "This C source is designed to generate the test vectors that appear in this memo to verify correctness of the algorithm. The source code is not intended for use in commercial products.",
      "ja": "このCソースは、アルゴリズムの正確さを検証するために、このメモに表示されるテストベクトルを生成するように設計されています。ソースコードは、商用製品での使用を意図していません。"
    },
    {
      "indent": 2,
      "text": "/****************************************************************/\n/* AES-CMAC with AES-128 bit                                    */\n/* CMAC     Algorithm described in SP800-38B                    */\n/* Author: Junhyuk Song (junhyuk.song@samsung.com)              */\n/*         Jicheol Lee  (jicheol.lee@samsung.com)               */\n/****************************************************************/",
      "raw": true
    },
    {
      "indent": 2,
      "text": "#include <stdio.h>",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* For CMAC Calculation */\nunsigned char const_Rb[16] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87\n};\nunsigned char const_Zero[16] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* Basic Functions */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void xor_128(unsigned char *a, unsigned char *b, unsigned char *out)\n{\n    int i;\n    for (i=0;i<16; i++)\n    {\n        out[i] = a[i] ^ b[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void print_hex(char *str, unsigned char *buf, int len)\n{\n    int     i;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    for ( i=0; i<len; i++ ) {\n        if ( (i % 16) == 0 && i != 0 ) printf(str);\n        printf(\"%02x\", buf[i]);\n        if ( (i % 4) == 3 ) printf(\" \");\n        if ( (i % 16) == 15 ) printf(\"\\n\");\n    }\n    if ( (i % 16) != 0 ) printf(\"\\n\");\n} void print128(unsigned char *bytes)\n{\n    int         j;\n    for (j=0; j<16;j++) {\n        printf(\"%02x\",bytes[j]);\n        if ( (j%4) == 3 ) printf(\" \");\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void print96(unsigned char *bytes)\n{\n    int         j;\n    for (j=0; j<12;j++) {\n        printf(\"%02x\",bytes[j]);\n        if ( (j%4) == 3 ) printf(\" \");\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* AES-CMAC Generation Function */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void leftshift_onebit(unsigned char *input,unsigned char *output)\n{\n    int         i;\n    unsigned char overflow = 0;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    for ( i=15; i>=0; i-- ) {\n        output[i] = input[i] << 1;\n        output[i] |= overflow;\n        overflow = (input[i] & 0x80)?1:0;\n    }\n    return;\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void generate_subkey(unsigned char *key, unsigned char *K1, unsigned\n                     char *K2)\n{\n    unsigned char L[16];\n    unsigned char Z[16];\n    unsigned char tmp[16];\n    int i;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "for ( i=0; i<16; i++ ) Z[i] = 0;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "AES_128(key,Z,L);",
      "ja": "AES_128（キー、Z、L）;"
    },
    {
      "indent": 6,
      "text": "if ( (L[0] & 0x80) == 0 ) { /* If MSB(L) = 0, then K1 = L << 1 */\n    leftshift_onebit(L,K1);\n} else {    /* Else K1 = ( L << 1 ) (+) Rb */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "    leftshift_onebit(L,tmp);\n    xor_128(tmp,const_Rb,K1);\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    if ( (K1[0] & 0x80) == 0 ) {\n        leftshift_onebit(K1,K2);\n    } else {\n        leftshift_onebit(K1,tmp);\n        xor_128(tmp,const_Rb,K2);\n    }\n    return;\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void padding ( unsigned char *lastb, unsigned char *pad, int length )\n{\n    int         j;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    /* original last block */\n    for ( j=0; j<16; j++ ) {\n        if ( j < length ) {\n            pad[j] = lastb[j];\n        } else if ( j == length ) {\n            pad[j] = 0x80;\n        } else {\n            pad[j] = 0x00;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void AES_CMAC ( unsigned char *key, unsigned char *input, int length,\n                unsigned char *mac )\n{\n    unsigned char       X[16],Y[16], M_last[16], padded[16];\n    unsigned char       K1[16], K2[16];\n    int         n, i, flag;\n    generate_subkey(key,K1,K2);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "n = (length+15) / 16;       /* n is number of rounds */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if ( n == 0 ) {\n    n = 1;\n    flag = 0;\n} else {\n    if ( (length%16) == 0 ) { /* last block is a complete block */\n        flag = 1;\n    } else { /* last block is not complete block */\n        flag = 0;\n    }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "if ( flag ) { /* last block is complete block */\n    xor_128(&input[16*(n-1)],K1,M_last);\n} else {\n    padding(&input[16*(n-1)],padded,length%16);\n    xor_128(padded,K2,M_last);\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "for ( i=0; i<16; i++ ) X[i] = 0;\nfor ( i=0; i<n-1; i++ ) {\n    xor_128(X,&input[16*i],Y); /* Y := Mi (+) X  */\n    AES_128(key,Y,X);      /* X := AES-128(KEY, Y); */\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "xor_128(X,M_last,Y);\nAES_128(key,Y,X);",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    for ( i=0; i<16; i++ ) {\n        mac[i] = X[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "int main()\n{\n    unsigned char L[16], K1[16], K2[16], T[16], TT[12];\n    unsigned char M[64] = {\n        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,\n        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,\n        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,\n        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,\n        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10\n    };\n    unsigned char key[16] = {\n        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c\n    };",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"--------------------------------------------------\\n\");\nprintf(\"K              \"); print128(key); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nSubkey Generation\\n\");\nAES_128(key,const_Zero,L);\nprintf(\"AES_128(key,0) \"); print128(L); printf(\"\\n\");\ngenerate_subkey(key,K1,K2);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"K1             \"); print128(K1); printf(\"\\n\");\nprintf(\"K2             \"); print128(K2); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 1: len = 0\\n\");\nprintf(\"M              \"); printf(\"<empty string>\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "AES_CMAC(key,M,0,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 2: len = 16\\n\");\nprintf(\"M              \"); print_hex(\"                \",M,16);\nAES_CMAC(key,M,16,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");\nprintf(\"\\nExample 3: len = 40\\n\");\nprintf(\"M              \"); print_hex(\"               \",M,40);\nAES_CMAC(key,M,40,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 4: len = 64\\n\");\nprintf(\"M              \"); print_hex(\"               \",M,64);\nAES_CMAC(key,M,64,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"--------------------------------------------------\\n\");",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    return 0;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 2,
      "text": "Junhyuk Song University of Washington Samsung Electronics",
      "ja": "ジュンヒョクソンワシントン大学サムスンエレクトロニクス"
    },
    {
      "indent": 2,
      "text": "Phone: (206) 853-5843\nEMail: songlee@ee.washington.edu, junhyuk.song@samsung.com",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Jicheol Lee Samsung Electronics",
      "ja": "Jicheol Lee Samsung Electronics"
    },
    {
      "indent": 2,
      "text": "Phone: +82-31-279-3605\nEMail: jicheol.lee@samsung.com",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Radha Poovendran Network Security Lab University of Washington",
      "ja": "Radha Poovendranネットワークセキュリティラボワシントン大学"
    },
    {
      "indent": 2,
      "text": "Phone: (206) 221-6512 EMail: radha@ee.washington.edu",
      "ja": "電話：（206）221-6512メール：radha@ee.washington.edu"
    },
    {
      "indent": 2,
      "text": "Tetsu Iwata Nagoya University",
      "ja": "てつ いわた なごや うにゔぇｒしｔｙ"
    },
    {
      "indent": 2,
      "text": "EMail: iwata@cse.nagoya-u.ac.jp",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースは、すべての保証を明示的または明示的に提供します。ここに含まれる情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、または一般ライセンスを取得しようとした試み、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得した結果を取得できます。 http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}