{
  "title": {
    "text": "RFC 4880 - OpenPGP Message Format",
    "ja": "RFC 4880 - OpenPGPメッセージ形式"
  },
  "number": 4880,
  "created_at": "2020-08-15 22:21:03.695001+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          J. Callas\nRequest for Comments: 4880                               PGP Corporation\nObsoletes: 1991, 2440                                     L. Donnerhacke\nCategory: Standards Track                                       IKS GmbH\n                                                               H. Finney\n                                                         PGP Corporation\n                                                                 D. Shaw\n                                                               R. Thayer\n                                                           November 2007",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "OpenPGP Message Format",
      "ja": "OpenPGPメッセージ形式"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document is maintained in order to publish all necessary information needed to develop interoperable applications based on the OpenPGP format. It is not a step-by-step cookbook for writing an application. It describes only the format and methods needed to read, check, generate, and write conforming packets crossing any network. It does not deal with storage and implementation questions. It does, however, discuss implementation issues necessary to avoid security flaws.",
      "ja": "このドキュメントは、OpenPGP形式に基づく相互運用可能なアプリケーションの開発に必要なすべての必要な情報を公開するために維持されています。アプリケーションを作成するための段階的なクックブックではありません。ネットワークを通過する適合パケットの読み取り、チェック、生成、および書き込みに必要なフォーマットとメソッドのみを説明しています。ストレージと実装に関する質問は扱いません。ただし、セキュリティ上の欠陥を回避するために必要な実装の問題については説明します。"
    },
    {
      "indent": 3,
      "text": "OpenPGP software uses a combination of strong public-key and symmetric cryptography to provide security services for electronic communications and data storage. These services include confidentiality, key management, authentication, and digital signatures. This document specifies the message formats used in OpenPGP.",
      "ja": "OpenPGPソフトウェアは、強力な公開鍵と対称暗号の組み合わせを使用して、電子通信とデータストレージにセキュリティサービスを提供します。これらのサービスには、機密性、キー管理、認証、およびデジタル署名が含まれます。このドキュメントでは、OpenPGPで使用されるメッセージ形式を指定します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. Terms ......................................................5\n2. General functions ...............................................6\n   2.1. Confidentiality via Encryption .............................6\n   2.2. Authentication via Digital Signature .......................7\n   2.3. Compression ................................................7\n   2.4. Conversion to Radix-64 .....................................8\n   2.5. Signature-Only Applications ................................8\n3. Data Element Formats ............................................8\n   3.1. Scalar Numbers .............................................8\n   3.2. Multiprecision Integers ....................................9\n   3.3. Key IDs ....................................................9\n   3.4. Text .......................................................9\n   3.5. Time Fields ...............................................10\n   3.6. Keyrings ..................................................10\n   3.7. String-to-Key (S2K) Specifiers ............................10\n        3.7.1. String-to-Key (S2K) Specifier Types ................10\n               3.7.1.1. Simple S2K ................................10\n               3.7.1.2. Salted S2K ................................11\n               3.7.1.3. Iterated and Salted S2K ...................11\n        3.7.2. String-to-Key Usage ................................12\n               3.7.2.1. Secret-Key Encryption .....................12\n               3.7.2.2. Symmetric-Key Message Encryption ..........13\n4. Packet Syntax ..................................................13\n   4.1. Overview ..................................................13\n   4.2. Packet Headers ............................................13\n        4.2.1. Old Format Packet Lengths ..........................14\n        4.2.2. New Format Packet Lengths ..........................15\n               4.2.2.1. One-Octet Lengths .........................15\n               4.2.2.2. Two-Octet Lengths .........................15\n               4.2.2.3. Five-Octet Lengths ........................15\n               4.2.2.4. Partial Body Lengths ......................16\n        4.2.3. Packet Length Examples .............................16\n   4.3. Packet Tags ...............................................17\n5. Packet Types ...................................................17\n   5.1. Public-Key Encrypted Session Key Packets (Tag 1) ..........17\n   5.2. Signature Packet (Tag 2) ..................................19\n        5.2.1. Signature Types ....................................19\n        5.2.2. Version 3 Signature Packet Format ..................21\n        5.2.3. Version 4 Signature Packet Format ..................24\n               5.2.3.1. Signature Subpacket Specification .........25\n               5.2.3.2. Signature Subpacket Types .................27\n               5.2.3.3. Notes on Self-Signatures ..................27\n               5.2.3.4. Signature Creation Time ...................28\n               5.2.3.5. Issuer ....................................28\n               5.2.3.6. Key Expiration Time .......................28",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "               5.2.3.7. Preferred Symmetric Algorithms ............28\n               5.2.3.8. Preferred Hash Algorithms .................29\n               5.2.3.9. Preferred Compression Algorithms ..........29\n               5.2.3.10. Signature Expiration Time ................29\n               5.2.3.11. Exportable Certification .................29\n               5.2.3.12. Revocable ................................30\n               5.2.3.13. Trust Signature ..........................30\n               5.2.3.14. Regular Expression .......................31\n               5.2.3.15. Revocation Key ...........................31\n               5.2.3.16. Notation Data ............................31\n               5.2.3.17. Key Server Preferences ...................32\n               5.2.3.18. Preferred Key Server .....................33\n               5.2.3.19. Primary User ID ..........................33\n               5.2.3.20. Policy URI ...............................33\n               5.2.3.21. Key Flags ................................33\n               5.2.3.22. Signer's User ID .........................34\n               5.2.3.23. Reason for Revocation ....................35\n               5.2.3.24. Features .................................36\n               5.2.3.25. Signature Target .........................36\n               5.2.3.26. Embedded Signature .......................37\n        5.2.4. Computing Signatures ...............................37\n               5.2.4.1. Subpacket Hints ...........................38\n   5.3. Symmetric-Key Encrypted Session Key Packets (Tag 3) .......38\n   5.4. One-Pass Signature Packets (Tag 4) ........................39\n   5.5. Key Material Packet .......................................40\n        5.5.1. Key Packet Variants ................................40\n               5.5.1.1. Public-Key Packet (Tag 6) .................40\n               5.5.1.2. Public-Subkey Packet (Tag 14) .............40\n               5.5.1.3. Secret-Key Packet (Tag 5) .................41\n               5.5.1.4. Secret-Subkey Packet (Tag 7) ..............41\n        5.5.2. Public-Key Packet Formats ..........................41\n        5.5.3. Secret-Key Packet Formats ..........................43\n   5.6. Compressed Data Packet (Tag 8) ............................45\n   5.7. Symmetrically Encrypted Data Packet (Tag 9) ...............45\n   5.8. Marker Packet (Obsolete Literal Packet) (Tag 10) ..........46\n   5.9. Literal Data Packet (Tag 11) ..............................46\n   5.10. Trust Packet (Tag 12) ....................................47\n   5.11. User ID Packet (Tag 13) ..................................48\n   5.12. User Attribute Packet (Tag 17) ...........................48\n        5.12.1. The Image Attribute Subpacket .....................48\n   5.13. Sym. Encrypted Integrity Protected Data Packet (Tag 18) ..49\n   5.14. Modification Detection Code Packet (Tag 19) ..............52\n6. Radix-64 Conversions ...........................................53\n   6.1. An Implementation of the CRC-24 in \"C\" ....................54\n   6.2. Forming ASCII Armor .......................................54\n   6.3. Encoding Binary in Radix-64 ...............................57\n   6.4. Decoding Radix-64 .........................................58\n   6.5. Examples of Radix-64 ......................................59",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   6.6. Example of an ASCII Armored Message .......................59\n7. Cleartext Signature Framework ..................................59\n   7.1. Dash-Escaped Text .........................................60\n8. Regular Expressions ............................................61\n9. Constants ......................................................61\n   9.1. Public-Key Algorithms .....................................62\n   9.2. Symmetric-Key Algorithms ..................................62\n   9.3. Compression Algorithms ....................................63\n   9.4. Hash Algorithms ...........................................63\n10. IANA Considerations ...........................................63\n   10.1. New String-to-Key Specifier Types ........................64\n   10.2. New Packets ..............................................64\n        10.2.1. User Attribute Types ..............................64\n               10.2.1.1. Image Format Subpacket Types .............64\n        10.2.2. New Signature Subpackets ..........................64\n               10.2.2.1. Signature Notation Data Subpackets .......65\n               10.2.2.2. Key Server Preference Extensions .........65\n               10.2.2.3. Key Flags Extensions .....................65\n               10.2.2.4. Reason For Revocation Extensions .........65\n               10.2.2.5. Implementation Features ..................66\n        10.2.3. New Packet Versions ...............................66\n   10.3. New Algorithms ...........................................66\n        10.3.1. Public-Key Algorithms .............................66\n        10.3.2. Symmetric-Key Algorithms ..........................67\n        10.3.3. Hash Algorithms ...................................67\n        10.3.4. Compression Algorithms ............................67\n11. Packet Composition ............................................67\n   11.1. Transferable Public Keys .................................67\n   11.2. Transferable Secret Keys .................................69\n   11.3. OpenPGP Messages .........................................69\n   11.4. Detached Signatures ......................................70\n12. Enhanced Key Formats ..........................................70\n   12.1. Key Structures ...........................................70\n   12.2. Key IDs and Fingerprints .................................71\n13. Notes on Algorithms ...........................................72\n   13.1. PKCS#1 Encoding in OpenPGP ...............................72\n        13.1.1. EME-PKCS1-v1_5-ENCODE .............................73\n        13.1.2. EME-PKCS1-v1_5-DECODE .............................73\n        13.1.3. EMSA-PKCS1-v1_5 ...................................74\n   13.2. Symmetric Algorithm Preferences ..........................75\n   13.3. Other Algorithm Preferences ..............................76\n        13.3.1. Compression Preferences ...........................76\n        13.3.2. Hash Algorithm Preferences ........................76\n   13.4. Plaintext ................................................77\n   13.5. RSA ......................................................77\n   13.6. DSA ......................................................77\n   13.7. Elgamal ..................................................78\n   13.8. Reserved Algorithm Numbers ...............................78",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   13.9. OpenPGP CFB Mode .........................................78\n   13.10. Private or Experimental Parameters ......................79\n   13.11. Extension of the MDC System .............................80\n   13.12. Meta-Considerations for Expansion .......................80\n14. Security Considerations .......................................81\n15. Implementation Nits ...........................................84\n16. References ....................................................86\n   16.1. Normative References .....................................86\n   16.2. Informative References ...................................88",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides information on the message-exchange packet formats used by OpenPGP to provide encryption, decryption, signing, and key management functions. It is a revision of RFC 2440, \"OpenPGP Message Format\", which itself replaces RFC 1991, \"PGP Message Exchange Formats\" [RFC1991] [RFC2440].",
      "ja": "このドキュメントは、OpenPGPが暗号化、復号化、署名、および鍵管理機能を提供するために使用するメッセージ交換パケット形式に関する情報を提供します。これはRFC 2440「OpenPGPメッセージフォーマット」の改訂版であり、それ自体がRFC 1991「PGPメッセージ交換フォーマット」[RFC1991] [RFC2440]に置き換わるものです。"
    },
    {
      "indent": 0,
      "text": "1.1. Terms",
      "section_title": true,
      "ja": "1.1. 条項"
    },
    {
      "indent": 5,
      "text": "* OpenPGP - This is a term for security software that uses PGP 5.x as a basis, formalized in RFC 2440 and this document.",
      "ja": "* OpenPGP-これは、PGP 5.xを基礎として使用するセキュリティソフトウェアの用語であり、RFC 2440およびこのドキュメントで正式に定められています。"
    },
    {
      "indent": 5,
      "text": "* PGP - Pretty Good Privacy. PGP is a family of software systems developed by Philip R. Zimmermann from which OpenPGP is based.",
      "ja": "* PGP-かなり良いプライバシー。 PGPは、OpenPGPのベースとなっているフィリップR.ジマーマンによって開発されたソフトウェアシステムのファミリです。"
    },
    {
      "indent": 5,
      "text": "* PGP 2.6.x - This version of PGP has many variants, hence the term PGP 2.6.x. It used only RSA, MD5, and IDEA for its cryptographic transforms. An informational RFC, RFC 1991, was written describing this version of PGP.",
      "ja": "* PGP 2.6.x-このバージョンのPGPには多くのバリアントがあるため、用語PGP 2.6.xです。暗号化変換にはRSA、MD5、およびIDEAのみを使用しました。このバージョンのPGPについて説明する情報RFC（RFC 1991）が作成されました。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.x - This version of PGP is formerly known as \"PGP 3\" in the community and also in the predecessor of this document, RFC 1991. It has new formats and corrects a number of problems in the PGP 2.6.x design. It is referred to here as PGP 5.x because that software was the first release of the \"PGP 3\" code base.",
      "ja": "* PGP 5.x-このバージョンのPGPは、コミュニティおよびこのドキュメントの前身であるRFC 1991では以前「PGP 3」として知られていました。新しい形式があり、PGP 2.6.x設計の多くの問題を修正しています。このソフトウェアは「PGP 3」コードベースの最初のリリースだったため、ここではPGP 5.xと呼びます。"
    },
    {
      "indent": 5,
      "text": "* GnuPG - GNU Privacy Guard, also called GPG. GnuPG is an OpenPGP implementation that avoids all encumbered algorithms. Consequently, early versions of GnuPG did not include RSA public keys. GnuPG may or may not have (depending on version) support for IDEA or other encumbered algorithms.",
      "ja": "* GnuPG-GPGとも呼ばれるGNUプライバシーガード。 GnuPGは、すべての面倒なアルゴリズムを回避するOpenPGP実装です。その結果、GnuPGの初期のバージョンにはRSA公開鍵が含まれていませんでした。 GnuPGは（バージョンによっては）IDEAまたはその他の邪魔なアルゴリズムをサポートしている場合とサポートしていない場合があります。"
    },
    {
      "indent": 3,
      "text": "\"PGP\", \"Pretty Good\", and \"Pretty Good Privacy\" are trademarks of PGP Corporation and are used with permission. The term \"OpenPGP\" refers to the protocol described in this and related documents.",
      "ja": "「PGP」、「Pretty Good」、および「Pretty Good Privacy」はPGP Corporationの商標であり、許可を得て使用しています。 「OpenPGP」という用語は、このドキュメントおよび関連ドキュメントで説明されているプロトコルを指します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The key words \"PRIVATE USE\", \"HIERARCHICAL ALLOCATION\", \"FIRST COME FIRST SERVED\", \"EXPERT REVIEW\", \"SPECIFICATION REQUIRED\", \"IESG APPROVAL\", \"IETF CONSENSUS\", and \"STANDARDS ACTION\" that appear in this document when used to describe namespace allocation are to be interpreted as described in [RFC2434].",
      "ja": "このドキュメントに記載されているキーワード「プライベート使用」、「階層割り当て」、「最初のサービスが最初に提供されました」、「専門家によるレビュー」、「仕様が必要」、「IESG承認」、「IETF合意」、および「標準アクション」名前空間の割り当てを説明するために使用する場合、[RFC2434]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. General functions",
      "section_title": true,
      "ja": "2. 一般的な機能"
    },
    {
      "indent": 3,
      "text": "OpenPGP provides data integrity services for messages and data files by using these core technologies:",
      "ja": "OpenPGPは、次のコアテクノロジーを使用して、メッセージとデータファイルにデータ整合性サービスを提供します。"
    },
    {
      "indent": 5,
      "text": "- digital signatures",
      "ja": "- デジタル署名"
    },
    {
      "indent": 5,
      "text": "- encryption",
      "ja": "- 暗号化"
    },
    {
      "indent": 5,
      "text": "- compression",
      "ja": "- 圧縮"
    },
    {
      "indent": 5,
      "text": "- Radix-64 conversion",
      "ja": "- Radix-64変換"
    },
    {
      "indent": 3,
      "text": "In addition, OpenPGP provides key management and certificate services, but many of these are beyond the scope of this document.",
      "ja": "さらに、OpenPGPはキー管理と証明書サービスを提供しますが、これらの多くはこのドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "2.1. Confidentiality via Encryption",
      "section_title": true,
      "ja": "2.1. 暗号化による機密性"
    },
    {
      "indent": 3,
      "text": "OpenPGP combines symmetric-key encryption and public-key encryption to provide confidentiality. When made confidential, first the object is encrypted using a symmetric encryption algorithm. Each symmetric key is used only once, for a single object. A new \"session key\" is generated as a random number for each object (sometimes referred to as a session). Since it is used only once, the session key is bound to the message and transmitted with it. To protect the key, it is encrypted with the receiver's public key. The sequence is as follows:",
      "ja": "OpenPGPは、対称鍵暗号化と公開鍵暗号化を組み合わせて機密性を提供します。機密にする場合、最初にオブジェクトは対称暗号化アルゴリズムを使用して暗号化されます。各対称キーは、単一のオブジェクトに対して1回だけ使用されます。新しい「セッションキー」は、オブジェクトごとに乱数として生成されます（セッションと呼ばれることもあります）。これは1回だけ使用されるため、セッションキーはメッセージにバインドされて送信されます。キーを保護するために、受信者の公開キーで暗号化されます。シーケンスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The sender creates a message.",
      "ja": "1. 送信者がメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "2. The sending OpenPGP generates a random number to be used as a session key for this message only.",
      "ja": "2. 送信OpenPGPは、このメッセージのセッションキーとしてのみ使用される乱数を生成します。"
    },
    {
      "indent": 3,
      "text": "3. The session key is encrypted using each recipient's public key. These \"encrypted session keys\" start the message.",
      "ja": "3. セッションキーは、各受信者の公開キーを使用して暗号化されます。これらの「暗号化されたセッションキー」がメッセージを開始します。"
    },
    {
      "indent": 3,
      "text": "4. The sending OpenPGP encrypts the message using the session key, which forms the remainder of the message. Note that the message is also usually compressed.",
      "ja": "4. 送信OpenPGPは、セッションキーを使用してメッセージを暗号化します。セッションキーは、メッセージの残りの部分を形成します。通常、メッセージも圧縮されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "5. The receiving OpenPGP decrypts the session key using the recipient's private key.",
      "ja": "5. 受信OpenPGPは、受信者の秘密鍵を使用してセッションキーを復号化します。"
    },
    {
      "indent": 3,
      "text": "6. The receiving OpenPGP decrypts the message using the session key. If the message was compressed, it will be decompressed.",
      "ja": "6. 受信OpenPGPは、セッションキーを使用してメッセージを復号化します。メッセージが圧縮されている場合は、解凍されます。"
    },
    {
      "indent": 3,
      "text": "With symmetric-key encryption, an object may be encrypted with a symmetric key derived from a passphrase (or other shared secret), or a two-stage mechanism similar to the public-key method described above in which a session key is itself encrypted with a symmetric algorithm keyed from a shared secret.",
      "ja": "対称キー暗号化では、パスフレーズ（または他の共有シークレット）から派生した対称キー、またはセッションキー自体が暗号化される上記の公開キー方法と同様の2段階メカニズムでオブジェクトを暗号化できます。共有秘密から鍵をかけられた対称アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Both digital signature and confidentiality services may be applied to the same message. First, a signature is generated for the message and attached to the message. Then the message plus signature is encrypted using a symmetric session key. Finally, the session key is encrypted using public-key encryption and prefixed to the encrypted block.",
      "ja": "デジタル署名サービスと機密性サービスの両方を同じメッセージに適用できます。最初に、メッセージの署名が生成され、メッセージに添付されます。次に、メッセージと署名が対称セッションキーを使用して暗号化されます。最後に、セッションキーは公開キー暗号化を使用して暗号化され、暗号化されたブロックの前に付加されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Authentication via Digital Signature",
      "section_title": true,
      "ja": "2.2. デジタル署名による認証"
    },
    {
      "indent": 3,
      "text": "The digital signature uses a hash code or message digest algorithm, and a public-key signature algorithm. The sequence is as follows:",
      "ja": "デジタル署名は、ハッシュコードまたはメッセージダイジェストアルゴリズム、および公開鍵署名アルゴリズムを使用します。シーケンスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The sender creates a message.",
      "ja": "1. 送信者がメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "2. The sending software generates a hash code of the message.",
      "ja": "2. 送信ソフトウェアは、メッセージのハッシュコードを生成します。"
    },
    {
      "indent": 3,
      "text": "3. The sending software generates a signature from the hash code using the sender's private key.",
      "ja": "3. 送信ソフトウェアは、送信者の秘密キーを使用してハッシュコードから署名を生成します。"
    },
    {
      "indent": 3,
      "text": "4. The binary signature is attached to the message.",
      "ja": "4. バイナリ署名がメッセージに添付されます。"
    },
    {
      "indent": 3,
      "text": "5. The receiving software keeps a copy of the message signature.",
      "ja": "5. 受信ソフトウェアは、メッセージ署名のコピーを保持します。"
    },
    {
      "indent": 3,
      "text": "6. The receiving software generates a new hash code for the received message and verifies it using the message's signature. If the verification is successful, the message is accepted as authentic.",
      "ja": "6. 受信ソフトウェアは、受信したメッセージの新しいハッシュコードを生成し、メッセージの署名を使用してそれを検証します。検証が成功した場合、メッセージは信頼できるものとして受け入れられます。"
    },
    {
      "indent": 0,
      "text": "2.3. Compression",
      "section_title": true,
      "ja": "2.3. 圧縮"
    },
    {
      "indent": 3,
      "text": "OpenPGP implementations SHOULD compress the message after applying the signature but before encryption.",
      "ja": "OpenPGP実装は、署名を適用した後、暗号化する前にメッセージを圧縮する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If an implementation does not implement compression, its authors should be aware that most OpenPGP messages in the world are compressed. Thus, it may even be wise for a space-constrained implementation to implement decompression, but not compression.",
      "ja": "実装が圧縮を実装していない場合、その作成者は、世界中のほとんどのOpenPGPメッセージが圧縮されていることに注意する必要があります。したがって、スペースに制約のある実装では、圧縮ではなく解凍を実装するのが賢明な場合もあります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, compression has the added side effect that some types of attacks can be thwarted by the fact that slightly altered, compressed data rarely uncompresses without severe errors. This is hardly rigorous, but it is operationally useful. These attacks can be rigorously prevented by implementing and using Modification Detection Codes as described in sections following.",
      "ja": "さらに、圧縮には、わずかに変更された圧縮データが重大なエラーなしで圧縮解除されることはめったにないという事実によって、一部のタイプの攻撃を阻止できるという追加の副作用があります。これは厳密ではありませんが、操作上は便利です。これらの攻撃は、以下のセクションで説明する変更検出コードを実装して使用することにより、厳密に防止できます。"
    },
    {
      "indent": 0,
      "text": "2.4. Conversion to Radix-64",
      "section_title": true,
      "ja": "2.4. Radix-64への変換"
    },
    {
      "indent": 3,
      "text": "OpenPGP's underlying native representation for encrypted messages, signature certificates, and keys is a stream of arbitrary octets. Some systems only permit the use of blocks consisting of seven-bit, printable text. For transporting OpenPGP's native raw binary octets through channels that are not safe to raw binary data, a printable encoding of these binary octets is needed. OpenPGP provides the service of converting the raw 8-bit binary octet stream to a stream of printable ASCII characters, called Radix-64 encoding or ASCII Armor.",
      "ja": "暗号化されたメッセージ、署名証明書、および鍵のOpenPGPの基礎となるネイティブ表現は、任意のオクテットのストリームです。一部のシステムでは、7ビットの印刷可能なテキストで構成されるブロックの使用のみが許可されています。 OpenPGPのネイティブの生のバイナリオクテットを生のバイナリデータに対して安全ではないチャネルを介して転送するには、これらのバイナリオクテットの印刷可能なエンコードが必要です。 OpenPGPは、生の8ビットバイナリオクテットストリームを、Radix-64エンコーディングまたはASCIIアーマーと呼ばれる印刷可能なASCII文字のストリームに変換するサービスを提供します。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD provide Radix-64 conversions.",
      "ja": "実装は、Radix-64変換を提供する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "2.5. Signature-Only Applications",
      "section_title": true,
      "ja": "2.5. 署名のみのアプリケーション"
    },
    {
      "indent": 3,
      "text": "OpenPGP is designed for applications that use both encryption and signatures, but there are a number of problems that are solved by a signature-only implementation. Although this specification requires both encryption and signatures, it is reasonable for there to be subset implementations that are non-conformant only in that they omit encryption.",
      "ja": "OpenPGPは、暗号化と署名の両方を使用するアプリケーション向けに設計されていますが、署名のみの実装によって解決される多くの問題があります。この仕様では暗号化と署名の両方が必要ですが、暗号化を省略しているという点でのみ非準拠であるサブセット実装が存在することは妥当です。"
    },
    {
      "indent": 0,
      "text": "3. Data Element Formats",
      "section_title": true,
      "ja": "3. データ要素の形式"
    },
    {
      "indent": 3,
      "text": "This section describes the data elements used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPで使用されるデータ要素について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Scalar Numbers",
      "section_title": true,
      "ja": "3.1. スカラー数"
    },
    {
      "indent": 3,
      "text": "Scalar numbers are unsigned and are always stored in big-endian format. Using n[k] to refer to the kth octet being interpreted, the value of a two-octet scalar is ((n[0] << 8) + n[1]). The value of a four-octet scalar is ((n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]).",
      "ja": "スカラー数は符号なしで、常にビッグエンディアン形式で格納されます。 n [k]を使用して解釈されるk番目のオクテットを参照すると、2オクテットのスカラーの値は（（n [0] << 8）+ n [1]）になります。 4オクテットスカラーの値は、（（n [0] << 24）+（n [1] << 16）+（n [2] << 8）+ n [3]）です。"
    },
    {
      "indent": 0,
      "text": "3.2. Multiprecision Integers",
      "section_title": true,
      "ja": "3.2. 多倍長整数"
    },
    {
      "indent": 3,
      "text": "Multiprecision integers (also called MPIs) are unsigned integers used to hold large integers such as the ones used in cryptographic calculations.",
      "ja": "倍精度整数（MPIとも呼ばれます）は、暗号計算で使用される整数など、大きな整数を保持するために使用される符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "An MPI consists of two pieces: a two-octet scalar that is the length of the MPI in bits followed by a string of octets that contain the actual integer.",
      "ja": "MPIは2つの部分で構成されています。2オクテットのスカラーで、ビット単位のMPIの後に、実際の整数を含むオクテットの文字列が続きます。"
    },
    {
      "indent": 3,
      "text": "These octets form a big-endian number; a big-endian number can be made into an MPI by prefixing it with the appropriate length.",
      "ja": "これらのオクテットはビッグエンディアン番号を形成します。ビッグエンディアン番号は、適切な長さのプレフィックスを付けることでMPIにすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "(all numbers are in hexadecimal)",
      "ja": "（すべての数値は16進数です）"
    },
    {
      "indent": 3,
      "text": "The string of octets [00 01 01] forms an MPI with the value 1. The string [00 09 01 FF] forms an MPI with the value of 511.",
      "ja": "オクテットの文字列[00 01 01]は値1のMPIを形成します。文字列[00 09 01 FF]は値511のMPIを形成します。"
    },
    {
      "indent": 3,
      "text": "Additional rules:",
      "ja": "追加のルール："
    },
    {
      "indent": 3,
      "text": "The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.",
      "ja": "MPIのサイズは（（MPI.length + 7）/ 8）+ 2オクテットです。"
    },
    {
      "indent": 3,
      "text": "The length field of an MPI describes the length starting from its most significant non-zero bit. Thus, the MPI [00 02 01] is not formed correctly. It should be [00 01 01].",
      "ja": "MPIの長さフィールドは、最上位のゼロ以外のビットから始まる長さを示します。したがって、MPI [00 02 01]は正しく形成されません。 [00 01 01]である必要があります。"
    },
    {
      "indent": 3,
      "text": "Unused bits of an MPI MUST be zero.",
      "ja": "MPIの未使用ビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Also note that when an MPI is encrypted, the length refers to the plaintext MPI. It may be ill-formed in its ciphertext.",
      "ja": "また、MPIが暗号化されている場合、長さはプレーンテキストMPIを指すことに注意してください。暗号文の形式が正しくない可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Key IDs",
      "section_title": true,
      "ja": "3.3. キーID"
    },
    {
      "indent": 3,
      "text": "A Key ID is an eight-octet scalar that identifies a key. Implementations SHOULD NOT assume that Key IDs are unique. The section \"Enhanced Key Formats\" below describes how Key IDs are formed.",
      "ja": "キーIDは、キーを識別する8オクテットのスカラーです。実装では、キーIDが一意であると想定しないでください。以下の「拡張キー形式」セクションでは、キーIDの形成方法について説明します。"
    },
    {
      "indent": 0,
      "text": "3.4. Text",
      "section_title": true,
      "ja": "3.4. テキスト"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified, the character set for text is the UTF-8 [RFC3629] encoding of Unicode [ISO10646].",
      "ja": "特に指定のない限り、テキストの文字セットはUnicode [ISO10646]のUTF-8 [RFC3629]エンコーディングです。"
    },
    {
      "indent": 0,
      "text": "3.5. Time Fields",
      "section_title": true,
      "ja": "3.5. 時間フィールド"
    },
    {
      "indent": 3,
      "text": "A time field is an unsigned four-octet number containing the number of seconds elapsed since midnight, 1 January 1970 UTC.",
      "ja": "時間フィールドは、1970年1月1日UTCの午前0時から経過した秒数を含む、符号なしの4オクテット数です。"
    },
    {
      "indent": 0,
      "text": "3.6. Keyrings",
      "section_title": true,
      "ja": "3.6. キーリング"
    },
    {
      "indent": 3,
      "text": "A keyring is a collection of one or more keys in a file or database. Traditionally, a keyring is simply a sequential list of keys, but may be any suitable database. It is beyond the scope of this standard to discuss the details of keyrings or other databases.",
      "ja": "キーリングは、ファイルまたはデータベース内の1つ以上のキーのコレクションです。伝統的に、キーリングは単にキーの連続したリストですが、適切なデータベースであれば何でもかまいません。キーリングやその他のデータベースの詳細について議論することは、この標準の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "3.7. String-to-Key (S2K) Specifiers",
      "section_title": true,
      "ja": "3.7. String-to-Key（S2K）指定子"
    },
    {
      "indent": 3,
      "text": "String-to-key (S2K) specifiers are used to convert passphrase strings into symmetric-key encryption/decryption keys. They are used in two places, currently: to encrypt the secret part of private keys in the private keyring, and to convert passphrases to encryption keys for symmetrically encrypted messages.",
      "ja": "文字列からキー（S2K）指定子は、パスフレーズ文字列を対称キーの暗号化/復号化キーに変換するために使用されます。現在、2つの場所で使用されています。秘密鍵リングの秘密鍵の秘密部分を暗号化することと、対称的に暗号化されたメッセージのパスフレーズを暗号鍵に変換することです。"
    },
    {
      "indent": 0,
      "text": "3.7.1. String-to-Key (S2K) Specifier Types",
      "section_title": true,
      "ja": "3.7.1. String-to-Key（S2K）指定子タイプ"
    },
    {
      "indent": 3,
      "text": "There are three types of S2K specifiers currently supported, and some reserved values:",
      "ja": "現在サポートされているS2K指定子には3つのタイプがあり、いくつかの予約値があります。"
    },
    {
      "indent": 7,
      "text": "ID          S2K Type\n--          --------\n0           Simple S2K\n1           Salted S2K\n2           Reserved value\n3           Iterated and Salted S2K\n100 to 110  Private/Experimental S2K",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These are described in Sections 3.7.1.1 - 3.7.1.3.",
      "ja": "これらについては、セクション3.7.1.1から3.7.1.3で説明します。"
    },
    {
      "indent": 0,
      "text": "3.7.1.1. Simple S2K",
      "section_title": true,
      "ja": "3.7.1.1. シンプルなS2K"
    },
    {
      "indent": 3,
      "text": "This directly hashes the string to produce the key data. See below for how this hashing is done.",
      "ja": "これにより、文字列が直接ハッシュされ、キーデータが生成されます。このハッシュがどのように行われるかについては、以下を参照してください。"
    },
    {
      "indent": 7,
      "text": "Octet 0: 0x00 Octet 1: hash algorithm",
      "ja": "オクテット0：0x00オクテット1：ハッシュアルゴリズム"
    },
    {
      "indent": 0,
      "text": " Simple S2K hashes the passphrase to produce the session key. The manner in which this is done depends on the size of the session key (which will depend on the cipher used) and the size of the hash algorithm's output. If the hash size is greater than the session key size, the high-order (leftmost) octets of the hash are used as the key.",
      "ja": "単純なS2Kは、パスフレーズをハッシュしてセッションキーを生成します。これが行われる方法は、セッションキーのサイズ（使用される暗号に依存します）とハッシュアルゴリズムの出力のサイズによって異なります。ハッシュサイズがセッションキーサイズより大きい場合、ハッシュの上位（左端）オクテットがキーとして使用されます。"
    },
    {
      "indent": 3,
      "text": "If the hash size is less than the key size, multiple instances of the hash context are created -- enough to produce the required key data. These instances are preloaded with 0, 1, 2, ... octets of zeros (that is to say, the first instance has no preloading, the second gets preloaded with 1 octet of zero, the third is preloaded with two octets of zeros, and so forth).",
      "ja": "ハッシュサイズがキーサイズより小さい場合、必要なキーデータを生成するのに十分な、ハッシュコンテキストの複数のインスタンスが作成されます。これらのインスタンスには0、1、2、...のゼロのオクテットがプリロードされています（つまり、最初のインスタンスにはプリロードがありません。2番目のインスタンスには1オクテットのゼロがプリロードされ、3番目のインスタンスには2つのオクテットのゼロがプリロードされます。など）。"
    },
    {
      "indent": 3,
      "text": "As the data is hashed, it is given independently to each hash context. Since the contexts have been initialized differently, they will each produce different hash output. Once the passphrase is hashed, the output data from the multiple hashes is concatenated, first hash leftmost, to produce the key data, with any excess octets on the right discarded.",
      "ja": "データはハッシュされるため、各ハッシュコンテキストに個別に与えられます。コンテキストは異なる方法で初期化されているため、コンテキストごとに異なるハッシュ出力が生成されます。パスフレーズがハッシュされると、複数のハッシュからの出力データが連結され、最初のハッシュが左端になり、右側の余分なオクテットが破棄されたキーデータが生成されます。"
    },
    {
      "indent": 0,
      "text": "3.7.1.2. Salted S2K",
      "section_title": true,
      "ja": "3.7.1.2. 塩漬けS2K"
    },
    {
      "indent": 3,
      "text": "This includes a \"salt\" value in the S2K specifier -- some arbitrary data -- that gets hashed along with the passphrase string, to help prevent dictionary attacks.",
      "ja": "これには、辞書攻撃を防止するために、パスフレーズ文字列とともにハッシュされるS2K指定子の「塩」値（一部の任意のデータ）が含まれます。"
    },
    {
      "indent": 7,
      "text": "Octet 0: 0x01 Octet 1: hash algorithm Octets 2-9: 8-octet salt value",
      "ja": "オクテット0：0x01オクテット1：ハッシュアルゴリズムオクテット2-9：8オクテットソルト値"
    },
    {
      "indent": 3,
      "text": "Salted S2K is exactly like Simple S2K, except that the input to the hash function(s) consists of the 8 octets of salt from the S2K specifier, followed by the passphrase.",
      "ja": "Salted S2KはSimple S2Kとまったく同じですが、ハッシュ関数への入力がS2K指定子からの8オクテットのsaltで構成され、その後にパスフレーズが続く点が異なります。"
    },
    {
      "indent": 0,
      "text": "3.7.1.3. Iterated and Salted S2K",
      "section_title": true,
      "ja": "3.7.1.3. 反復およびソルト処理されたS2K"
    },
    {
      "indent": 3,
      "text": "This includes both a salt and an octet count. The salt is combined with the passphrase and the resulting value is hashed repeatedly. This further increases the amount of work an attacker must do to try dictionary attacks.",
      "ja": "これには、塩分とオクテット数の両方が含まれます。ソルトはパスフレーズと組み合わされ、結果の値は繰り返しハッシュされます。これにより、辞書攻撃を試みるために攻撃者が実行しなければならない作業量がさらに増加し​​ます。"
    },
    {
      "indent": 7,
      "text": "Octet 0: 0x03 Octet 1: hash algorithm Octets 2-9: 8-octet salt value Octet 10: count, a one-octet, coded value",
      "ja": "オクテット0：0x03オクテット1：ハッシュアルゴリズムオクテット2-9：8オクテットソルト値オクテット10：カウント、1オクテット、コード化された値"
    },
    {
      "indent": 3,
      "text": "The count is coded into a one-octet number using the following formula:",
      "ja": "カウントは、次の式を使用して1オクテットの数値にコード化されます。"
    },
    {
      "indent": 7,
      "text": "#define EXPBIAS 6\n    count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above formula is in C, where \"Int32\" is a type for a 32-bit integer, and the variable \"c\" is the coded count, Octet 10.",
      "ja": "上記の式はCであり、「Int32」は32ビット整数の型、変数「c」はコード化されたカウント、オクテット10です。"
    },
    {
      "indent": 3,
      "text": "Iterated-Salted S2K hashes the passphrase and salt data multiple times. The total number of octets to be hashed is specified in the encoded count in the S2K specifier. Note that the resulting count value is an octet count of how many octets will be hashed, not an iteration count.",
      "ja": "Iterated-Salted S2Kは、パスフレーズとソルトデータを複数回ハッシュします。ハッシュされるオクテットの総数は、S2K指定子のエンコードされたカウントで指定されます。結果のカウント値は、ハッシュされるオクテットの数のオクテットカウントであり、反復カウントではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Initially, one or more hash contexts are set up as with the other S2K algorithms, depending on how many octets of key data are needed. Then the salt, followed by the passphrase data, is repeatedly hashed until the number of octets specified by the octet count has been hashed. The one exception is that if the octet count is less than the size of the salt plus passphrase, the full salt plus passphrase will be hashed even though that is greater than the octet count. After the hashing is done, the data is unloaded from the hash context(s) as with the other S2K algorithms.",
      "ja": "最初に、必要なキーデータのオクテット数に応じて、1つ以上のハッシュコンテキストが他のS2Kアルゴリズムと同様に設定されます。次に、オクテットカウントで指定されたオクテット数がハッシュされるまで、ソルトとそれに続くパスフレーズデータが繰り返しハッシュされます。 1つの例外は、オクテットカウントがソルトとパスフレーズのサイズより小さい場合、オクテットカウントよりも大きくても、完全なソルトとパスフレーズがハッシュされることです。ハッシュが行われた後、他のS2Kアルゴリズムと同様に、データはハッシュコンテキストからアンロードされます。"
    },
    {
      "indent": 0,
      "text": "3.7.2. String-to-Key Usage",
      "section_title": true,
      "ja": "3.7.2. 文字列からキーへの使用"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD use salted or iterated-and-salted S2K specifiers, as simple S2K specifiers are more vulnerable to dictionary attacks.",
      "ja": "単純なS2K指定子は辞書攻撃に対してより脆弱であるため、実装では、ソルト付きまたは反復および塩入れ済みのS2K指定子を使用する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "3.7.2.1. Secret-Key Encryption",
      "section_title": true,
      "ja": "3.7.2.1. 秘密鍵の暗号化"
    },
    {
      "indent": 3,
      "text": "An S2K specifier can be stored in the secret keyring to specify how to convert the passphrase to a key that unlocks the secret data. Older versions of PGP just stored a cipher algorithm octet preceding the secret data or a zero to indicate that the secret data was unencrypted. The MD5 hash function was always used to convert the passphrase to a key for the specified cipher algorithm.",
      "ja": "S2K指定子をシークレットキーリングに格納して、パスフレーズをシークレットデータのロックを解除するキーに変換する方法を指定できます。古いバージョンのPGPは、秘密データの前に暗号アルゴリズムオクテットを格納したか、秘密データが暗号化されていないことを示すゼロを格納していました。パスフレーズを指定された暗号アルゴリズムのキーに変換するために、常にMD5ハッシュ関数が使用されました。"
    },
    {
      "indent": 3,
      "text": "For compatibility, when an S2K specifier is used, the special value 254 or 255 is stored in the position where the hash algorithm octet would have been in the old data structure. This is then followed immediately by a one-octet algorithm identifier, and then by the S2K specifier as encoded above.",
      "ja": "互換性のために、S2K指定子が使用される場合、ハッシュアルゴリズムオクテットが古いデータ構造内にあったはずの位置に、特別な値254または255が格納されます。この直後に1オクテットのアルゴリズム識別子が続き、次に上記でエンコードしたS2K指定子が続きます。"
    },
    {
      "indent": 3,
      "text": "Therefore, preceding the secret data there will be one of these possibilities:",
      "ja": "したがって、秘密データの前に、次のいずれかの可能性があります。"
    },
    {
      "indent": 7,
      "text": "0: secret data is unencrypted (no passphrase) 255 or 254: followed by algorithm octet and S2K specifier Cipher alg: use Simple S2K algorithm using MD5 hash",
      "ja": "0：秘密データは暗号化されていない（パスフレーズなし）255または254：アルゴリズムオクテットとS2K指定子が続くCipher alg：MD5ハッシュを使用した単純なS2Kアルゴリズムを使用"
    },
    {
      "indent": 3,
      "text": "This last possibility, the cipher algorithm number with an implicit use of MD5 and IDEA, is provided for backward compatibility; it MAY be understood, but SHOULD NOT be generated, and is deprecated.",
      "ja": "この最後の可能性であるMD5とIDEAを暗黙的に使用する暗号アルゴリズム番号は、下位互換性のために提供されています。それは理解されるかもしれませんが、生成されるべきではなく、非推奨です。"
    },
    {
      "indent": 3,
      "text": "These are followed by an Initial Vector of the same length as the block size of the cipher for the decryption of the secret values, if they are encrypted, and then the secret-key values themselves.",
      "ja": "これらの後には、シークレット値が暗号化されている場合はそれを復号化するための暗号のブロックサイズと同じ長さの初期ベクトルが続き、次にシークレットキー値自体が続きます。"
    },
    {
      "indent": 0,
      "text": "3.7.2.2. Symmetric-Key Message Encryption",
      "section_title": true,
      "ja": "3.7.2.2. 対称鍵メッセージの暗号化"
    },
    {
      "indent": 3,
      "text": "OpenPGP can create a Symmetric-key Encrypted Session Key (ESK) packet at the front of a message. This is used to allow S2K specifiers to be used for the passphrase conversion or to create messages with a mix of symmetric-key ESKs and public-key ESKs. This allows a message to be decrypted either with a passphrase or a public-key pair.",
      "ja": "OpenPGPは、メッセージの前に対称鍵暗号化セッションキー（ESK）パケットを作成できます。これは、パスフレーズ変換にS2K指定子を使用できるようにするため、または対称鍵ESKと公開鍵ESKが混在するメッセージを作成するために使用されます。これにより、メッセージをパスフレーズまたは公開鍵ペアのいずれかで復号化できます。"
    },
    {
      "indent": 3,
      "text": "PGP 2.X always used IDEA with Simple string-to-key conversion when encrypting a message with a symmetric algorithm. This is deprecated, but MAY be used for backward-compatibility.",
      "ja": "PGP 2.Xは、対称アルゴリズムでメッセージを暗号化するときに、常にIDEAをシンプルな文字列からキーへの変換で使用していました。これは非推奨ですが、下位互換性のために使用される場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Packet Syntax",
      "section_title": true,
      "ja": "4. パケット構文"
    },
    {
      "indent": 3,
      "text": "This section describes the packets used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPで使用されるパケットについて説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Overview",
      "section_title": true,
      "ja": "4.1. 概観"
    },
    {
      "indent": 3,
      "text": "An OpenPGP message is constructed from a number of records that are traditionally called packets. A packet is a chunk of data that has a tag specifying its meaning. An OpenPGP message, keyring, certificate, and so forth consists of a number of packets. Some of those packets may contain other OpenPGP packets (for example, a compressed data packet, when uncompressed, contains OpenPGP packets).",
      "ja": "OpenPGPメッセージは、従来パケットと呼ばれていたいくつかのレコードから構成されます。パケットは、その意味を指定するタグを持つデータのチャンクです。 OpenPGPメッセージ、キーリング、証明書などは、いくつかのパケットで構成されています。これらのパケットの一部には、他のOpenPGPパケットが含まれている可能性があります（たとえば、圧縮されていない場合、圧縮データパケットにはOpenPGPパケットが含まれています）。"
    },
    {
      "indent": 3,
      "text": "Each packet consists of a packet header, followed by the packet body. The packet header is of variable length.",
      "ja": "各パケットは、パケットヘッダーとそれに続くパケット本文で構成されます。パケットヘッダーは可変長です。"
    },
    {
      "indent": 0,
      "text": "4.2. Packet Headers",
      "section_title": true,
      "ja": "4.2. パケットヘッダー"
    },
    {
      "indent": 3,
      "text": "The first octet of the packet header is called the \"Packet Tag\". It determines the format of the header and denotes the packet contents. The remainder of the packet header is the length of the packet.",
      "ja": "パケットヘッダーの最初のオクテットは「パケットタグ」と呼ばれます。ヘッダーの形式を決定し、パケットの内容を示します。パケットヘッダーの残りの部分は、パケットの長さです。"
    },
    {
      "indent": 3,
      "text": "Note that the most significant bit is the leftmost bit, called bit 7. A mask for this bit is 0x80 in hexadecimal.",
      "ja": "最上位ビットはビット7と呼ばれる左端のビットであることに注意してください。このビットのマスクは16進数で0x80です。"
    },
    {
      "indent": 9,
      "text": "     +---------------+\nPTag |7 6 5 4 3 2 1 0|\n     +---------------+\nBit 7 -- Always one\nBit 6 -- New packet format if set",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PGP 2.6.x only uses old format packets. Thus, software that interoperates with those versions of PGP must only use old format packets. If interoperability is not an issue, the new packet format is RECOMMENDED. Note that old format packets have four bits of packet tags, and new format packets have six; some features cannot be used and still be backward-compatible.",
      "ja": "PGP 2.6.xは古い形式のパケットのみを使用します。したがって、これらのバージョンのPGPと相互運用するソフトウェアは、古い形式のパケットのみを使用する必要があります。相互運用性が問題でない場合は、新しいパケット形式が推奨されます。古い形式のパケットには4ビットのパケットタグがあり、新しい形式のパケットには6ビットがあることに注意してください。一部の機能は使用できず、下位互換性があります。"
    },
    {
      "indent": 3,
      "text": "Also note that packets with a tag greater than or equal to 16 MUST use new format packets. The old format packets can only express tags less than or equal to 15.",
      "ja": "また、タグが16以上のパケットは、新しい形式のパケットを使用する必要があることに注意してください。古い形式のパケットは、15以下のタグしか表現できません。"
    },
    {
      "indent": 3,
      "text": "Old format packets contain:",
      "ja": "古い形式のパケットには以下が含まれます："
    },
    {
      "indent": 9,
      "text": "Bits 5-2 -- packet tag Bits 1-0 -- length-type",
      "ja": "ビット5-2-パケットタグビット1-0-長さタイプ"
    },
    {
      "indent": 3,
      "text": "New format packets contain:",
      "ja": "新しいフォーマットのパケットには以下が含まれます："
    },
    {
      "indent": 9,
      "text": "Bits 5-0 -- packet tag",
      "ja": "ビット5-0-パケットタグ"
    },
    {
      "indent": 0,
      "text": "4.2.1. Old Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.1. 古い形式のパケット長"
    },
    {
      "indent": 3,
      "text": "The meaning of the length-type in old format packets is:",
      "ja": "古い形式のパケットにおける長さタイプの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0 - The packet has a one-octet length. The header is 2 octets long.",
      "ja": "0-パケットの長さは1オクテットです。ヘッダーの長さは2オクテットです。"
    },
    {
      "indent": 3,
      "text": "1 - The packet has a two-octet length. The header is 3 octets long.",
      "ja": "1-パケットの長さは2オクテットです。ヘッダーの長さは3オクテットです。"
    },
    {
      "indent": 3,
      "text": "2 - The packet has a four-octet length. The header is 5 octets long.",
      "ja": "2-パケットの長さは4オクテットです。ヘッダーの長さは5オクテットです。"
    },
    {
      "indent": 3,
      "text": "3 - The packet is of indeterminate length. The header is 1 octet long, and the implementation must determine how long the packet is. If the packet is in a file, this means that the packet extends until the end of the file. In general, an implementation SHOULD NOT use indeterminate-length packets except where the end of the data will be clear from the context, and even then it is better to use a definite length, or a new format header. The new format headers described below have a mechanism for precisely encoding data of indeterminate length.",
      "ja": "3-パケットの長さは不定です。ヘッダーは1オクテット長であり、実装はパケットの長さを決定する必要があります。パケットがファイル内にある場合、これはパケットがファイルの終わりまで続くことを意味します。一般に、実装は、データの終わりがコンテキストから明確になる場合を除いて、不定長パケットを使用すべきではなく（SHOULD NOT）、それでも、明確な長さまたは新しいフォーマットヘッダーを使用することをお勧めします。以下で説明する新しい形式のヘッダーには、不定の長さのデータを正確にエンコードするメカニズムがあります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. New Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.2. 新しい形式のパケット長"
    },
    {
      "indent": 3,
      "text": "New format packets have four possible ways of encoding length:",
      "ja": "新しい形式のパケットには、長さをエンコードする4つの可能な方法があります。"
    },
    {
      "indent": 3,
      "text": "1. A one-octet Body Length header encodes packet lengths of up to 191 octets.",
      "ja": "1. 1オクテットのBody Lengthヘッダーは、最大191オクテットのパケット長をエンコードします。"
    },
    {
      "indent": 3,
      "text": "2. A two-octet Body Length header encodes packet lengths of 192 to 8383 octets.",
      "ja": "2. 2オクテットのBody Lengthヘッダーは、192〜8383オクテットのパケット長をエンコードします。"
    },
    {
      "indent": 3,
      "text": "3. A five-octet Body Length header encodes packet lengths of up to 4,294,967,295 (0xFFFFFFFF) octets in length. (This actually encodes a four-octet scalar number.)",
      "ja": "3. 5オクテットのBody Lengthヘッダーは、最大4,294,967,295（0xFFFFFFFF）オクテットのパケット長をエンコードします。 （これは実際には4オクテットのスカラー数をエンコードします。）"
    },
    {
      "indent": 3,
      "text": "4. When the length of the packet body is not known in advance by the issuer, Partial Body Length headers encode a packet of indeterminate length, effectively making it a stream.",
      "ja": "4. パケットボディの長さが発行者によって事前にわからない場合、Partial Body Lengthヘッダーは長さが不定のパケットをエンコードし、事実上ストリームにします。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. One-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.1. 1オクテットの長さ"
    },
    {
      "indent": 3,
      "text": "A one-octet Body Length header encodes a length of 0 to 191 octets. This type of length header is recognized because the one octet value is less than 192. The body length is equal to:",
      "ja": "1オクテットのBody Lengthヘッダーは、0〜191オクテットの長さをエンコードします。このタイプの長さヘッダーは、1オクテットの値が192未満であるために認識されます。本文の長さは次と等しくなります。"
    },
    {
      "indent": 7,
      "text": "bodyLen = 1st_octet;",
      "ja": "bodyLen = 1st_octet;"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Two-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.2. 2オクテットの長さ"
    },
    {
      "indent": 3,
      "text": "A two-octet Body Length header encodes a length of 192 to 8383 octets. It is recognized because its first octet is in the range 192 to 223. The body length is equal to:",
      "ja": "2オクテットのBody Lengthヘッダーは、192〜8383オクテットの長さをエンコードします。これは、最初のオクテットが192から223の範囲にあるために認識されます。本文の長さは次と等しくなります。"
    },
    {
      "indent": 7,
      "text": "bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Five-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.3. 5オクテットの長さ"
    },
    {
      "indent": 3,
      "text": "A five-octet Body Length header consists of a single octet holding the value 255, followed by a four-octet scalar. The body length is equal to:",
      "ja": "5オクテットのBody Lengthヘッダーは、値が255の単一オクテットと、それに続く4オクテットスカラーで構成されます。ボディの長さは次と等しくなります。"
    },
    {
      "indent": 7,
      "text": "bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |\n          (4th_octet << 8)  | 5th_octet",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This basic set of one, two, and five-octet lengths is also used internally to some packets.",
      "ja": "この1、2、および5オクテット長の基本セットは、一部のパケットに対して内部的にも使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2.4. Partial Body Lengths",
      "section_title": true,
      "ja": "4.2.2.4. 部分的な体長"
    },
    {
      "indent": 3,
      "text": "A Partial Body Length header is one octet long and encodes the length of only part of the data packet. This length is a power of 2, from 1 to 1,073,741,824 (2 to the 30th power). It is recognized by its one octet value that is greater than or equal to 224, and less than 255. The Partial Body Length is equal to:",
      "ja": "Partial Body Lengthヘッダーは1オクテット長で、データパケットの一部のみの長さをエンコードします。この長さは2の累乗で、1から1,073,741,824（2の30乗）です。 224以上255未満の1オクテット値で認識されます。部分的なボディ長は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "partialBodyLen = 1 << (1st_octet & 0x1F);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Partial Body Length header is followed by a portion of the packet body data. The Partial Body Length header specifies this portion's length. Another length header (one octet, two-octet, five-octet, or partial) follows that portion. The last length header in the packet MUST NOT be a Partial Body Length header. Partial Body Length headers may only be used for the non-final parts of the packet.",
      "ja": "各Partial Body Lengthヘッダーの後には、パケットボディデータの一部が続きます。 Partial Body Lengthヘッダーは、この部分の長さを指定します。その部分の後に、別の長さのヘッダー（1オクテット、2オクテット、5オクテット、または部分的）が続きます。パケットの最後の長さのヘッダーは、部分的な本体の長さのヘッダーであってはなりません。 Partial Body Lengthヘッダーは、パケットの非最終部分にのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "Note also that the last Body Length header can be a zero-length header.",
      "ja": "最後のBody Lengthヘッダーは長さゼロのヘッダーでもかまいません。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use Partial Body Lengths for data packets, be they literal, compressed, or encrypted. The first partial length MUST be at least 512 octets long. Partial Body Lengths MUST NOT be used for any other packet types.",
      "ja": "実装では、リテラル、圧縮、暗号化のいずれの場合でも、データパケットに部分的なボディ長を使用できます。最初の部分的な長さは少なくとも512オクテットの長さでなければなりません。部分的なボディ長は、他のパケットタイプには使用しないでください。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Packet Length Examples",
      "section_title": true,
      "ja": "4.2.3. パケット長の例"
    },
    {
      "indent": 3,
      "text": "These examples show ways that new format packets might encode the packet lengths.",
      "ja": "これらの例は、新しい形式のパケットがパケット長をエンコードする方法を示しています。"
    },
    {
      "indent": 3,
      "text": "A packet with length 100 may have its length encoded in one octet: 0x64. This is followed by 100 octets of data.",
      "ja": "長さが100のパケットは、その長さが1オクテットでエンコードされる場合があります：0x64。この後に100オクテットのデータが続きます。"
    },
    {
      "indent": 3,
      "text": "A packet with length 1723 may have its length encoded in two octets: 0xC5, 0xFB. This header is followed by the 1723 octets of data.",
      "ja": "長さが1723のパケットは、その長さが2つのオクテット（0xC5、0xFB）でエンコードされている場合があります。このヘッダーの後には、1723オクテットのデータが続きます。"
    },
    {
      "indent": 3,
      "text": "A packet with length 100000 may have its length encoded in five octets: 0xFF, 0x00, 0x01, 0x86, 0xA0.",
      "ja": "長さが100000のパケットは、5オクテット（0xFF、0x00、0x01、0x86、0xA0）でエンコードされた長さを持つ場合があります。"
    },
    {
      "indent": 3,
      "text": "It might also be encoded in the following octet stream: 0xEF, first 32768 octets of data; 0xE1, next two octets of data; 0xE0, next one octet of data; 0xF0, next 65536 octets of data; 0xC5, 0xDD, last 1693 octets of data. This is just one possible encoding, and many variations are possible on the size of the Partial Body Length headers, as long as a regular Body Length header encodes the last portion of the data.",
      "ja": "また、次のオクテットストリームでエンコードされる場合もあります。0xEF、最初の32768オクテットのデータ。 0xE1、次の2オクテットのデータ。 0xE0、次の1オクテットのデータ。 0xF0、次の65536オクテットのデータ。 0xC5、0xDD、最後の1693オクテットのデータ。これは可能なエンコードの1つにすぎず、通常のBody Lengthヘッダーがデータの最後の部分をエンコードする限り、Partial Body Lengthヘッダーのサイズに多くのバリエーションが可能です。"
    },
    {
      "indent": 3,
      "text": "Please note that in all of these explanations, the total length of the packet is the length of the header(s) plus the length of the body.",
      "ja": "これらすべての説明で、パケットの全長はヘッダーの長さと本文の長さの合計であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Packet Tags",
      "section_title": true,
      "ja": "4.3. パケットタグ"
    },
    {
      "indent": 3,
      "text": "The packet tag denotes what type of packet the body holds. Note that old format headers can only have tags less than 16, whereas new format headers can have tags as great as 63. The defined tags (in decimal) are as follows:",
      "ja": "パケットタグは、ボディが保持するパケットのタイプを示します。古い形式のヘッダーは16未満のタグしか持つことができないのに対し、新しい形式のヘッダーは63ものタグを含めることができることに注意してください。定義されたタグ（10進数）は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "0 -- Reserved - a packet tag MUST NOT have this value 1 -- Public-Key Encrypted Session Key Packet 2 -- Signature Packet 3 -- Symmetric-Key Encrypted Session Key Packet 4 -- One-Pass Signature Packet 5 -- Secret-Key Packet 6 -- Public-Key Packet 7 -- Secret-Subkey Packet 8 -- Compressed Data Packet 9 -- Symmetrically Encrypted Data Packet 10 -- Marker Packet 11 -- Literal Data Packet 12 -- Trust Packet 13 -- User ID Packet 14 -- Public-Subkey Packet 17 -- User Attribute Packet 18 -- Sym. Encrypted and Integrity Protected Data Packet 19 -- Modification Detection Code Packet 60 to 63 -- Private or Experimental Values",
      "ja": "0-予約済み-パケットタグはこの値を持っていてはなりません1-公開鍵暗号化セッションキーパケット2-署名パケット3-対称鍵暗号化セッションキーパケット4-ワンパス署名パケット5-秘密-キーパケット6-公開キーパケット7-シークレットサブキーパケット8-圧縮データパケット9-対称的に暗号化されたデータパケット10-マーカーパケット11-リテラルデータパケット12-信頼パケット13-ユーザーIDパケット14-公開サブキーパケット17-ユーザー属性パケット18-対称。暗号化および整合性保護されたデータパケット19-変更検出コードパケット60〜63-プライベートまたは実験値"
    },
    {
      "indent": 0,
      "text": "5. Packet Types",
      "section_title": true,
      "ja": "5. パケットタイプ"
    },
    {
      "indent": 0,
      "text": "5.1. Public-Key Encrypted Session Key Packets (Tag 1)",
      "section_title": true,
      "ja": "5.1. 公開鍵暗号化セッション鍵パケット（タグ1）"
    },
    {
      "indent": 3,
      "text": "A Public-Key Encrypted Session Key packet holds the session key used to encrypt a message. Zero or more Public-Key Encrypted Session Key packets and/or Symmetric-Key Encrypted Session Key packets may precede a Symmetrically Encrypted Data Packet, which holds an encrypted message. The message is encrypted with the session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet(s). The Symmetrically Encrypted Data Packet is preceded by one Public-Key Encrypted Session Key packet for each OpenPGP key to which the message is encrypted. The recipient of the message finds a session key that is encrypted to their public key, decrypts the session key, and then uses the session key to decrypt the message.",
      "ja": "公開鍵暗号化セッションキーパケットは、メッセージの暗号化に使用されるセッションキーを保持します。ゼロ以上の公開キー暗号化セッションキーパケットおよび/または対称キー暗号化セッションキーパケットは、暗号化メッセージを保持する対称暗号化データパケットの前にある場合があります。メッセージはセッションキーで暗号化され、セッションキー自体が暗号化されて、暗号化されたセッションキーパケットに格納されます。対称的に暗号化されたデータパケットの前には、メッセージが暗号化されるOpenPGPキーごとに1つの公開キー暗号化セッションキーパケットがあります。メッセージの受信者は、公開鍵で暗号化されたセッションキーを見つけ、セッションキーを復号化してから、セッションキーを使用してメッセージを復号化します。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number giving the version number of the packet type. The currently defined value for packet version is 3.",
      "ja": "- パケットタイプのバージョン番号を示す1オクテット番号。現在定義されているパケットバージョンの値は3です。"
    },
    {
      "indent": 5,
      "text": "- An eight-octet number that gives the Key ID of the public key to which the session key is encrypted. If the session key is encrypted to a subkey, then the Key ID of this subkey is used here instead of the Key ID of the primary key.",
      "ja": "- セッションキーが暗号化される公開キーのキーIDを提供する8オクテットの数値。セッションキーがサブキーに暗号化されている場合、ここでは主キーのキーIDの代わりにこのサブキーのキーIDが使用されます。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number giving the public-key algorithm used.",
      "ja": "- 使用される公開鍵アルゴリズムを示す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A string of octets that is the encrypted session key. This string takes up the remainder of the packet, and its contents are dependent on the public-key algorithm used.",
      "ja": "- 暗号化されたセッションキーであるオクテットの文字列。この文字列はパケットの残りの部分を占め、その内容は使用される公開鍵アルゴリズムに依存します。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for RSA encryption",
      "ja": "RSA暗号化のアルゴリズム固有のフィールド"
    },
    {
      "indent": 5,
      "text": "- multiprecision integer (MPI) of RSA encrypted value m**e mod n.",
      "ja": "- RSA暗号化値m ** e mod nの多精度整数（MPI）。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for Elgamal encryption:",
      "ja": "Elgamal暗号化のアルゴリズム固有のフィールド："
    },
    {
      "indent": 5,
      "text": "- MPI of Elgamal (Diffie-Hellman) value g**k mod p.",
      "ja": "- Elgamal（Diffie-Hellman）値のMPI値g ** k mod p。"
    },
    {
      "indent": 5,
      "text": "- MPI of Elgamal (Diffie-Hellman) value m * y**k mod p.",
      "ja": "- Elgamal（Diffie-Hellman）値m * y ** k mod pのMPI。"
    },
    {
      "indent": 3,
      "text": "The value \"m\" in the above formulas is derived from the session key as follows. First, the session key is prefixed with a one-octet algorithm identifier that specifies the symmetric encryption algorithm used to encrypt the following Symmetrically Encrypted Data Packet. Then a two-octet checksum is appended, which is equal to the sum of the preceding session key octets, not including the algorithm identifier, modulo 65536. This value is then encoded as described in PKCS#1 block encoding EME-PKCS1-v1_5 in Section 7.2.1 of [RFC3447] to form the \"m\" value used in the formulas above. See Section 13.1 of this document for notes on OpenPGP's use of PKCS#1.",
      "ja": "上記の式の値「m」は、次のようにセッションキーから導出されます。最初に、セッションキーの前に1オクテットのアルゴリズム識別子が付加され、次の対称的に暗号化されたデータパケットの暗号化に使用される対称暗号化アルゴリズムを指定します。次に、2オクテットのチェックサムが追加されます。これは、前のセッションキーオクテットの合計に等しく、アルゴリズム識別子は65536を含みません。次に、この値は、 [RFC3447]のセクション7.2.1は、上記の式で使用される「m」値を形成します。 OpenPGPによるPKCS＃1の使用に関する注意事項については、このドキュメントのセクション13.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that when an implementation forms several PKESKs with one session key, forming a message that can be decrypted by several keys, the implementation MUST make a new PKCS#1 encoding for each key.",
      "ja": "実装が1つのセッションキーで複数のPKESKを形成し、複数のキーで復号化できるメッセージを形成する場合、実装はキーごとに新しいPKCS＃1エンコーディングを作成する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY accept or use a Key ID of zero as a \"wild card\" or \"speculative\" Key ID. In this case, the receiving implementation would try all available private keys, checking for a valid decrypted session key. This format helps reduce traffic analysis of messages.",
      "ja": "実装は、ゼロのキーIDを「ワイルドカード」または「投機的」キーIDとして受け入れるか使用することができます。この場合、受信側の実装は、利用可能なすべての秘密鍵を試し、有効な復号化されたセッション鍵をチェックします。この形式は、メッセージのトラフィック分析を減らすのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2. Signature Packet (Tag 2)",
      "section_title": true,
      "ja": "5.2. 署名パケット（タグ2）"
    },
    {
      "indent": 3,
      "text": "A Signature packet describes a binding between some public key and some data. The most common signatures are a signature of a file or a block of text, and a signature that is a certification of a User ID.",
      "ja": "署名パケットは、いくつかの公開鍵といくつかのデータの間のバインディングを記述します。最も一般的な署名は、ファイルまたはテキストブロックの署名と、ユーザーIDの証明である署名です。"
    },
    {
      "indent": 3,
      "text": "Two versions of Signature packets are defined. Version 3 provides basic signature information, while version 4 provides an expandable format with subpackets that can specify more information about the signature. PGP 2.6.x only accepts version 3 signatures.",
      "ja": "2つのバージョンの署名パケットが定義されています。バージョン3は基本的な署名情報を提供し、バージョン4は署名に関する詳細情報を指定できるサブパケットを備えた拡張可能な形式を提供します。 PGP 2.6.xは、バージョン3の署名のみを受け入れます。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD accept V3 signatures. Implementations SHOULD generate V4 signatures.",
      "ja": "実装はV3署名を受け入れる必要があります。実装はV4署名を生成する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note that if an implementation is creating an encrypted and signed message that is encrypted to a V3 key, it is reasonable to create a V3 signature.",
      "ja": "実装が、V3キーに暗号化された暗号化および署名付きメッセージを作成している場合は、V3署名を作成するのが妥当です。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Signature Types",
      "section_title": true,
      "ja": "5.2.1. 署名タイプ"
    },
    {
      "indent": 3,
      "text": "There are a number of possible meanings for a signature, which are indicated in a signature type octet in any given signature. Please note that the vagueness of these meanings is not a flaw, but a feature of the system. Because OpenPGP places final authority for validity upon the receiver of a signature, it may be that one signer's casual act might be more rigorous than some other authority's positive act. See Section 5.2.4, \"Computing Signatures\", for detailed information on how to compute and verify signatures of each type.",
      "ja": "シグニチャにはいくつかの可能な意味があり、これらは特定のシグニチャのシグニチャタイプオクテットで示されます。これらの意味のあいまいさは欠陥ではなく、システムの機能であることに注意してください。 OpenPGPは、署名の受信者に有効性の最終的な権限を与えるため、ある署名者の偶発的な行為は、他の権限の積極的な行為よりも厳格である可能性があります。各タイプのシグネチャを計算および検証する方法の詳細については、セクション5.2.4「シグネチャの計算」を参照してください。"
    },
    {
      "indent": 3,
      "text": "These meanings are as follows:",
      "ja": "これらの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x00: Signature of a binary document. This means the signer owns it, created it, or certifies that it has not been modified.",
      "ja": "0x00：バイナリドキュメントの署名。これは、署名者がそれを所有、作成、または変更されていないことを証明することを意味します。"
    },
    {
      "indent": 3,
      "text": "0x01: Signature of a canonical text document. This means the signer owns it, created it, or certifies that it has not been modified. The signature is calculated over the text data with its line endings converted to <CR><LF>.",
      "ja": "0x01：正規のテキストドキュメントの署名。これは、署名者がそれを所有、作成、または変更されていないことを証明することを意味します。署名はテキストデータに対して計算され、その行末は<CR> <LF>に変換されます。"
    },
    {
      "indent": 3,
      "text": "0x02: Standalone signature. This signature is a signature of only its own subpacket contents. It is calculated identically to a signature over a zero-length binary document. Note that it doesn't make sense to have a V3 standalone signature.",
      "ja": "0x02：スタンドアロンシグネチャ。このシグニチャは、独自のサブパケットコンテンツのみのシグニチャです。長さゼロのバイナリドキュメントの署名と同じように計算されます。 V3スタンドアロンシグネチャを持つことは意味がないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "0x10: Generic certification of a User ID and Public-Key packet. The issuer of this certification does not make any particular assertion as to how well the certifier has checked that the owner of the key is in fact the person described by the User ID.",
      "ja": "0x10：ユーザーIDと公開鍵パケットの一般的な認証。この証明書の発行者は、キーの所有者が実際にユーザーIDによって記述された人物であることを認証者がどれだけ適切にチェックしたかについて、特定の主張をしません。"
    },
    {
      "indent": 3,
      "text": "0x11: Persona certification of a User ID and Public-Key packet. The issuer of this certification has not done any verification of the claim that the owner of this key is the User ID specified.",
      "ja": "0x11：ユーザーIDと公開鍵パケットのペルソナ認証。この証明書の発行者は、このキーの所有者が指定されたユーザーIDであるという主張の検証を行っていません。"
    },
    {
      "indent": 3,
      "text": "0x12: Casual certification of a User ID and Public-Key packet. The issuer of this certification has done some casual verification of the claim of identity.",
      "ja": "0x12：ユーザーIDと公開鍵パケットのカジュアルな認証。この認証の発行者は、身元の主張について何気なく検証を行っています。"
    },
    {
      "indent": 3,
      "text": "0x13: Positive certification of a User ID and Public-Key packet. The issuer of this certification has done substantial verification of the claim of identity.",
      "ja": "0x13：ユーザーIDと公開鍵パケットの肯定的な認証。この認証の発行者は、身元の主張の実質的な検証を行いました。"
    },
    {
      "indent": 7,
      "text": "Most OpenPGP implementations make their \"key signatures\" as 0x10 certifications. Some implementations can issue 0x11-0x13 certifications, but few differentiate between the types.",
      "ja": "ほとんどのOpenPGP実装は、「鍵署名」を0x10証明書として作成します。一部の実装は0x11-0x13証明書を発行できますが、タイプを区別するものはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "0x18: Subkey Binding Signature This signature is a statement by the top-level signing key that indicates that it owns the subkey. This signature is calculated directly on the primary key and subkey, and not on any User ID or other packets. A signature that binds a signing subkey MUST have an Embedded Signature subpacket in this binding signature that contains a 0x19 signature made by the signing subkey on the primary key and subkey.",
      "ja": "0x18：サブキーバインディング署名この署名は、サブキーを所有していることを示す最上位の署名キーによるステートメントです。この署名は、主キーとサブキーで直接計算され、ユーザーIDや他のパケットでは計算されません。署名サブキーをバインドする署名は、主キーとサブキーの署名サブキーによって作成された0x19署名を含むこの署名署名に埋め込み署名サブパケットを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "0x19: Primary Key Binding Signature This signature is a statement by a signing subkey, indicating that it is owned by the primary key and subkey. This signature is calculated the same way as a 0x18 signature: directly on the primary key and subkey, and not on any User ID or other packets.",
      "ja": "0x19：主キーバインディング署名この署名は、署名サブキーによるステートメントであり、主キーとサブキーによって所有されていることを示します。このシグネチャは、0x18シグネチャと同じ方法で計算されます。ユーザーIDやその他のパケットではなく、主キーとサブキーで直接計算されます。"
    },
    {
      "indent": 3,
      "text": "0x1F: Signature directly on a key This signature is calculated directly on a key. It binds the information in the Signature subpackets to the key, and is appropriate to be used for subpackets that provide information about the key, such as the Revocation Key subpacket. It is also appropriate for statements that non-self certifiers want to make about the key itself, rather than the binding between a key and a name.",
      "ja": "0x1F：鍵に直接署名この署名は、鍵に直接計算されます。これは、Signatureサブパケットの情報をキーにバインドし、Revocation Keyサブパケットなど、キーに関する情報を提供するサブパケットに使用するのに適しています。また、非自己認証者がキーと名前の間のバインディングではなく、キー自体について作成することを望むステートメントにも適しています。"
    },
    {
      "indent": 3,
      "text": "0x20: Key revocation signature The signature is calculated directly on the key being revoked. A revoked key is not to be used. Only revocation signatures by the key being revoked, or by an authorized revocation key, should be considered valid revocation signatures.",
      "ja": "0x20：鍵失効署名署名は、失効する鍵で直接計算されます。取り消された鍵は使用されません。取り消されるキーまたは承認された取り消しキーによる取り消し署名のみが、有効な取り消し署名と見なされます。"
    },
    {
      "indent": 3,
      "text": "0x28: Subkey revocation signature The signature is calculated directly on the subkey being revoked. A revoked subkey is not to be used. Only revocation signatures by the top-level signature key that is bound to this subkey, or by an authorized revocation key, should be considered valid revocation signatures.",
      "ja": "0x28：サブキー失効署名署名は失効するサブキーで直接計算されます。取り消されたサブキーは使用されません。このサブキーにバインドされている最上位の署名キーによる、または承認された失効キーによる失効署名のみが、有効な失効署名と見なされます。"
    },
    {
      "indent": 3,
      "text": "0x30: Certification revocation signature This signature revokes an earlier User ID certification signature (signature class 0x10 through 0x13) or direct-key signature (0x1F). It should be issued by the same key that issued the revoked signature or an authorized revocation key. The signature is computed over the same data as the certificate that it revokes, and should have a later creation date than that certificate.",
      "ja": "0x30：証明書失効署名この署名は、以前のユーザーID証明書署名（署名クラス0x10〜0x13）または直接キー署名（0x1F）を取り消します。それは、取り消された署名を発行したのと同じ鍵または許可された取り消し鍵によって発行されるべきです。署名は、それが取り消す証明書と同じデータに基づいて計算され、その証明書より後の作成日を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "0x40: Timestamp signature. This signature is only meaningful for the timestamp contained in it.",
      "ja": "0x40：タイムスタンプ署名。この署名は、それに含まれるタイムスタンプに対してのみ意味があります。"
    },
    {
      "indent": 3,
      "text": "0x50: Third-Party Confirmation signature. This signature is a signature over some other OpenPGP Signature packet(s). It is analogous to a notary seal on the signed data. A third-party signature SHOULD include Signature Target subpacket(s) to give easy identification. Note that we really do mean SHOULD. There are plausible uses for this (such as a blind party that only sees the signature, not the key or source document) that cannot include a target subpacket.",
      "ja": "0x50：サードパーティの確認署名。この署名は、他のいくつかのOpenPGP署名パケットに対する署名です。これは、署名されたデータの公証シールに似ています。サードパーティの署名には、簡単に識別できるように、Signature Targetサブパケットを含める必要があります（SHOULD）。本当に意味する必要があることに注意してください。これには、ターゲットのサブパケットを含めることができない、もっともらしい使い方があります（署名だけを見て、キーやソースドキュメントは見えないブラインドパーティーなど）。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Version 3 Signature Packet Format",
      "section_title": true,
      "ja": "5.2.2. バージョン3署名パケット形式"
    },
    {
      "indent": 3,
      "text": "The body of a version 3 Signature Packet contains:",
      "ja": "バージョン3の署名パケットの本文には、次のものが含まれます。"
    },
    {
      "indent": 5,
      "text": "- One-octet version number (3).",
      "ja": "- 1オクテットのバージョン番号（3）。"
    },
    {
      "indent": 5,
      "text": "- One-octet length of following hashed material. MUST be 5.",
      "ja": "- 次のハッシュされたマテリアルの1オクテット長。 5でなければなりません。"
    },
    {
      "indent": 9,
      "text": "- One-octet signature type.",
      "ja": "- 1オクテットの署名タイプ。"
    },
    {
      "indent": 9,
      "text": "- Four-octet creation time.",
      "ja": "- 4オクテットの作成時間。"
    },
    {
      "indent": 5,
      "text": "- Eight-octet Key ID of signer.",
      "ja": "- 署名者の8オクテットのキーID。"
    },
    {
      "indent": 5,
      "text": "- One-octet public-key algorithm.",
      "ja": "- 1オクテットの公開鍵アルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- One-octet hash algorithm.",
      "ja": "- 1オクテットハッシュアルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- Two-octet field holding left 16 bits of signed hash value.",
      "ja": "- 署名されたハッシュ値の左16ビットを保持する2オクテットのフィールド。"
    },
    {
      "indent": 5,
      "text": "- One or more multiprecision integers comprising the signature. This portion is algorithm specific, as described below.",
      "ja": "- 署名を構成する1つ以上の多精度整数。以下で説明するように、この部分はアルゴリズム固有です。"
    },
    {
      "indent": 3,
      "text": "The concatenation of the data to be signed, the signature type, and creation time from the Signature packet (5 additional octets) is hashed. The resulting hash value is used in the signature algorithm. The high 16 bits (first two octets) of the hash are included in the Signature packet to provide a quick test to reject some invalid signatures.",
      "ja": "署名されるデータ、署名タイプ、および署名パケットからの作成時間の連結（5つの追加オクテット）がハッシュされます。結果のハッシュ値は、署名アルゴリズムで使用されます。ハッシュの上位16ビット（最初の2オクテット）は署名パケットに含まれており、無効な署名を拒否する迅速なテストを提供します。"
    },
    {
      "indent": 3,
      "text": "Algorithm-Specific Fields for RSA signatures:",
      "ja": "RSA署名のアルゴリズム固有のフィールド："
    },
    {
      "indent": 5,
      "text": "- multiprecision integer (MPI) of RSA signature value m**d mod n.",
      "ja": "- RSA署名値m ** d mod nの多精度整数（MPI）。"
    },
    {
      "indent": 3,
      "text": "Algorithm-Specific Fields for DSA signatures:",
      "ja": "DSA署名のアルゴリズム固有のフィールド："
    },
    {
      "indent": 5,
      "text": "- MPI of DSA value r.",
      "ja": "- DSA値のMPI r。"
    },
    {
      "indent": 5,
      "text": "- MPI of DSA value s.",
      "ja": "- DSA値のMPI。"
    },
    {
      "indent": 3,
      "text": "The signature calculation is based on a hash of the signed data, as described above. The details of the calculation are different for DSA signatures than for RSA signatures.",
      "ja": "署名の計算は、上記のように、署名されたデータのハッシュに基づいています。計算の詳細は、DSA署名とRSA署名では異なります。"
    },
    {
      "indent": 3,
      "text": "With RSA signatures, the hash value is encoded using PKCS#1 encoding type EMSA-PKCS1-v1_5 as described in Section 9.2 of RFC 3447. This requires inserting the hash value as an octet string into an ASN.1 structure. The object identifier for the type of hash being used is included in the structure. The hexadecimal representations for the currently defined hash algorithms are as follows:",
      "ja": "RSA署名では、ハッシュ値はRFC 3447のセクション9.2で説明されているように、PKCS＃1エンコードタイプEMSA-PKCS1-v1_5を使用してエンコードされます。これには、ハッシュ値をオクテット文字列としてASN.1構造に挿入する必要があります。使用されているハッシュのタイプのオブジェクト識別子は、構造に含まれています。現在定義されているハッシュアルゴリズムの16進数表現は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- MD5: 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05",
      "ja": "- MD5：0x2A、0x86、0x48、0x86、0xF7、0x0D、0x02、0x05"
    },
    {
      "indent": 5,
      "text": "- RIPEMD-160: 0x2B, 0x24, 0x03, 0x02, 0x01",
      "ja": "- RIPEMD-160：0x2B、0x24、0x03、0x02、0x01"
    },
    {
      "indent": 5,
      "text": "- SHA-1: 0x2B, 0x0E, 0x03, 0x02, 0x1A",
      "ja": "- SHA-1：0x2B、0x0E、0x03、0x02、0x1A"
    },
    {
      "indent": 5,
      "text": "- SHA224: 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04",
      "ja": "- SHA224：0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x04"
    },
    {
      "indent": 5,
      "text": "- SHA256: 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01",
      "ja": "- SHA256：0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x01"
    },
    {
      "indent": 5,
      "text": "- SHA384: 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02",
      "ja": "- SHA3​​84：0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x02"
    },
    {
      "indent": 5,
      "text": "- SHA512: 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03",
      "ja": "- SHA512：0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x03"
    },
    {
      "indent": 3,
      "text": "The ASN.1 Object Identifiers (OIDs) are as follows:",
      "ja": "ASN.1オブジェクト識別子（OID）は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- MD5: 1.2.840.113549.2.5",
      "ja": "- 入り口：1,840.113549.A.K。"
    },
    {
      "indent": 5,
      "text": "- RIPEMD-160: 1.3.36.3.2.1",
      "ja": "- RIPEMD-160：1.3.36.3.2.1"
    },
    {
      "indent": 5,
      "text": "- SHA-1: 1.3.14.3.2.26",
      "ja": "- しゃー１： １。３。１４。３。２。２６"
    },
    {
      "indent": 5,
      "text": "- SHA224: 2.16.840.1.101.3.4.2.4",
      "ja": "- SHA224：2.16.840.1.101.3.4.2.4"
    },
    {
      "indent": 5,
      "text": "- SHA256: 2.16.840.1.101.3.4.2.1",
      "ja": "- SHA256：2.16.840.1.101.3.4.2.1"
    },
    {
      "indent": 5,
      "text": "- SHA384: 2.16.840.1.101.3.4.2.2",
      "ja": "- シャダ4：A.16.840.1.101.A.A.A. 4"
    },
    {
      "indent": 5,
      "text": "- SHA512: 2.16.840.1.101.3.4.2.3",
      "ja": "- シャク12：16,840.1,101.A.A.A.A。"
    },
    {
      "indent": 3,
      "text": "The full hash prefixes for these are as follows:",
      "ja": "これらの完全なハッシュプレフィックスは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "MD5: 0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10",
      "ja": "MD5：0x30、0x20、0x30、0x0C、0x06、0x08、0x2A、0x86、0x48、0x86、0xF7、0x0D、0x02、0x05、0x05、0x00、0x04、0x10"
    },
    {
      "indent": 7,
      "text": "RIPEMD-160: 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02, 0x01, 0x05, 0x00, 0x04, 0x14",
      "ja": "RIPEMD-160：0x30、0x21、0x30、0x09、0x06、0x05、0x2B、0x24、0x03、0x02、0x01、0x05、0x00、0x04、0x14"
    },
    {
      "indent": 7,
      "text": "SHA-1: 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14",
      "ja": "SHA-1：0x30、0x21、0x30、0x09、0x06、0x05、0x2b、0x0E、0x03、0x02、0x1A、0x05、0x00、0x04、0x14"
    },
    {
      "indent": 7,
      "text": "SHA224: 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C",
      "ja": "SHA224：0x30、0x31、0x30、0x0d、0x06、0x09、0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x04、0x05、0x00、0x04、0x1C"
    },
    {
      "indent": 7,
      "text": "SHA256: 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20",
      "ja": "SHA256：0x30、0x31、0x30、0x0d、0x06、0x09、0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x01、0x05、0x00、0x04、0x20"
    },
    {
      "indent": 7,
      "text": "SHA384: 0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30",
      "ja": "SHA3​​84：0x30、0x41、0x30、0x0d、0x06、0x09、0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x02、0x05、0x00、0x04、0x30"
    },
    {
      "indent": 7,
      "text": "SHA512: 0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40",
      "ja": "SHA512：0x30、0x51、0x30、0x0d、0x06、0x09、0x60、0x86、0x48、0x01、0x65、0x03、0x04、0x02、0x03、0x05、0x00、0x04、0x40"
    },
    {
      "indent": 3,
      "text": "DSA signatures MUST use hashes that are equal in size to the number of bits of q, the group generated by the DSA key's generator value.",
      "ja": "DSA署名は、サイズがDSAキーのジェネレータ値によって生成されるグループであるqのビット数と等しいハッシュを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the output size of the chosen hash is larger than the number of bits of q, the hash result is truncated to fit by taking the number of leftmost bits equal to the number of bits of q. This (possibly truncated) hash function result is treated as a number and used directly in the DSA signature algorithm.",
      "ja": "選択されたハッシュの出力サイズがqのビット数より大きい場合、左端のビット数をqのビット数と等しくすることにより、ハッシュ結果は切り捨てられます。この（切り捨てられた可能性がある）ハッシュ関数の結果は数値として扱われ、DSA署名アルゴリズムで直接使用されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Version 4 Signature Packet Format",
      "section_title": true,
      "ja": "5.2.3. バージョン4署名パケット形式"
    },
    {
      "indent": 3,
      "text": "The body of a version 4 Signature packet contains:",
      "ja": "バージョン4の署名パケットの本文には以下が含まれます。"
    },
    {
      "indent": 5,
      "text": "- One-octet version number (4).",
      "ja": "- 1オクテットのバージョン番号（4）。"
    },
    {
      "indent": 5,
      "text": "- One-octet signature type.",
      "ja": "- 1オクテットの署名タイプ。"
    },
    {
      "indent": 5,
      "text": "- One-octet public-key algorithm.",
      "ja": "- 1オクテットの公開鍵アルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- One-octet hash algorithm.",
      "ja": "- 1オクテットハッシュアルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- Two-octet scalar octet count for following hashed subpacket data. Note that this is the length in octets of all of the hashed subpackets; a pointer incremented by this number will skip over the hashed subpackets.",
      "ja": "- 次のハッシュサブパケットデータの2オクテットスカラーオクテットカウント。これは、ハッシュされたすべてのサブパケットの長さ（オクテット単位）であることに注意してください。この数だけインクリメントされたポインタは、ハッシュされたサブパケットをスキップします。"
    },
    {
      "indent": 5,
      "text": "- Hashed subpacket data set (zero or more subpackets).",
      "ja": "- ハッシュされたサブパケットデータセット（ゼロ以上のサブパケット）。"
    },
    {
      "indent": 5,
      "text": "- Two-octet scalar octet count for the following unhashed subpacket data. Note that this is the length in octets of all of the unhashed subpackets; a pointer incremented by this number will skip over the unhashed subpackets.",
      "ja": "- 次のハッシュされていないサブパケットデータの2オクテットスカラーオクテットカウント。これは、ハッシュされていないすべてのサブパケットの長さ（オクテット単位）であることに注意してください。この数だけインクリメントされたポインターは、ハッシュされていないサブパケットをスキップします。"
    },
    {
      "indent": 5,
      "text": "- Unhashed subpacket data set (zero or more subpackets).",
      "ja": "- ハッシュ化されていないサブパケットデータセット（ゼロ以上のサブパケット）。"
    },
    {
      "indent": 5,
      "text": "- Two-octet field holding the left 16 bits of the signed hash value.",
      "ja": "- 署名付きハッシュ値の左16ビットを保持する2オクテットのフィールド。"
    },
    {
      "indent": 5,
      "text": "- One or more multiprecision integers comprising the signature. This portion is algorithm specific, as described above.",
      "ja": "- 署名を構成する1つ以上の多精度整数。この部分は、上記のようにアルゴリズム固有です。"
    },
    {
      "indent": 3,
      "text": "The concatenation of the data being signed and the signature data from the version number through the hashed subpacket data (inclusive) is hashed. The resulting hash value is what is signed. The left 16 bits of the hash are included in the Signature packet to provide a quick test to reject some invalid signatures.",
      "ja": "署名されるデータと、バージョン番号からハッシュされたサブパケットデータ（両端を含む）までの署名データの連結がハッシュされます。結果のハッシュ値は署名されたものです。ハッシュの左側の16ビットは署名パケットに含まれており、いくつかの無効な署名を拒否する簡単なテストを提供します。"
    },
    {
      "indent": 0,
      "text": " There are two fields consisting of Signature subpackets. The first field is hashed with the rest of the signature data, while the second is unhashed. The second set of subpackets is not cryptographically protected by the signature and should include only advisory information.",
      "ja": "Signatureサブパケットで構成される2つのフィールドがあります。最初のフィールドは残りの署名データでハッシュされ、2番目のフィールドはハッシュされません。サブパケットの2番目のセットは、署名によって暗号で保護されておらず、助言情報のみを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The algorithms for converting the hash function result to a signature are described in a section below.",
      "ja": "ハッシュ関数の結果を署名に変換するアルゴリズムについては、以下のセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1. Signature Subpacket Specification",
      "section_title": true,
      "ja": "5.2.3.1. 署名サブパケット仕様"
    },
    {
      "indent": 3,
      "text": "A subpacket data set consists of zero or more Signature subpackets. In Signature packets, the subpacket data set is preceded by a two-octet scalar count of the length in octets of all the subpackets. A pointer incremented by this number will skip over the subpacket data set.",
      "ja": "サブパケットデータセットは、0個以上のSignatureサブパケットで構成されます。シグニチャパケットでは、サブパケットデータセットの前に、すべてのサブパケットのオクテット単位の長さの2オクテットスカラーカウントが続きます。この数だけインクリメントされたポインターは、サブパケットデータセットをスキップします。"
    },
    {
      "indent": 3,
      "text": "Each subpacket consists of a subpacket header and a body. The header consists of:",
      "ja": "各サブパケットは、サブパケットヘッダーと本文で構成されます。ヘッダーは次のもので構成されます。"
    },
    {
      "indent": 5,
      "text": "- the subpacket length (1, 2, or 5 octets),",
      "ja": "- サブパケット長（1、2、または5オクテット）、"
    },
    {
      "indent": 5,
      "text": "- the subpacket type (1 octet),",
      "ja": "- サブパケットタイプ（1オクテット）、"
    },
    {
      "indent": 3,
      "text": "and is followed by the subpacket-specific data.",
      "ja": "その後にサブパケット固有のデータが続きます。"
    },
    {
      "indent": 3,
      "text": "The length includes the type octet but not this length. Its format is similar to the \"new\" format packet header lengths, but cannot have Partial Body Lengths. That is:",
      "ja": "長さにはタイプオクテットが含まれますが、この長さは含まれません。その形式は「新しい」形式のパケットヘッダー長に似ていますが、部分的な本文の長さを持つことはできません。あれは："
    },
    {
      "indent": 7,
      "text": "if the 1st octet < 192, then lengthOfLength = 1 subpacketLen = 1st_octet",
      "ja": "1番目のオクテットが192未満の場合、lengthOfLength = 1 subpacketLen = 1st_octet"
    },
    {
      "indent": 7,
      "text": "if the 1st octet >= 192 and < 255, then\n    lengthOfLength = 2\n    subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if the 1st octet = 255, then\n    lengthOfLength = 5\n    subpacket length = [four-octet scalar starting at 2nd_octet]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value of the subpacket type octet may be:",
      "ja": "サブパケットタイプオクテットの値は次のとおりです。"
    },
    {
      "indent": 0,
      "text": " 0 = Reserved 1 = Reserved 2 = Signature Creation Time 3 = Signature Expiration Time 4 = Exportable Certification 5 = Trust Signature 6 = Regular Expression 7 = Revocable 8 = Reserved 9 = Key Expiration Time 10 = Placeholder for backward compatibility 11 = Preferred Symmetric Algorithms 12 = Revocation Key 13 = Reserved 14 = Reserved 15 = Reserved 16 = Issuer 17 = Reserved 18 = Reserved 19 = Reserved 20 = Notation Data 21 = Preferred Hash Algorithms 22 = Preferred Compression Algorithms 23 = Key Server Preferences 24 = Preferred Key Server 25 = Primary User ID 26 = Policy URI 27 = Key Flags 28 = Signer's User ID 29 = Reason for Revocation 30 = Features 31 = Signature Target 32 = Embedded Signature 100 To 110 = Private or experimental",
      "ja": "0 =予約済み1 =予約済み2 =署名の作成時間3 =署名の有効期限4 =エクスポート可能な証明書5 =信頼署名6 =正規表現7 =取り消し可能8 =予約済み9 =鍵の有効期限10 =下位互換性のためのプレースホルダー11 =優先対称アルゴリズム12 =取り消しキー13 =予約済み14 =予約済み15 =予約済み16 =発行者17 =予約済み19 =予約済み20 =予約済み20 =表記データ21 =優先ハッシュアルゴリズム22 =優先圧縮アルゴリズム23 =キーサーバー設定24 =優先キーサーバー25 =プライマリユーザーID 26 =ポリシーURI 27 =キーフラグ28 =署名者のユーザーID 29 =取り消しの理由30 =機能31 =署名ターゲット32 =埋め込み署名100から110 =プライベートまたは実験的"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD ignore any subpacket of a type that it does not recognize.",
      "ja": "実装は、認識しないタイプのサブパケットを無視する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Bit 7 of the subpacket type is the \"critical\" bit. If set, it denotes that the subpacket is one that is critical for the evaluator of the signature to recognize. If a subpacket is encountered that is marked critical but is unknown to the evaluating software, the evaluator SHOULD consider the signature to be in error.",
      "ja": "サブパケットタイプのビット7は「クリティカル」ビットです。設定されている場合、それはサブパケットが署名の評価者が認識するために重要なものであることを示します。クリティカルとしてマークされているが、評価ソフトウェアにとって未知のサブパケットが検出された場合、評価者は、署名にエラーがあると見なすべきである（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "An evaluator may \"recognize\" a subpacket, but not implement it. The purpose of the critical bit is to allow the signer to tell an evaluator that it would prefer a new, unknown feature to generate an error than be ignored.",
      "ja": "評価者はサブパケットを「認識」するかもしれないが、それを実装しないかもしれない。クリティカルビットの目的は、無視されるよりもエラーを生成するために新しい未知の機能を好むことを署名者が評価者に伝えることを可能にすることです。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD implement the three preferred algorithm subpackets (11, 21, and 22), as well as the \"Reason for Revocation\" subpacket. Note, however, that if an implementation chooses not to implement some of the preferences, it is required to behave in a polite manner to respect the wishes of those users who do implement these preferences.",
      "ja": "実装は、3つの推奨アルゴリズムサブパケット（11、21、および22）と、「Reason for Revocation」サブパケットを実装する必要があります（SHOULD）。ただし、実装が一部の設定を実装しないことを選択した場合は、これらの設定を実装するユーザーの希望を尊重するように礼儀正しく行動する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2. Signature Subpacket Types",
      "section_title": true,
      "ja": "5.2.3.2. シグニチャサブパケットタイプ"
    },
    {
      "indent": 3,
      "text": "A number of subpackets are currently defined. Some subpackets apply to the signature itself and some are attributes of the key. Subpackets that are found on a self-signature are placed on a certification made by the key itself. Note that a key may have more than one User ID, and thus may have more than one self-signature, and differing subpackets.",
      "ja": "現在、いくつかのサブパケットが定義されています。一部のサブパケットは署名自体に適用され、一部はキーの属性です。自己署名で見つかったサブパケットは、キー自体によって作成された証明書に配置されます。キーには複数のユーザーIDがあり、したがって複数の自己署名と異なるサブパケットを持つ場合があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A subpacket may be found either in the hashed or unhashed subpacket sections of a signature. If a subpacket is not hashed, then the information in it cannot be considered definitive because it is not part of the signature proper.",
      "ja": "サブパケットは、シグニチャのハッシュ化された、またはハッシュ化されていないサブパケットセクションのいずれかにあります。サブパケットがハッシュされていない場合、その中の情報は適切な署名の一部ではないため、決定的なものとは見なされません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.3. Notes on Self-Signatures",
      "section_title": true,
      "ja": "5.2.3.3. 自己署名に関する注意"
    },
    {
      "indent": 3,
      "text": "A self-signature is a binding signature made by the key to which the signature refers. There are three types of self-signatures, the certification signatures (types 0x10-0x13), the direct-key signature (type 0x1F), and the subkey binding signature (type 0x18). For certification self-signatures, each User ID may have a self-signature, and thus different subpackets in those self-signatures. For subkey binding signatures, each subkey in fact has a self-signature. Subpackets that appear in a certification self-signature apply to the user name, and subpackets that appear in the subkey self-signature apply to the subkey. Lastly, subpackets on the direct-key signature apply to the entire key.",
      "ja": "自己署名は、署名が参照する鍵によって作成されたバインディング署名です。自己署名には、証明書署名（タイプ0x10-0x13）、直接鍵署名（タイプ0x1F）、およびサブキーバインディング署名（タイプ0x18）の3つのタイプがあります。証明書の自己署名の場合、各ユーザーIDに自己署名があり、そのため、これらの自己署名のサブパケットが異なる場合があります。サブキーバインディング署名の場合、実際には各サブキーに自己署名があります。証明書の自己署名に表示されるサブパケットはユーザー名に適用され、サブキーの自己署名に表示されるサブパケットはサブキーに適用されます。最後に、直接キー署名のサブパケットは、キー全体に適用されます。"
    },
    {
      "indent": 3,
      "text": "Implementing software should interpret a self-signature's preference subpackets as narrowly as possible. For example, suppose a key has two user names, Alice and Bob. Suppose that Alice prefers the symmetric algorithm CAST5, and Bob prefers IDEA or TripleDES. If the software locates this key via Alice's name, then the preferred algorithm is CAST5; if software locates the key via Bob's name, then the preferred algorithm is IDEA. If the key is located by Key ID, the algorithm of the primary User ID of the key provides the preferred symmetric algorithm.",
      "ja": "ソフトウェアの実装では、自己署名の設定サブパケットを可能な限り狭く解釈する必要があります。たとえば、キーにAliceとBobの2つのユーザー名があるとします。 Aliceが対称アルゴリズムCAST5を優先し、BobがIDEAまたはTripleDESを優先するとします。ソフトウェアがこのキーをアリスの名前で見つけた場合、推奨されるアルゴリズムはCAST5です。ソフトウェアがボブの名前でキーを見つける場合、推奨されるアルゴリズムはIDEAです。キーがキーIDによって特定される場合、キーのプライマリユーザーIDのアルゴリズムが優先対称アルゴリズムを提供します。"
    },
    {
      "indent": 0,
      "text": " Revoking a self-signature or allowing it to expire has a semantic meaning that varies with the signature type. Revoking the self-signature on a User ID effectively retires that user name. The self-signature is a statement, \"My name X is tied to my signing key K\" and is corroborated by other users' certifications. If another user revokes their certification, they are effectively saying that they no longer believe that name and that key are tied together. Similarly, if the users themselves revoke their self-signature, then the users no longer go by that name, no longer have that email address, etc. Revoking a binding signature effectively retires that subkey. Revoking a direct-key signature cancels that signature. Please see the \"Reason for Revocation\" subpacket (Section 5.2.3.23) for more relevant detail.",
      "ja": "自己署名を取り消したり、有効期限を切れたりさせることには、署名の種類によって異なる意味があります。ユーザーIDの自己署名を取り消すと、そのユーザー名は事実上廃止されます。自己署名は「私の名前Xは私の署名鍵Kに関連付けられている」というステートメントであり、他のユーザーの証明書によって裏付けられています。別のユーザーが証明書を取り消す場合、その名前とそのキーが関連付けられているとはもはや信じていないことを効果的に述べています。同様に、ユーザー自身が自己署名を取り消すと、ユーザーはその名前で移動したり、その電子メールアドレスを失ったりするなどしなくなります。バインディング署名を取り消すと、そのサブキーは実質的に廃止されます。ダイレクトキー署名を取り消すと、その署名がキャンセルされます。詳細については、「Reason for Revocation」サブパケット（セクション5.2.3.23）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Since a self-signature contains important information about the key's use, an implementation SHOULD allow the user to rewrite the self-signature, and important information in it, such as preferences and key expiration.",
      "ja": "自己署名には鍵の使用に関する重要な情報が含まれているため、実装では、ユーザーは自己署名と、設定や鍵の有効期限などの重要な情報を書き換えることができます（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "It is good practice to verify that a self-signature imported into an implementation doesn't advertise features that the implementation doesn't support, rewriting the signature as appropriate.",
      "ja": "実装にインポートされた自己署名が、実装がサポートしていない機能を宣伝していないことを確認し、必要に応じて署名を書き換えることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "An implementation that encounters multiple self-signatures on the same object may resolve the ambiguity in any way it sees fit, but it is RECOMMENDED that priority be given to the most recent self-signature.",
      "ja": "同じオブジェクトで複数の自己署名に遭遇する実装は、あいまいさを解決する方法で解決する場合がありますが、最新の自己署名を優先することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.2.3.4. Signature Creation Time",
      "section_title": true,
      "ja": "5.2.3.4. 署名作成時間"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4オクテットの時間フィールド）"
    },
    {
      "indent": 3,
      "text": "The time the signature was made.",
      "ja": "署名が行われた時刻。"
    },
    {
      "indent": 3,
      "text": "MUST be present in the hashed area.",
      "ja": "ハッシュされた領域に存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.5. Issuer",
      "section_title": true,
      "ja": "5.2.3.5. 発行者"
    },
    {
      "indent": 3,
      "text": "(8-octet Key ID)",
      "ja": "（8オクテットのキーID）"
    },
    {
      "indent": 3,
      "text": "The OpenPGP Key ID of the key issuing the signature.",
      "ja": "署名を発行する鍵のOpenPGP鍵ID。"
    },
    {
      "indent": 0,
      "text": "5.2.3.6. Key Expiration Time",
      "section_title": true,
      "ja": "5.2.3.6. キーの有効期限"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4オクテットの時間フィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the key. This is the number of seconds after the key creation time that the key expires. If this is not present or has a value of zero, the key never expires. This is found only on a self-signature.",
      "ja": "鍵の有効期間。これは、キーの有効期限が切れる、キー作成時間後の秒数です。これが存在しないか、値がゼロの場合、キーは期限切れになりません。これは自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.7. Preferred Symmetric Algorithms",
      "section_title": true,
      "ja": "5.2.3.7. 推奨される対称アルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 0,
      "text": " Symmetric algorithm numbers that indicate which algorithms the key holder prefers to use. The subpacket body is an ordered list of octets with the most preferred listed first. It is assumed that only algorithms listed are supported by the recipient's software. Algorithm numbers are in Section 9. This is only found on a self-signature.",
      "ja": "鍵保有者が使用することを好むアルゴリズムを示す対称アルゴリズム番号。サブパケットの本体は、最も優先されるものが最初にリストされているオクテットの順序付きリストです。リストされているアルゴリズムのみが受信者のソフトウェアでサポートされていると想定されています。アルゴリズム番号はセクション9にあります。これは自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.8. Preferred Hash Algorithms",
      "section_title": true,
      "ja": "5.2.3.8. 優先ハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 3,
      "text": "Message digest algorithm numbers that indicate which algorithms the key holder prefers to receive. Like the preferred symmetric algorithms, the list is ordered. Algorithm numbers are in Section 9. This is only found on a self-signature.",
      "ja": "キーホルダーが受信することを好むアルゴリズムを示すメッセージダイジェストアルゴリズム番号。優先対称アルゴリズムと同様に、リストは順序付けられています。アルゴリズム番号はセクション9にあります。これは自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.9. Preferred Compression Algorithms",
      "section_title": true,
      "ja": "5.2.3.9. 推奨される圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 3,
      "text": "Compression algorithm numbers that indicate which algorithms the key holder prefers to use. Like the preferred symmetric algorithms, the list is ordered. Algorithm numbers are in Section 9. If this subpacket is not included, ZIP is preferred. A zero denotes that uncompressed data is preferred; the key holder's software might have no compression software in that implementation. This is only found on a self-signature.",
      "ja": "キーホルダーが使用することを好むアルゴリズムを示す圧縮アルゴリズム番号。優先対称アルゴリズムと同様に、リストは順序付けられています。アルゴリズム番号はセクション9にあります。このサブパケットが含まれていない場合は、ZIPが推奨されます。ゼロは、非圧縮データが優先されることを示します。鍵の所有者のソフトウェアには、その実装に圧縮ソフトウェアがない場合があります。これは自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.10. Signature Expiration Time",
      "section_title": true,
      "ja": "5.2.3.10. 署名の有効期限"
    },
    {
      "indent": 3,
      "text": "(4-octet time field)",
      "ja": "（4オクテットの時間フィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the signature. This is the number of seconds after the signature creation time that the signature expires. If this is not present or has a value of zero, it never expires.",
      "ja": "署名の有効期間。これは、署名の有効期限が切れる署名作成時刻からの秒数です。これが存在しないか、値がゼロの場合、期限切れになることはありません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.11. Exportable Certification",
      "section_title": true,
      "ja": "5.2.3.11. 輸出可能な認証"
    },
    {
      "indent": 3,
      "text": "(1 octet of exportability, 0 for not, 1 for exportable)",
      "ja": "（1オクテットのエクスポート可能、0はエクスポート不可、1はエクスポート可能）"
    },
    {
      "indent": 3,
      "text": "This subpacket denotes whether a certification signature is \"exportable\", to be used by other users than the signature's issuer. The packet body contains a Boolean flag indicating whether the signature is exportable. If this packet is not present, the certification is exportable; it is equivalent to a flag containing a 1.",
      "ja": "このサブパケットは、証明書の署名が「エクスポート可能」であるかどうかを示し、署名の発行者以外のユーザーが使用します。パケット本体には、署名がエクスポート可能かどうかを示すブールフラグが含まれています。このパケットが存在しない場合、証明書はエクスポート可能です。これは、1を含むフラグと同等です。"
    },
    {
      "indent": 3,
      "text": "Non-exportable, or \"local\", certifications are signatures made by a user to mark a key as valid within that user's implementation only.",
      "ja": "エクスポートできない、つまり「ローカル」証明書は、ユーザーがそのユーザーの実装内でのみキーを有効としてマークするために作成した署名です。"
    },
    {
      "indent": 3,
      "text": "Thus, when an implementation prepares a user's copy of a key for transport to another user (this is the process of \"exporting\" the key), any local certification signatures are deleted from the key.",
      "ja": "したがって、実装が別のユーザーに転送するためにユーザーのキーのコピーを準備するとき（これはキーを「エクスポートする」プロセスです）、ローカル証明書の署名はキーから削除されます。"
    },
    {
      "indent": 3,
      "text": "The receiver of a transported key \"imports\" it, and likewise trims any local certifications. In normal operation, there won't be any, assuming the import is performed on an exported key. However, there are instances where this can reasonably happen. For example, if an implementation allows keys to be imported from a key database in addition to an exported key, then this situation can arise.",
      "ja": "トランスポートされたキーの受信者はそれを「インポート」し、同様にすべてのローカル認証をトリミングします。通常の操作では、エクスポートされたキーでインポートが実行されると仮定して、何もありません。ただし、これが合理的に発生する場合があります。たとえば、実装で、エクスポートされたキーに加えてキーデータベースからキーをインポートできる場合、この状況が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some implementations do not represent the interest of a single user (for example, a key server). Such implementations always trim local certifications from any key they handle.",
      "ja": "一部の実装は、単一のユーザー（たとえば、鍵サーバー）の関心を表していない。このような実装では、ローカル証明書を、処理するすべてのキーから常にトリミングします。"
    },
    {
      "indent": 0,
      "text": "5.2.3.12. Revocable",
      "section_title": true,
      "ja": "5.2.3.12. 取消可能"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocability, 0 for not, 1 for revocable)",
      "ja": "（1オクテットの取り消し可能、0は取り消し不可、1は取り消し可能）"
    },
    {
      "indent": 3,
      "text": "Signature's revocability status. The packet body contains a Boolean flag indicating whether the signature is revocable. Signatures that are not revocable have any later revocation signatures ignored. They represent a commitment by the signer that he cannot revoke his signature for the life of his key. If this packet is not present, the signature is revocable.",
      "ja": "署名の取り消しステータス。パケット本体には、署名が取り消し可能かどうかを示すブールフラグが含まれています。取り消しできない署名は、それ以降の失効署名は無視されます。それらは、彼が自分の鍵の寿命のために自分の署名を取り消すことができないという署名者によるコミットメントを表しています。このパケットが存在しない場合、署名は取り消し可能です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.13. Trust Signature",
      "section_title": true,
      "ja": "5.2.3.13. 信頼署名"
    },
    {
      "indent": 3,
      "text": "(1 octet \"level\" (depth), 1 octet of trust amount)",
      "ja": "（1オクテットの「レベル」（深さ）、1オクテットの信頼量）"
    },
    {
      "indent": 3,
      "text": "Signer asserts that the key is not only valid but also trustworthy at the specified level. Level 0 has the same meaning as an ordinary validity signature. Level 1 means that the signed key is asserted to be a valid trusted introducer, with the 2nd octet of the body specifying the degree of trust. Level 2 means that the signed key is asserted to be trusted to issue level 1 trust signatures, i.e., that it is a \"meta introducer\". Generally, a level n trust signature asserts that a key is trusted to issue level n-1 trust signatures. The trust amount is in a range from 0-255, interpreted such that values less than 120 indicate partial trust and values of 120 or greater indicate complete trust. Implementations SHOULD emit values of 60 for partial trust and 120 for complete trust.",
      "ja": "署名者は、キーが有効であるだけでなく、指定されたレベルで信頼できると主張します。レベル0は、通常の有効性署名と同じ意味です。レベル1は、本体の2番目のオクテットが信頼度を指定して、署名された鍵が有効な信頼できる紹介者であると断言されることを意味します。レベル2は、署名された鍵がレベル1の信頼署名を発行するために信頼されていることをアサートすること、つまり、「メタイントロデューサー」であることを意味します。一般に、レベルnの信頼署名は、鍵がレベルn-1の信頼署名を発行するために信頼されていることを表明します。信頼量は0〜255の範囲で、120未満の値は部分的な信頼を示し、120以上の値は完全な信頼を示すと解釈されます。実装は、部分信頼の場合は60、完全信頼の場合は120の値を発行する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.2.3.14. Regular Expression",
      "section_title": true,
      "ja": "5.2.3.14. 正規表現"
    },
    {
      "indent": 3,
      "text": "(null-terminated regular expression)",
      "ja": "（ヌルで終了する正規表現）"
    },
    {
      "indent": 3,
      "text": "Used in conjunction with trust Signature packets (of level > 0) to limit the scope of trust that is extended. Only signatures by the target key on User IDs that match the regular expression in the body of this packet have trust extended by the trust Signature subpacket. The regular expression uses the same syntax as the Henry Spencer's \"almost public domain\" regular expression [REGEX] package. A description of the syntax is found in Section 8 below.",
      "ja": "拡張される信頼の範囲を制限するために、信頼レベル0以上の署名パケットと一緒に使用されます。このパケットの本文の正規表現に一致するユーザーIDのターゲットキーによる署名のみが、信頼署名サブパケットによって信頼が拡張されます。正規表現は、ヘンリースペンサーの「ほぼパブリックドメイン」の正規表現[REGEX]パッケージと同じ構文を使用します。構文の説明は、以下のセクション8にあります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.15. Revocation Key",
      "section_title": true,
      "ja": "5.2.3.15. 失効キー"
    },
    {
      "indent": 3,
      "text": "(1 octet of class, 1 octet of public-key algorithm ID, 20 octets of fingerprint)",
      "ja": "（1オクテットのクラス、1オクテットの公開鍵アルゴリズムID、20オクテットのフィンガープリント）"
    },
    {
      "indent": 3,
      "text": "Authorizes the specified key to issue revocation signatures for this key. Class octet must have bit 0x80 set. If the bit 0x40 is set, then this means that the revocation information is sensitive. Other bits are for future expansion to other kinds of authorizations. This is found on a self-signature.",
      "ja": "指定されたキーに対して、このキーの失効署名を発行することを承認します。クラスオクテットにはビット0x80が設定されている必要があります。ビット0x40が設定されている場合、これは失効情報が機密であることを意味します。他のビットは、他の種類の承認への将来の拡張用です。これは自己署名に記載されています。"
    },
    {
      "indent": 3,
      "text": "If the \"sensitive\" flag is set, the keyholder feels this subpacket contains private trust information that describes a real-world sensitive relationship. If this flag is set, implementations SHOULD NOT export this signature to other users except in cases where the data needs to be available: when the signature is being sent to the designated revoker, or when it is accompanied by a revocation signature from that revoker. Note that it may be appropriate to isolate this subpacket within a separate signature so that it is not combined with other subpackets that need to be exported.",
      "ja": "「sensitive」フラグが設定されている場合、キーホルダーは、このサブパケットに実世界の機密関係を説明するプライベート信頼情報が含まれていると感じます。このフラグが設定されている場合、実装は、データを使用可能にする必要がある場合を除いて、この署名を他のユーザーにエクスポートしないでください。署名が指定された取り消し者に送信されるとき、またはその取り消し者からの取り消し署名が伴う場合。エクスポートする必要がある他のサブパケットと組み合わされないように、このサブパケットを別のシグネチャ内に分離することが適切な場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3.16. Notation Data",
      "section_title": true,
      "ja": "5.2.3.16. 表記データ"
    },
    {
      "indent": 7,
      "text": "(4 octets of flags, 2 octets of name length (M), 2 octets of value length (N), M octets of name data, N octets of value data)",
      "ja": "（4オクテットのフラグ、2オクテットの名前の長さ（M）、2オクテットの値の長さ（N）、Mオクテットの名前データ、Nオクテットの値データ）"
    },
    {
      "indent": 3,
      "text": "This subpacket describes a \"notation\" on the signature that the issuer wishes to make. The notation has a name and a value, each of which are strings of octets. There may be more than one notation in a signature. Notations can be used for any extension the issuer of the signature cares to make. The \"flags\" field holds four octets of flags.",
      "ja": "このサブパケットは、発行者が作成したい署名の「表記」を記述します。表記には名前と値があり、それぞれオクテットの文字列です。署名には複数の表記がある場合があります。表記は、署名の発行者が作成する必要のある任意の拡張子に使用できます。 「フラグ」フィールドは、フラグの4オクテットを保持します。"
    },
    {
      "indent": 3,
      "text": "All undefined flags MUST be zero. Defined flags are as follows:",
      "ja": "未定義のフラグはすべてゼロでなければなりません。定義されているフラグは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "First octet: 0x80 = human-readable. This note value is text. Other octets: none.",
      "ja": "最初のオクテット：0x80 =人間が読める形式。この音価はテキストです。その他のオクテット：なし。"
    },
    {
      "indent": 3,
      "text": "Notation names are arbitrary strings encoded in UTF-8. They reside in two namespaces: The IETF namespace and the user namespace.",
      "ja": "表記名は、UTF-8でエンコードされた任意の文字列です。これらは、IETF名前空間とユーザー名前空間の2つの名前空間に存在します。"
    },
    {
      "indent": 3,
      "text": "The IETF namespace is registered with IANA. These names MUST NOT contain the \"@\" character (0x40). This is a tag for the user namespace.",
      "ja": "IETF名前空間はIANAに登録されています。これらの名前には「@」文字（0x40）を含めてはなりません。これは、ユーザー名前空間のタグです。"
    },
    {
      "indent": 3,
      "text": "Names in the user namespace consist of a UTF-8 string tag followed by \"@\" followed by a DNS domain name. Note that the tag MUST NOT contain an \"@\" character. For example, the \"sample\" tag used by Example Corporation could be \"sample@example.com\".",
      "ja": "ユーザー名前空間の名前は、UTF-8文字列タグ、 \"@\"、それに続くDNSドメイン名で構成されます。タグに「@」文字を含めることはできません。たとえば、Example Corporationが使用する「sample」タグは「sample@example.com」のようになります。"
    },
    {
      "indent": 3,
      "text": "Names in a user space are owned and controlled by the owners of that domain. Obviously, it's bad form to create a new name in a DNS space that you don't own.",
      "ja": "ユーザー空間の名前は、そのドメインの所有者によって所有および制御されます。明らかに、あなたが所有していないDNSスペースに新しい名前を作成することは悪い形です。"
    },
    {
      "indent": 3,
      "text": "Since the user namespace is in the form of an email address, implementers MAY wish to arrange for that address to reach a person who can be consulted about the use of the named tag. Note that due to UTF-8 encoding, not all valid user space name tags are valid email addresses.",
      "ja": "ユーザーの名前空間は電子メールアドレスの形式であるため、実装者は、名前付きタグの使用について相談できる担当者にそのアドレスが届くように手配する必要があります。 UTF-8エンコードのため、有効なユーザースペース名タグのすべてが有効なメールアドレスであるとは限りません。"
    },
    {
      "indent": 3,
      "text": "If there is a critical notation, the criticality applies to that specific notation and not to notations in general.",
      "ja": "クリティカル表記がある場合、クリティカル度はその特定の表記に適用され、一般的な表記には適用されません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.17. Key Server Preferences",
      "section_title": true,
      "ja": "5.2.3.17. 主要なサーバー設定"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（フラグのNオクテット）"
    },
    {
      "indent": 3,
      "text": "This is a list of one-bit flags that indicate preferences that the key holder has about how the key is handled on a key server. All undefined flags MUST be zero.",
      "ja": "これは、キーサーバーでのキーの処理方法についてキーホルダーが持っている設定を示す1ビットフラグのリストです。未定義のフラグはすべてゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "First octet: 0x80 = No-modify the key holder requests that this key only be modified or updated by the key holder or an administrator of the key server.",
      "ja": "最初のオクテット：0x80 = No-modifyキーホルダーは、このキーをキーホルダーまたはキーサーバーの管理者のみが変更または更新することを要求します。"
    },
    {
      "indent": 3,
      "text": "This is found only on a self-signature.",
      "ja": "これは自己署名でのみ見つかります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.18. Preferred Key Server",
      "section_title": true,
      "ja": "5.2.3.18. 優先キーサーバー"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（ストリング）"
    },
    {
      "indent": 3,
      "text": "This is a URI of a key server that the key holder prefers be used for updates. Note that keys with multiple User IDs can have a preferred key server for each User ID. Note also that since this is a URI, the key server can actually be a copy of the key retrieved by ftp, http, finger, etc.",
      "ja": "これは、キーホルダーが更新に使用することを好むキーサーバーのURIです。複数のユーザーIDを持つキーは、ユーザーIDごとに優先キーサーバーを持つことができます。これはURIであるため、キーサーバーは実際にはftp、http、fingerなどによって取得されたキーのコピーである可能性もあります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.19. Primary User ID",
      "section_title": true,
      "ja": "5.2.3.19. プライマリユーザーID"
    },
    {
      "indent": 3,
      "text": "(1 octet, Boolean)",
      "ja": "（1オクテット、ブール）"
    },
    {
      "indent": 3,
      "text": "This is a flag in a User ID's self-signature that states whether this User ID is the main User ID for this key. It is reasonable for an implementation to resolve ambiguities in preferences, etc. by referring to the primary User ID. If this flag is absent, its value is zero. If more than one User ID in a key is marked as primary, the implementation may resolve the ambiguity in any way it sees fit, but it is RECOMMENDED that priority be given to the User ID with the most recent self-signature.",
      "ja": "これは、このユーザーIDがこのキーのメインユーザーIDであるかどうかを示すユーザーIDの自己署名のフラグです。実装は、基本ユーザーIDを参照して、設定などのあいまいさを解決するのが妥当です。このフラグが存在しない場合、その値はゼロです。キー内の複数のユーザーIDがプライマリとしてマークされている場合、実装はあいまいさを適切と思われる方法で解決しますが、最新の自己署名を持つユーザーIDを優先することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When appearing on a self-signature on a User ID packet, this subpacket applies only to User ID packets. When appearing on a self-signature on a User Attribute packet, this subpacket applies only to User Attribute packets. That is to say, there are two different and independent \"primaries\" -- one for User IDs, and one for User Attributes.",
      "ja": "ユーザーIDパケットの自己署名に表示される場合、このサブパケットはユーザーIDパケットにのみ適用されます。ユーザー属性パケットの自己署名に表示される場合、このサブパケットはユーザー属性パケットにのみ適用されます。つまり、2つの異なる独立した「プライマリ」があります。1つはユーザーID用で、もう1つはユーザー属性用です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.20. Policy URI",
      "section_title": true,
      "ja": "5.2.3.20. ポリシーURI"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（ストリング）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a URI of a document that describes the policy under which the signature was issued.",
      "ja": "このサブパケットには、署名が発行されたポリシーを説明するドキュメントのURIが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.21. Key Flags",
      "section_title": true,
      "ja": "5.2.3.21. 主なフラグ"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（フラグのNオクテット）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a list of binary flags that hold information about a key. It is a string of octets, and an implementation MUST NOT assume a fixed size. This is so it can grow over time. If a list is shorter than an implementation expects, the unstated flags are considered to be zero. The defined flags are as follows:",
      "ja": "このサブパケットには、キーに関する情報を保持するバイナリフラグのリストが含まれています。これはオクテットの文字列であり、実装は固定サイズを想定してはなりません。これは、時間とともに成長できるようにするためです。リストが実装で期待されているよりも短い場合、明記されていないフラグはゼロと見なされます。定義されているフラグは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "First octet:",
      "ja": "最初のオクテット："
    },
    {
      "indent": 7,
      "text": "0x01 - This key may be used to certify other keys.",
      "ja": "0x01-このキーは、他のキーを認証するために使用できます。"
    },
    {
      "indent": 7,
      "text": "0x02 - This key may be used to sign data.",
      "ja": "0x02-このキーはデータの署名に使用できます。"
    },
    {
      "indent": 7,
      "text": "0x04 - This key may be used to encrypt communications.",
      "ja": "0x04-このキーは通信の暗号化に使用できます。"
    },
    {
      "indent": 7,
      "text": "0x08 - This key may be used to encrypt storage.",
      "ja": "0x08-このキーはストレージの暗号化に使用できます。"
    },
    {
      "indent": 7,
      "text": "0x10 - The private component of this key may have been split by a secret-sharing mechanism.",
      "ja": "0x10-この鍵の秘密コンポーネントは、秘密共有メカニズムによって分割された可能性があります。"
    },
    {
      "indent": 7,
      "text": "0x20 - This key may be used for authentication.",
      "ja": "0x20-このキーは認証に使用できます。"
    },
    {
      "indent": 7,
      "text": "0x80 - The private component of this key may be in the possession of more than one person.",
      "ja": "0x80-この鍵の秘密コンポーネントは複数の人が所有している可能性があります。"
    },
    {
      "indent": 3,
      "text": "Usage notes:",
      "ja": "使用上の注意："
    },
    {
      "indent": 3,
      "text": "The flags in this packet may appear in self-signatures or in certification signatures. They mean different things depending on who is making the statement -- for example, a certification signature that has the \"sign data\" flag is stating that the certification is for that use. On the other hand, the \"communications encryption\" flag in a self-signature is stating a preference that a given key be used for communications. Note however, that it is a thorny issue to determine what is \"communications\" and what is \"storage\". This decision is left wholly up to the implementation; the authors of this document do not claim any special wisdom on the issue and realize that accepted opinion may change.",
      "ja": "このパケットのフラグは、自己署名または認証署名に表示される場合があります。これらは、声明を出した人によって異なる意味を持ちます。たとえば、「署名データ」フラグが付いた証明書署名は、その証明書がその用途のためのものであることを示しています。一方、自己署名の「通信暗号化」フラグは、所定の鍵を通信に使用することを優先することを示しています。ただし、「通信」と「ストレージ」を判別するのは難しい問題です。この決定は完全に実装次第です。このドキュメントの作成者は、この問題について特別な知識を主張せず、受け入れられた意見が変わる可能性があることを認識しています。"
    },
    {
      "indent": 3,
      "text": "The \"split key\" (0x10) and \"group key\" (0x80) flags are placed on a self-signature only; they are meaningless on a certification signature. They SHOULD be placed only on a direct-key signature (type 0x1F) or a subkey signature (type 0x18), one that refers to the key the flag applies to.",
      "ja": "「分割キー」（0x10）および「グループキー」（0x80）フラグは、自己署名にのみ配置されます。証明書の署名では意味がありません。それらは、フラグが適用されるキーを参照するダイレクトキーシグネチャ（タイプ0x1F）またはサブキーシグネチャ（タイプ0x18）にのみ配置する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.2.3.22. Signer's User ID",
      "section_title": true,
      "ja": "5.2.3.22. 署名者のユーザーID"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（ストリング）"
    },
    {
      "indent": 3,
      "text": "This subpacket allows a keyholder to state which User ID is responsible for the signing. Many keyholders use a single key for different purposes, such as business communications as well as personal communications. This subpacket allows such a keyholder to state which of their roles is making a signature.",
      "ja": "このサブパケットにより、キーホルダーは署名を担当するユーザーIDを指定できます。多くのキーホルダーは、ビジネスコミュニケーションやパーソナルコミュニケーションなど、さまざまな目的で単一のキーを使用します。このサブパケットにより、そのようなキーホルダーは、どの役割が署名を行っているかを示すことができます。"
    },
    {
      "indent": 3,
      "text": "This subpacket is not appropriate to use to refer to a User Attribute packet.",
      "ja": "このサブパケットは、ユーザー属性パケットの参照に使用するのには適していません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.23. Reason for Revocation",
      "section_title": true,
      "ja": "5.2.3.23. 取消の理由"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocation code, N octets of reason string)",
      "ja": "（1オクテットの失効コード、Nオクテットの理由文字列）"
    },
    {
      "indent": 3,
      "text": "This subpacket is used only in key revocation and certification revocation signatures. It describes the reason why the key or certificate was revoked.",
      "ja": "このサブパケットは、鍵失効および証明書失効署名でのみ使用されます。鍵または証明書が取り消された理由を説明します。"
    },
    {
      "indent": 3,
      "text": "The first octet contains a machine-readable code that denotes the reason for the revocation:",
      "ja": "最初のオクテットには、取り消しの理由を示す機械可読コードが含まれています。"
    },
    {
      "indent": 3,
      "text": " 0 - No reason specified (key revocations or cert revocations) 1 - Key is superseded (key revocations) 2 - Key material has been compromised (key revocations) 3 - Key is retired and no longer used (key revocations) 32 - User ID information is no longer valid (cert revocations) 100-110 - Private Use",
      "ja": "0-理由が指定されていない（鍵の失効または証明書の失効）1-鍵が置き換えられている（鍵の失効）2-鍵の素材が危険にさらされている（鍵の失効）3-鍵が廃止されて使用されていない（鍵の失効）32-ユーザーID情報有効ではなくなりました（証明書の取り消し）100-110-私的使用"
    },
    {
      "indent": 3,
      "text": "Following the revocation code is a string of octets that gives information about the Reason for Revocation in human-readable form (UTF-8). The string may be null, that is, of zero length. The length of the subpacket is the length of the reason string plus one. An implementation SHOULD implement this subpacket, include it in all revocation signatures, and interpret revocations appropriately. There are important semantic differences between the reasons, and there are thus important reasons for revoking signatures.",
      "ja": "失効コードに続くのは、人間が読める形式（UTF-8）で失効理由に関する情報を提供するオクテットの文字列です。文字列はnull、つまり長さがゼロの場合があります。サブパケットの長さは、理由文字列の長さに1を加えたものです。実装は、このサブパケットを実装し、すべての失効署名に含め、失効を適切に解釈する必要があります（SHOULD）。これらの理由には意味上の重要な違いがあるため、署名を取り消すには重要な理由があります。"
    },
    {
      "indent": 3,
      "text": "If a key has been revoked because of a compromise, all signatures created by that key are suspect. However, if it was merely superseded or retired, old signatures are still valid. If the revoked signature is the self-signature for certifying a User ID, a revocation denotes that that user name is no longer in use. Such a revocation SHOULD include a 0x20 code.",
      "ja": "侵害のために鍵が取り消された場合、その鍵によって作成されたすべての署名が疑わしいものです。ただし、単に置き換えられるか廃止された場合でも、古い署名は引き続き有効です。取り消された署名がユーザーIDを認証するための自己署名である場合、取り消しはそのユーザー名が使用されなくなったことを示します。このような取り消しには、0x20コードを含める必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Note that any signature may be revoked, including a certification on some other person's key. There are many good reasons for revoking a certification signature, such as the case where the keyholder leaves the employ of a business with an email address. A revoked certification is no longer a part of validity calculations.",
      "ja": "他の人の鍵の証明書を含む署名は取り消される場合があることに注意してください。証明書の署名を取り消す理由はたくさんあります。たとえば、キーホルダーがメールアドレスを持っている会社の従業員を辞めた場合などです。失効した証明書は、有効性計算の一部ではなくなりました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.24. Features",
      "section_title": true,
      "ja": "5.2.3.24. 特徴"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（フラグのNオクテット）"
    },
    {
      "indent": 3,
      "text": "The Features subpacket denotes which advanced OpenPGP features a user's implementation supports. This is so that as features are added to OpenPGP that cannot be backwards-compatible, a user can state that they can use that feature. The flags are single bits that indicate that a given feature is supported.",
      "ja": "Featuresサブパケットは、ユーザーの実装がサポートする高度なOpenPGP機能を示します。これは、下位互換性のない機能がOpenPGPに追加されたときに、ユーザーがその機能を使用できることを示すことができるようにするためです。フラグは、特定の機能がサポートされていることを示す単一ビットです。"
    },
    {
      "indent": 3,
      "text": "This subpacket is similar to a preferences subpacket, and only appears in a self-signature.",
      "ja": "このサブパケットは設定サブパケットに似ており、自己署名でのみ表示されます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT use a feature listed when sending to a user who does not state that they can use it.",
      "ja": "実装は、それを使用できると述べていないユーザーに送信するときにリストされている機能を使用してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Defined features are as follows:",
      "ja": "定義されている機能は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "First octet:",
      "ja": "最初のオクテット："
    },
    {
      "indent": 7,
      "text": "0x01 - Modification Detection (packets 18 and 19)",
      "ja": "0x01-変更検出（パケット18および19）"
    },
    {
      "indent": 3,
      "text": "If an implementation implements any of the defined features, it SHOULD implement the Features subpacket, too.",
      "ja": "実装が定義された機能のいずれかを実装する場合は、Featuresサブパケットも実装する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "An implementation may freely infer features from other suitable implementation-dependent mechanisms.",
      "ja": "実装は、他の適切な実装依存のメカニズムから機能を自由に推測できます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.25. Signature Target",
      "section_title": true,
      "ja": "5.2.3.25. 署名ターゲット"
    },
    {
      "indent": 3,
      "text": "(1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)",
      "ja": "（1オクテット公開鍵アルゴリズム、1オクテットハッシュアルゴリズム、Nオクテットハッシュ）"
    },
    {
      "indent": 3,
      "text": "This subpacket identifies a specific target signature to which a signature refers. For revocation signatures, this subpacket provides explicit designation of which signature is being revoked. For a third-party or timestamp signature, this designates what signature is signed. All arguments are an identifier of that target signature.",
      "ja": "このサブパケットは、シグニチャが参照する特定のターゲットシグニチャを識別します。失効署名の場合、このサブパケットは失効する署名の明示的な指定を提供します。サードパーティまたはタイムスタンプ署名の場合、これは署名される署名を示します。すべての引数は、そのターゲットシグネチャの識別子です。"
    },
    {
      "indent": 3,
      "text": "The N octets of hash data MUST be the size of the hash of the signature. For example, a target signature with a SHA-1 hash MUST have 20 octets of hash data.",
      "ja": "ハッシュデータのNオクテットは、署名のハッシュのサイズでなければなりません。たとえば、SHA-1ハッシュを含むターゲットシグネチャには、20オクテットのハッシュデータが必要です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.26. Embedded Signature",
      "section_title": true,
      "ja": "5.2.3.26. 埋め込み署名"
    },
    {
      "indent": 3,
      "text": "(1 signature packet body)",
      "ja": "（1つの署名パケット本体）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a complete Signature packet body as specified in Section 5.2 above. It is useful when one signature needs to refer to, or be incorporated in, another signature.",
      "ja": "このサブパケットには、上記のセクション5.2で指定されている完全な署名パケットの本文が含まれています。これは、ある署名が別の署名を参照または組み込む必要がある場合に役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Computing Signatures",
      "section_title": true,
      "ja": "5.2.4. 署名の計算"
    },
    {
      "indent": 3,
      "text": "All signatures are formed by producing a hash over the signature data, and then using the resulting hash in the signature algorithm.",
      "ja": "すべての署名は、署名データに対してハッシュを生成し、結果のハッシュを署名アルゴリズムで使用することによって形成されます。"
    },
    {
      "indent": 3,
      "text": "For binary document signatures (type 0x00), the document data is hashed directly. For text document signatures (type 0x01), the document is canonicalized by converting line endings to <CR><LF>, and the resulting data is hashed.",
      "ja": "バイナリドキュメント署名（タイプ0x00）の場合、ドキュメントデータは直接ハッシュされます。テキストドキュメントの署名（タイプ0x01）の場合、ドキュメントは行末を<CR> <LF>に変換することによって正規化され、結果のデータはハッシュされます。"
    },
    {
      "indent": 3,
      "text": "When a signature is made over a key, the hash data starts with the octet 0x99, followed by a two-octet length of the key, and then body of the key packet. (Note that this is an old-style packet header for a key packet with two-octet length.) A subkey binding signature (type 0x18) or primary key binding signature (type 0x19) then hashes the subkey using the same format as the main key (also using 0x99 as the first octet). Key revocation signatures (types 0x20 and 0x28) hash only the key being revoked.",
      "ja": "署名が鍵を介して作成される場合、ハッシュデータはオクテット0x99で始まり、2オクテットの長さの鍵が続き、次に鍵パケットの本体が続きます。 （これは2オクテット長のキーパケットの古いスタイルのパケットヘッダーであることに注意してください。）サブキーバインディング署名（タイプ0x18）またはプライマリキーバインディング署名（タイプ0x19）は、メインと同じ形式を使用してサブキーをハッシュします。キー（最初のオクテットとして0x99も使用）。鍵取り消し署名（タイプ0x20および0x28）は、取り消される鍵のみをハッシュします。"
    },
    {
      "indent": 3,
      "text": "A certification signature (type 0x10 through 0x13) hashes the User ID being bound to the key into the hash context after the above data. A V3 certification hashes the contents of the User ID or attribute packet packet, without any header. A V4 certification hashes the constant 0xB4 for User ID certifications or the constant 0xD1 for User Attribute certifications, followed by a four-octet number giving the length of the User ID or User Attribute data, and then the User ID or User Attribute data.",
      "ja": "証明書署名（タイプ0x10〜0x13）は、上記のデータの後に、キーにバインドされているユーザーIDをハッシュコンテキストにハッシュします。 V3証明書は、ヘッダーなしでユーザーIDまたは属性パケットパケットの内容をハッシュします。 V4認定は、ユーザーID認定の場合は定数0xB4、ユーザー属性認定の場合は定数0xD1をハッシュし、その後に4オクテットの数字がユーザーIDまたはユーザー属性データの長さを示し、次にユーザーIDまたはユーザー属性データをハッシュします。"
    },
    {
      "indent": 3,
      "text": "When a signature is made over a Signature packet (type 0x50), the hash data starts with the octet 0x88, followed by the four-octet length of the signature, and then the body of the Signature packet. (Note that this is an old-style packet header for a Signature packet with the length-of-length set to zero.) The unhashed subpacket data of the Signature packet being hashed is not included in the hash, and the unhashed subpacket data length value is set to zero.",
      "ja": "署名が署名パケット（タイプ0x50）で作成される場合、ハッシュデータはオクテット0x88で始まり、4オクテットの長さの署名が続き、その後に署名パケットの本体が続きます。 （これは、length-of-lengthがゼロに設定されたSignatureパケットの古いスタイルのパケットヘッダーであることに注意してください。）ハッシュされるSignatureパケットのハッシュされていないサブパケットデータはハッシュに含まれず、ハッシュされていないサブパケットデータの長さ値はゼロに設定されます。"
    },
    {
      "indent": 0,
      "text": " Once the data body is hashed, then a trailer is hashed. A V3 signature hashes five octets of the packet body, starting from the signature type field. This data is the signature type, followed by the four-octet signature time. A V4 signature hashes the packet body starting from its first field, the version number, through the end of the hashed subpacket data. Thus, the fields hashed are the signature version, the signature type, the public-key algorithm, the hash algorithm, the hashed subpacket length, and the hashed subpacket body.",
      "ja": "データ本体がハッシュされると、トレーラーがハッシュされます。 V3シグニチャは、シグニチャタイプフィールドから開始して、パケット本体の5オクテットをハッシュします。このデータは署名タイプで、4オクテットの署名時間が続きます。 V4シグニチャは、最初のフィールドであるバージョン番号から始まり、ハッシュされたサブパケットデータの最後まで、パケット本体をハッシュします。したがって、ハッシュされるフィールドは、署名バージョン、署名タイプ、公開鍵アルゴリズム、ハッシュアルゴリズム、ハッシュサブパケット長、およびハッシュサブパケットボディです。"
    },
    {
      "indent": 3,
      "text": "V4 signatures also hash in a final trailer of six octets: the version of the Signature packet, i.e., 0x04; 0xFF; and a four-octet, big-endian number that is the length of the hashed data from the Signature packet (note that this number does not include these final six octets).",
      "ja": "V4署名は、6オクテットの最後のトレーラーでもハッシュされます。署名パケットのバージョン、つまり0x04。 0xFF;署名パケットからのハッシュデータの長さである4オクテットのビッグエンディアン数（この数にはこれらの最後の6オクテットは含まれないことに注意してください）。"
    },
    {
      "indent": 3,
      "text": "After all this has been hashed in a single hash context, the resulting hash field is used in the signature algorithm and placed at the end of the Signature packet.",
      "ja": "これがすべて1つのハッシュコンテキストでハッシュされた後、結果のハッシュフィールドが署名アルゴリズムで使用され、署名パケットの最後に配置されます。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Subpacket Hints",
      "section_title": true,
      "ja": "5.2.4.1. サブパケットヒント"
    },
    {
      "indent": 3,
      "text": "It is certainly possible for a signature to contain conflicting information in subpackets. For example, a signature may contain multiple copies of a preference or multiple expiration times. In most cases, an implementation SHOULD use the last subpacket in the signature, but MAY use any conflict resolution scheme that makes more sense. Please note that we are intentionally leaving conflict resolution to the implementer; most conflicts are simply syntax errors, and the wishy-washy language here allows a receiver to be generous in what they accept, while putting pressure on a creator to be stingy in what they generate.",
      "ja": "署名がサブパケットに矛盾する情報を含むことは確かに可能です。たとえば、シグニチャには、プリファレンスの複数のコピーまたは複数の有効期限が含まれる場合があります。ほとんどの場合、実装は署名の最後のサブパケットを使用する必要があります（SHOULD）が、より意味のある競合解決スキームを使用してもかまいません（MAY）。意図的に競合の解決を実装者に任せていることに注意してください。ほとんどの衝突は単に構文エラーであり、ここでの希望に満ちた言語は、レシーバーが受け入れるものに寛大であり、クリエーターが生成するものにけちをするよう圧力をかけることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Some apparent conflicts may actually make sense -- for example, suppose a keyholder has a V3 key and a V4 key that share the same RSA key material. Either of these keys can verify a signature created by the other, and it may be reasonable for a signature to contain an issuer subpacket for each key, as a way of explicitly tying those keys to the signature.",
      "ja": "一部の明らかな競合は実際に意味をなす場合があります。たとえば、キーホルダーに同じRSAキーマテリアルを共有するV3キーとV4キーがあるとします。これらのキーのいずれかは、他のキーによって作成された署名を検証できます。これらのキーを署名に明示的に結び付ける方法として、署名に各キーの発行者サブパケットを含めるのが妥当な場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Symmetric-Key Encrypted Session Key Packets (Tag 3)",
      "section_title": true,
      "ja": "5.3. 対称鍵暗号化セッション鍵パケット（タグ3）"
    },
    {
      "indent": 3,
      "text": "The Symmetric-Key Encrypted Session Key packet holds the symmetric-key encryption of a session key used to encrypt a message. Zero or more Public-Key Encrypted Session Key packets and/or Symmetric-Key Encrypted Session Key packets may precede a Symmetrically Encrypted Data packet that holds an encrypted message. The message is encrypted with a session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet or the Symmetric-Key Encrypted Session Key packet.",
      "ja": "対称鍵暗号化セッション鍵パケットは、メッセージの暗号化に使用されるセッション鍵の対称鍵暗号化を保持します。ゼロ以上の公開鍵暗号化セッションキーパケットおよび/または対称鍵暗号化セッションキーパケットは、暗号化されたメッセージを保持する対称暗号化データパケットの前にある場合があります。メッセージはセッションキーで暗号化され、セッションキー自体が暗号化されて、暗号化セッションキーパケットまたは対称キー暗号化セッションキーパケットに格納されます。"
    },
    {
      "indent": 3,
      "text": "If the Symmetrically Encrypted Data packet is preceded by one or more Symmetric-Key Encrypted Session Key packets, each specifies a passphrase that may be used to decrypt the message. This allows a message to be encrypted to a number of public keys, and also to one or more passphrases. This packet type is new and is not generated by PGP 2.x or PGP 5.0.",
      "ja": "Symmetrically Encrypted Dataパケットの前に1つ以上のSymmetric-Key Encrypted Session Keyパケットがある場合、それぞれがメッセージの復号化に使用できるパスフレーズを指定します。これにより、メッセージをいくつかの公開鍵および1つ以上のパスフレーズで暗号化できます。このパケットタイプは新しく、PGP 2.xまたはPGP 5.0では生成されません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number. The only currently defined version is 4.",
      "ja": "- 1オクテットのバージョン番号。現在定義されている唯一のバージョンは4です。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the symmetric algorithm used.",
      "ja": "- 使用される対称アルゴリズムを表す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A string-to-key (S2K) specifier, length as defined above.",
      "ja": "- string-to-key（S2K）指定子、上記で定義された長さ。"
    },
    {
      "indent": 5,
      "text": "- Optionally, the encrypted session key itself, which is decrypted with the string-to-key object.",
      "ja": "- オプションで、暗号化されたセッションキー自体。文字列からキーへのオブジェクトで復号化されます。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is not present (which can be detected on the basis of packet length and S2K specifier size), then the S2K algorithm applied to the passphrase produces the session key for decrypting the file, using the symmetric cipher algorithm from the Symmetric-Key Encrypted Session Key packet.",
      "ja": "暗号化されたセッションキーが存在しない場合（パケット長とS2K指定子サイズに基づいて検出可能）、パスフレーズに適用されたS2Kアルゴリズムは、対称からの対称暗号アルゴリズムを使用して、ファイルを復号化するためのセッションキーを生成します。 -Key暗号化セッションキーパケット。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is present, the result of applying the S2K algorithm to the passphrase is used to decrypt just that encrypted session key field, using CFB mode with an IV of all zeros. The decryption result consists of a one-octet algorithm identifier that specifies the symmetric-key encryption algorithm used to encrypt the following Symmetrically Encrypted Data packet, followed by the session key octets themselves.",
      "ja": "暗号化されたセッションキーが存在する場合、パスフレーズにS2Kアルゴリズムを適用した結果を使用して、IVがすべて0のCFBモードを使用して、その暗号化されたセッションキーフィールドのみが復号化されます。復号化の結果は、次の対称暗号化データパケットの暗号化に使用される対称キー暗号化アルゴリズムを指定する1オクテットのアルゴリズム識別子と、それに続くセッションキーオクテット自体で構成されます。"
    },
    {
      "indent": 3,
      "text": "Note: because an all-zero IV is used for this decryption, the S2K specifier MUST use a salt value, either a Salted S2K or an Iterated-Salted S2K. The salt value will ensure that the decryption key is not repeated even if the passphrase is reused.",
      "ja": "注：この復号にはすべてゼロのIVが使用されるため、S2K指定子は、Salted S2KまたはIterated-Salted S2Kのいずれかのsalt値を使用する必要があります。 salt値は、パスフレーズが再利用された場合でも、復号化キーが繰り返されないようにします。"
    },
    {
      "indent": 0,
      "text": "5.4. One-Pass Signature Packets (Tag 4)",
      "section_title": true,
      "ja": "5.4. ワンパス署名パケット（タグ4）"
    },
    {
      "indent": 3,
      "text": "The One-Pass Signature packet precedes the signed data and contains enough information to allow the receiver to begin calculating any hashes needed to verify the signature. It allows the Signature packet to be placed at the end of the message, so that the signer can compute the entire signed message in one pass.",
      "ja": "ワンパス署名パケットは、署名されたデータの前にあり、署名を検証するために必要なハッシュの計算を受信者が開始できるようにするのに十分な情報が含まれています。これにより、署名パケットをメッセージの最後に配置できるため、署名者は署名されたメッセージ全体を1回のパスで計算できます。"
    },
    {
      "indent": 3,
      "text": "A One-Pass Signature does not interoperate with PGP 2.6.x or earlier.",
      "ja": "ワンパス署名は、PGP 2.6.x以前とは相互運用できません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number. The current version is 3.",
      "ja": "- 1オクテットのバージョン番号。現在のバージョンは3です。"
    },
    {
      "indent": 5,
      "text": "- A one-octet signature type. Signature types are described in Section 5.2.1.",
      "ja": "- 1オクテットの署名タイプ。シグニチャタイプについては、5.2.1項で説明しています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the hash algorithm used.",
      "ja": "- 使用されるハッシュアルゴリズムを表す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the public-key algorithm used.",
      "ja": "- 使用される公開鍵アルゴリズムを表す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- An eight-octet number holding the Key ID of the signing key.",
      "ja": "- 署名鍵の鍵IDを保持する8オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number holding a flag showing whether the signature is nested. A zero value indicates that the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.",
      "ja": "- 署名がネストされているかどうかを示すフラグを保持する1オクテットの数値。ゼロの値は、次のパケットが、同じメッセージデータに適用される別の署名を記述する別のワンパス署名パケットであることを示します。"
    },
    {
      "indent": 3,
      "text": "Note that if a message contains more than one one-pass signature, then the Signature packets bracket the message; that is, the first Signature packet after the message corresponds to the last one-pass packet and the final Signature packet corresponds to the first one-pass packet.",
      "ja": "メッセージに複数のワンパス署名が含まれている場合、署名パケットはメッセージを囲みます。つまり、メッセージの後の最初の署名パケットは最後のワンパスパケットに対応し、最後の署名パケットは最初のワンパスパケットに対応します。"
    },
    {
      "indent": 0,
      "text": "5.5. Key Material Packet",
      "section_title": true,
      "ja": "5.5. キーマテリアルパケット"
    },
    {
      "indent": 3,
      "text": "A key material packet contains all the information about a public or private key. There are four variants of this packet type, and two major versions. Consequently, this section is complex.",
      "ja": "鍵素材パケットには、公開鍵または秘密鍵に関するすべての情報が含まれています。このパケットタイプには4つのバリアントがあり、2つのメジャーバージョンがあります。したがって、このセクションは複雑です。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Key Packet Variants",
      "section_title": true,
      "ja": "5.5.1. 主要なパケットバリアント"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Public-Key Packet (Tag 6)",
      "section_title": true,
      "ja": "5.5.1.1. 公開鍵パケット（タグ6）"
    },
    {
      "indent": 3,
      "text": "A Public-Key packet starts a series of packets that forms an OpenPGP key (sometimes called an OpenPGP certificate).",
      "ja": "公開鍵パケットは、OpenPGP鍵（OpenPGP証明書と呼ばれることもあります）を形成する一連のパケットを開始します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Public-Subkey Packet (Tag 14)",
      "section_title": true,
      "ja": "5.5.1.2. 公開サブキーパケット（タグ14）"
    },
    {
      "indent": 3,
      "text": "A Public-Subkey packet (tag 14) has exactly the same format as a Public-Key packet, but denotes a subkey. One or more subkeys may be associated with a top-level key. By convention, the top-level key provides signature services, and the subkeys provide encryption services.",
      "ja": "公開サブキーパケット（タグ14）の形式は公開キーパケットとまったく同じですが、サブキーを示します。 1つ以上のサブキーをトップレベルのキーに関連付けることができます。慣例により、トップレベルのキーは署名サービスを提供し、サブキーは暗号化サービスを提供します。"
    },
    {
      "indent": 0,
      "text": " Note: in PGP 2.6.x, tag 14 was intended to indicate a comment packet. This tag was selected for reuse because no previous version of PGP ever emitted comment packets but they did properly ignore them. Public-Subkey packets are ignored by PGP 2.6.x and do not cause it to fail, providing a limited degree of backward compatibility.",
      "ja": "注：PGP 2.6.xでは、タグ14はコメントパケットを示すためのものでした。以前のバージョンのPGPではコメントパケットが出力されなかったため、このタグは再利用のために選択されましたが、それらは適切に無視されました。公開サブキーパケットはPGP 2.6.xによって無視され、失敗することはないため、ある程度の下位互換性があります。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Secret-Key Packet (Tag 5)",
      "section_title": true,
      "ja": "5.5.1.3. 秘密鍵パケット（タグ5）"
    },
    {
      "indent": 3,
      "text": "A Secret-Key packet contains all the information that is found in a Public-Key packet, including the public-key material, but also includes the secret-key material after all the public-key fields.",
      "ja": "秘密鍵パケットには、公開鍵マテリアルを含む、公開鍵パケットで見つかったすべての情報が含まれていますが、すべての公開鍵フィールドの後に秘密鍵マテリアルも含まれています。"
    },
    {
      "indent": 0,
      "text": "5.5.1.4. Secret-Subkey Packet (Tag 7)",
      "section_title": true,
      "ja": "5.5.1.4. シークレットサブキーパケット（タグ7）"
    },
    {
      "indent": 3,
      "text": "A Secret-Subkey packet (tag 7) is the subkey analog of the Secret Key packet and has exactly the same format.",
      "ja": "シークレットサブキーパケット（タグ7）は、シークレットキーパケットのサブキーアナログであり、形式はまったく同じです。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Public-Key Packet Formats",
      "section_title": true,
      "ja": "5.5.2. 公開鍵パケット形式"
    },
    {
      "indent": 3,
      "text": "There are two versions of key-material packets. Version 3 packets were first generated by PGP 2.6. Version 4 keys first appeared in PGP 5.0 and are the preferred key version for OpenPGP.",
      "ja": "キーマテリアルパケットには2つのバージョンがあります。バージョン3のパケットは、最初にPGP 2.6で生成されました。バージョン4のキーはPGP 5.0で最初に登場し、OpenPGPで推奨されるキーバージョンです。"
    },
    {
      "indent": 3,
      "text": "OpenPGP implementations MUST create keys with version 4 format. V3 keys are deprecated; an implementation MUST NOT generate a V3 key, but MAY accept it.",
      "ja": "OpenPGP実装は、バージョン4形式でキーを作成する必要があります。 V3キーは非推奨です。実装はV3キーを生成してはならない（MUST NOT）、しかしそれを受け入れてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "A version 3 public key or public-subkey packet contains:",
      "ja": "バージョン3の公開キーまたは公開サブキーパケットには、次のものが含まれます。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number (3).",
      "ja": "- 1オクテットのバージョン番号（3）。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number denoting the time that the key was created.",
      "ja": "- キーが作成された時刻を示す4オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A two-octet number denoting the time in days that this key is valid. If this number is zero, then it does not expire.",
      "ja": "- このキーが有効な日数を表す2オクテットの数値。この数がゼロの場合、有効期限はありません。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number denoting the public-key algorithm of this key.",
      "ja": "- この鍵の公開鍵アルゴリズムを示す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A series of multiprecision integers comprising the key material:",
      "ja": "- キーマテリアルを構成する一連の多重精度整数："
    },
    {
      "indent": 11,
      "text": "- a multiprecision integer (MPI) of RSA public modulus n;",
      "ja": "- RSAパブリックモジュラスnの多精度整数（MPI）。"
    },
    {
      "indent": 11,
      "text": "- an MPI of RSA public encryption exponent e.",
      "ja": "- RSA公開暗号化指数のMPI e。"
    },
    {
      "indent": 0,
      "text": " V3 keys are deprecated. They contain three weaknesses. First, it is relatively easy to construct a V3 key that has the same Key ID as any other key because the Key ID is simply the low 64 bits of the public modulus. Secondly, because the fingerprint of a V3 key hashes the key material, but not its length, there is an increased opportunity for fingerprint collisions. Third, there are weaknesses in the MD5 hash algorithm that make developers prefer other algorithms. See below for a fuller discussion of Key IDs and fingerprints.",
      "ja": "V3キーは非推奨です。それらには3つの弱点があります。まず、キーIDは単に公開モジュールの下位64ビットであるため、他のキーと同じキーIDを持つV3キーを構築するのは比較的簡単です。第二に、V3キーのフィンガープリントはキーマテリアルをハッシュしますが、その長さはハッシュしないため、フィンガープリントの衝突の機会が増えます。第3に、MD5ハッシュアルゴリズムには、開発者が他のアルゴリズムを好む弱点があります。キーIDとフィンガープリントの詳細については、以下をご覧ください。"
    },
    {
      "indent": 3,
      "text": "V2 keys are identical to the deprecated V3 keys except for the version number. An implementation MUST NOT generate them and MAY accept or reject them as it sees fit.",
      "ja": "V2キーは、バージョン番号を除いて、非推奨のV3キーと同じです。実装はそれらを生成してはならず（MUST NOT）、それらが適切であると考えるようにそれらを受け入れたり、拒否したりする場合があります。"
    },
    {
      "indent": 3,
      "text": "The version 4 format is similar to the version 3 format except for the absence of a validity period. This has been moved to the Signature packet. In addition, fingerprints of version 4 keys are calculated differently from version 3 keys, as described in the section \"Enhanced Key Formats\".",
      "ja": "バージョン4の形式は、有効期間がないことを除いて、バージョン3の形式と似ています。これは署名パケットに移動されました。また、バージョン4のキーのフィンガープリントは、バージョン3のキーとは異なる方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "A version 4 packet contains:",
      "ja": "バージョン4パケットには以下が含まれます。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number (4).",
      "ja": "- 1オクテットのバージョン番号（4）。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number denoting the time that the key was created.",
      "ja": "- キーが作成された時刻を示す4オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number denoting the public-key algorithm of this key.",
      "ja": "- この鍵の公開鍵アルゴリズムを示す1オクテットの数値。"
    },
    {
      "indent": 5,
      "text": "- A series of multiprecision integers comprising the key material. This algorithm-specific portion is:",
      "ja": "- キーマテリアルを構成する一連の多重精度整数。このアルゴリズム固有の部分は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for RSA public keys:",
      "ja": "RSA公開鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 9,
      "text": "- multiprecision integer (MPI) of RSA public modulus n;",
      "ja": "- RSAパブリックモジュラスnの多精度整数（MPI）。"
    },
    {
      "indent": 9,
      "text": "- MPI of RSA public encryption exponent e.",
      "ja": "- RSA公開暗号化指数のMPI e。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for DSA public keys:",
      "ja": "DSA公開鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 9,
      "text": "- MPI of DSA prime p;",
      "ja": "- DSAプライムpのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA group order q (q is a prime divisor of p-1);",
      "ja": "- DSAグループ次数qのMPI（qはp-1の素数）。"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA group generator g;",
      "ja": "- DSAグループジェネレーターのMPI g;"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA public-key value y (= g**x mod p where x is secret).",
      "ja": "- DSA公開鍵値y（= g ** x mod p、xは秘密）のMPI。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for Elgamal public keys:",
      "ja": "Elgamal公開鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal prime p;",
      "ja": "- Elgamal素数pのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal group generator g;",
      "ja": "- ElgamalグループジェネレーターのMPI g;"
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal public key value y (= g**x mod p where x is secret).",
      "ja": "- Elgamal公開鍵の値y（= g ** x mod p、xは秘密）のMPI。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Secret-Key Packet Formats",
      "section_title": true,
      "ja": "5.5.3. 秘密鍵パケット形式"
    },
    {
      "indent": 3,
      "text": "The Secret-Key and Secret-Subkey packets contain all the data of the Public-Key and Public-Subkey packets, with additional algorithm-specific secret-key data appended, usually in encrypted form.",
      "ja": "秘密鍵パケットと秘密サブキーパケットには、公開鍵パケットと公開サブキーパケットのすべてのデータが含まれ、通常は暗号化された形式で、追加のアルゴリズム固有の秘密鍵データが追加されます。"
    },
    {
      "indent": 3,
      "text": "The packet contains:",
      "ja": "パケットに含まれるもの："
    },
    {
      "indent": 5,
      "text": "- A Public-Key or Public-Subkey packet, as described above.",
      "ja": "- 上記の公開鍵または公開サブキーのパケット。"
    },
    {
      "indent": 5,
      "text": "- One octet indicating string-to-key usage conventions. Zero indicates that the secret-key data is not encrypted. 255 or 254 indicates that a string-to-key specifier is being given. Any other value is a symmetric-key encryption algorithm identifier.",
      "ja": "- 文字列からキーへの使用規則を示す1オクテット。ゼロは、秘密鍵データが暗号化されていないことを示します。 255または254は、文字列からキーへの指定子が指定されていることを示します。その他の値は、対称鍵暗号化アルゴリズムの識別子です。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If string-to-key usage octet was 255 or 254, a one-octet symmetric encryption algorithm.",
      "ja": "- [オプション]文字列からキーへの使用オクテットが255または254の場合、1オクテットの対称暗号化アルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If string-to-key usage octet was 255 or 254, a string-to-key specifier. The length of the string-to-key specifier is implied by its type, as described above.",
      "ja": "- [オプション]文字列からキーへの使用オクテットが255または254の場合、文字列からキーへの指定子。上記のように、文字列からキーへの指定子の長さは、そのタイプによって暗示されます。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If secret data is encrypted (string-to-key usage octet not zero), an Initial Vector (IV) of the same length as the cipher's block size.",
      "ja": "- [オプション]秘密データが暗号化されている場合（文字列からキーへの使用オクテットがゼロではない場合）、暗号のブロックサイズと同じ長さの初期ベクトル（IV）。"
    },
    {
      "indent": 5,
      "text": "- Plain or encrypted multiprecision integers comprising the secret key data. These algorithm-specific fields are as described below.",
      "ja": "- 秘密鍵データを構成するプレーンまたは暗号化された多精度整数。これらのアルゴリズム固有のフィールドは以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "- If the string-to-key usage octet is zero or 255, then a two-octet checksum of the plaintext of the algorithm-specific portion (sum of all octets, mod 65536). If the string-to-key usage octet was 254, then a 20-octet SHA-1 hash of the plaintext of the algorithm-specific portion. This checksum or hash is encrypted together with the algorithm-specific fields (if string-to-key usage octet is not zero). Note that for all other values, a two-octet checksum is required.",
      "ja": "- 文字列からキーへの使用オクテットが0または255の場合、アルゴリズム固有部分の平文の2オクテットチェックサム（すべてのオクテットの合計、mod 65536）。文字列からキーへの使用オクテットが254の場合、アルゴリズム固有部分の平文の20オクテットSHA-1ハッシュ。このチェックサムまたはハッシュは、アルゴリズム固有のフィールドとともに暗号化されます（文字列からキーへの使用オクテットがゼロでない場合）。他のすべての値については、2オクテットのチェックサムが必要であることに注意してください。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for RSA secret keys:",
      "ja": "RSA秘密鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 7,
      "text": "- multiprecision integer (MPI) of RSA secret exponent d.",
      "ja": "- RSA秘密指数の多重精度整数（MPI）d。"
    },
    {
      "indent": 7,
      "text": "- MPI of RSA secret prime value p.",
      "ja": "- RSA秘密プライム値pのMPI。"
    },
    {
      "indent": 7,
      "text": "- MPI of RSA secret prime value q (p < q).",
      "ja": "- RSAシークレットプライム値q（p <q）のMPI。"
    },
    {
      "indent": 7,
      "text": "- MPI of u, the multiplicative inverse of p, mod q.",
      "ja": "- uのMPI、pの乗法逆数、mod q。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for DSA secret keys:",
      "ja": "DSA秘密鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 7,
      "text": "- MPI of DSA secret exponent x.",
      "ja": "- DSA秘密指数xのMPI。"
    },
    {
      "indent": 7,
      "text": "Algorithm-Specific Fields for Elgamal secret keys:",
      "ja": "Elgamal秘密鍵のアルゴリズム固有のフィールド："
    },
    {
      "indent": 7,
      "text": "- MPI of Elgamal secret exponent x.",
      "ja": "- Elgamal秘密指数xのMPI。"
    },
    {
      "indent": 3,
      "text": "Secret MPI values can be encrypted using a passphrase. If a string-to-key specifier is given, that describes the algorithm for converting the passphrase to a key, else a simple MD5 hash of the passphrase is used. Implementations MUST use a string-to-key specifier; the simple hash is for backward compatibility and is deprecated, though implementations MAY continue to use existing private keys in the old format. The cipher for encrypting the MPIs is specified in the Secret-Key packet.",
      "ja": "秘密のMPI値は、パスフレーズを使用して暗号化できます。文字列からキーへの指定子が指定されている場合は、パスフレーズをキーに変換するためのアルゴリズムが記述されています。それ以外の場合は、パスフレーズの単純なMD5ハッシュが使用されます。実装では、文字列からキーへの指定子を使用する必要があります。単純なハッシュは下位互換性のためにあり、非推奨ですが、実装は古い形式の既存の秘密鍵を引き続き使用できます（MAY）。 MPIを暗号化するための暗号は、秘密鍵パケットで指定されます。"
    },
    {
      "indent": 3,
      "text": "Encryption/decryption of the secret data is done in CFB mode using the key created from the passphrase and the Initial Vector from the packet. A different mode is used with V3 keys (which are only RSA) than with other key formats. With V3 keys, the MPI bit count prefix (i.e., the first two octets) is not encrypted. Only the MPI non-prefix data is encrypted. Furthermore, the CFB state is resynchronized at the beginning of each new MPI value, so that the CFB block boundary is aligned with the start of the MPI data.",
      "ja": "秘密データの暗号化/復号化は、パスフレーズから作成されたキーとパケットからの初期ベクトルを使用してCFBモードで行われます。 V3キー（RSAのみ）では、他のキー形式とは異なるモードが使用されます。 V3キーでは、MPIビットカウントプレフィックス（つまり、最初の2つのオクテット）は暗号化されません。 MPI非プレフィックスデータのみが暗号化されます。さらに、CFB状態は新しい各MPI値の先頭で再同期されるため、CFBブロックの境界はMPIデータの先頭に揃えられます。"
    },
    {
      "indent": 3,
      "text": "With V4 keys, a simpler method is used. All secret MPI values are encrypted in CFB mode, including the MPI bitcount prefix.",
      "ja": "V4キーでは、より簡単な方法が使用されます。すべての秘密のMPI値は、MPIビットカウントプレフィックスを含め、CFBモードで暗号化されます。"
    },
    {
      "indent": 3,
      "text": "The two-octet checksum that follows the algorithm-specific portion is the algebraic sum, mod 65536, of the plaintext of all the algorithm-specific octets (including MPI prefix and data). With V3 keys, the checksum is stored in the clear. With V4 keys, the checksum is encrypted like the algorithm-specific data. This value is used to check that the passphrase was correct. However, this checksum is deprecated; an implementation SHOULD NOT use it, but should rather use the SHA-1 hash denoted with a usage octet of 254. The reason for this is that there are some attacks that involve undetectably modifying the secret key.",
      "ja": "アルゴリズム固有の部分に続く2オクテットのチェックサムは、アルゴリズム固有のすべてのオクテット（MPIプレフィックスとデータを含む）の平文の代数和mod 65536です。 V3キーでは、チェックサムはクリアテキストで保存されます。 V4キーでは、チェックサムはアルゴリズム固有のデータのように暗号化されます。この値は、パスフレーズが正しいことを確認するために使用されます。ただし、このチェックサムは非推奨です。実装はそれを使用すべきではありませんが、使用オクテット254で示されるSHA-1ハッシュを使用する必要があります。これは、秘密鍵の検出不能な変更を伴う攻撃があるためです。"
    },
    {
      "indent": 0,
      "text": "5.6. Compressed Data Packet (Tag 8)",
      "section_title": true,
      "ja": "5.6. 圧縮データパケット（タグ8）"
    },
    {
      "indent": 3,
      "text": "The Compressed Data packet contains compressed data. Typically, this packet is found as the contents of an encrypted packet, or following a Signature or One-Pass Signature packet, and contains a literal data packet.",
      "ja": "圧縮データパケットには圧縮データが含まれています。通常、このパケットは、暗号化されたパケットのコンテンツとして、または署名またはワンパス署名パケットの後に見つかり、リテラルデータパケットを含みます。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- One octet that gives the algorithm used to compress the packet.",
      "ja": "- パケットの圧縮に使用されるアルゴリズムを提供する1オクテット。"
    },
    {
      "indent": 5,
      "text": "- Compressed data, which makes up the remainder of the packet.",
      "ja": "- パケットの残りを構成する圧縮データ。"
    },
    {
      "indent": 3,
      "text": "A Compressed Data Packet's body contains an block that compresses some set of packets. See section \"Packet Composition\" for details on how messages are formed.",
      "ja": "圧縮データパケットの本体には、パケットのセットを圧縮するブロックが含まれています。メッセージの形成方法の詳細については、「パケットの構成」を参照してください。"
    },
    {
      "indent": 3,
      "text": "ZIP-compressed packets are compressed with raw RFC 1951 [RFC1951] DEFLATE blocks. Note that PGP V2.6 uses 13 bits of compression. If an implementation uses more bits of compression, PGP V2.6 cannot decompress it.",
      "ja": "ZIP圧縮されたパケットは、生のRFC 1951 [RFC1951] DEFLATEブロックで圧縮されます。 PGP V2.6は13ビットの圧縮を使用することに注意してください。実装でより多くの圧縮ビットを使用する場合、PGP V2.6は圧縮を解凍できません。"
    },
    {
      "indent": 3,
      "text": "ZLIB-compressed packets are compressed with RFC 1950 [RFC1950] ZLIB-style blocks.",
      "ja": "ZLIBで圧縮されたパケットは、RFC 1950 [RFC1950] ZLIBスタイルのブロックで圧縮されます。"
    },
    {
      "indent": 3,
      "text": "BZip2-compressed packets are compressed using the BZip2 [BZ2] algorithm.",
      "ja": "BZip2圧縮パケットは、BZip2 [BZ2]アルゴリズムを使用して圧縮されます。"
    },
    {
      "indent": 0,
      "text": "5.7. Symmetrically Encrypted Data Packet (Tag 9)",
      "section_title": true,
      "ja": "5.7. 対称的に暗号化されたデータパケット（タグ9）"
    },
    {
      "indent": 3,
      "text": "The Symmetrically Encrypted Data packet contains data encrypted with a symmetric-key algorithm. When it has been decrypted, it contains other packets (usually a literal data packet or compressed data packet, but in theory other Symmetrically Encrypted Data packets or sequences of packets that form whole OpenPGP messages).",
      "ja": "Symmetrically Encrypted Dataパケットには、対称鍵アルゴリズムで暗号化されたデータが含まれています。復号化されると、他のパケットが含まれます（通常、リテラルデータパケットまたは圧縮データパケットですが、理論的には、他の対称暗号化データパケットまたはOpenPGPメッセージ全体を形成する一連のパケット）。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- Encrypted data, the output of the selected symmetric-key cipher operating in OpenPGP's variant of Cipher Feedback (CFB) mode.",
      "ja": "- 暗号化されたデータ、OpenPGPのバリアントであるCipher Feedback（CFB）モードで動作する選択された対称鍵暗号の出力。"
    },
    {
      "indent": 3,
      "text": "The symmetric cipher used may be specified in a Public-Key or Symmetric-Key Encrypted Session Key packet that precedes the Symmetrically Encrypted Data packet. In that case, the cipher algorithm octet is prefixed to the session key before it is encrypted. If no packets of these types precede the encrypted data, the IDEA algorithm is used with the session key calculated as the MD5 hash of the passphrase, though this use is deprecated.",
      "ja": "使用される対称暗号は、対称暗号化データパケットに先行する公開鍵または対称鍵暗号化セッションキーパケットで指定できます。その場合、暗号化アルゴリズムのオクテットは、暗号化される前にセッションキーの前に付加されます。暗号化されたデータの前にこれらのタイプのパケットがない場合、IDEAアルゴリズムはパスフレーズのMD5ハッシュとして計算されたセッションキーで使用されますが、この使用は非推奨です。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in CFB mode, with a CFB shift size equal to the cipher's block size. The Initial Vector (IV) is specified as all zeros. Instead of using an IV, OpenPGP prefixes a string of length equal to the block size of the cipher plus two to the data before it is encrypted. The first block-size octets (for example, 8 octets for a 64-bit block length) are random, and the following two octets are copies of the last two octets of the IV. For example, in an 8-octet block, octet 9 is a repeat of octet 7, and octet 10 is a repeat of octet 8. In a cipher of length 16, octet 17 is a repeat of octet 15 and octet 18 is a repeat of octet 16. As a pedantic clarification, in both these examples, we consider the first octet to be numbered 1.",
      "ja": "データはCFBモードで暗号化され、CFBシフトサイズは暗号のブロックサイズと同じです。初期ベクトル（IV）はすべてゼロとして指定されます。 IVを使用する代わりに、OpenPGPは、暗号化の前に、暗号のブロックサイズに2を足した長さの文字列に2を足したものをデータの前に付けます。最初のブロックサイズのオクテット（たとえば、64ビットブロック長の8オクテット）はランダムであり、次の2つのオクテットはIVの最後の2つのオクテットのコピーです。たとえば、8オクテットブロックでは、オクテット9はオクテット7のリピートであり、オクテット10はオクテット8のリピートです。長さ16の暗号では、オクテット17はオクテット15のリピートであり、オクテット18はリピートです。わかりやすく説明するために、これらの例の両方で、最初のオクテットには1と番号を付けます。"
    },
    {
      "indent": 3,
      "text": "After encrypting the first block-size-plus-two octets, the CFB state is resynchronized. The last block-size octets of ciphertext are passed through the cipher and the block boundary is reset.",
      "ja": "最初のブロックサイズと2オクテットを暗号化した後、CFB状態が再同期されます。暗号文の最後のブロックサイズのオクテットが暗号を通過し、ブロック境界がリセットされます。"
    },
    {
      "indent": 3,
      "text": "The repetition of 16 bits in the random data prefixed to the message allows the receiver to immediately check whether the session key is incorrect. See the \"Security Considerations\" section for hints on the proper use of this \"quick check\".",
      "ja": "メッセージの前に付けられたランダムデータの16ビットの繰り返しにより、受信者はセッションキーが正しくないかどうかをすぐに確認できます。この「クイックチェック」の適切な使用に関するヒントについては、「セキュリティの考慮事項」セクションを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Marker Packet (Obsolete Literal Packet) (Tag 10)",
      "section_title": true,
      "ja": "5.8. マーカーパケット（廃止されたリテラルパケット）（タグ10）"
    },
    {
      "indent": 3,
      "text": "An experimental version of PGP used this packet as the Literal packet, but no released version of PGP generated Literal packets with this tag. With PGP 5.x, this packet has been reassigned and is reserved for use as the Marker packet.",
      "ja": "PGPの実験的なバージョンでは、このパケットをリテラルパケットとして使用していましたが、リリースされたバージョンのPGPは、このタグ付きのリテラルパケットを生成していません。 PGP 5.xでは、このパケットは再割り当てされ、マーカーパケットとして使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- The three octets 0x50, 0x47, 0x50 (which spell \"PGP\" in UTF-8).",
      "ja": "- 3つのオクテット0x50、0x47、0x50（UTF-8で「PGP」のスペル）。"
    },
    {
      "indent": 3,
      "text": "Such a packet MUST be ignored when received. It may be placed at the beginning of a message that uses features not available in PGP 2.6.x in order to cause that version to report that newer software is necessary to process the message.",
      "ja": "このようなパケットは受信時に無視する必要があります。 PGP 2.6.xで使用できない機能を使用するメッセージの最初に配置して、そのバージョンでメッセージの処理に新しいソフトウェアが必要であることを報告させることができます。"
    },
    {
      "indent": 0,
      "text": "5.9. Literal Data Packet (Tag 11)",
      "section_title": true,
      "ja": "5.9. リテラルデータパケット（タグ11）"
    },
    {
      "indent": 3,
      "text": "A Literal Data packet contains the body of a message; data that is not to be further interpreted.",
      "ja": "リテラルデータパケットには、メッセージの本文が含まれます。これ以上解釈されないデータ。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet field that describes how the data is formatted.",
      "ja": "- データのフォーマット方法を説明する1オクテットのフィールド。"
    },
    {
      "indent": 3,
      "text": "If it is a 'b' (0x62), then the Literal packet contains binary data. If it is a 't' (0x74), then it contains text data, and thus may need line ends converted to local form, or other text-mode changes. The tag 'u' (0x75) means the same as 't', but also indicates that implementation believes that the literal data contains UTF-8 text.",
      "ja": "「b」（0x62）の場合、リテラルパケットにはバイナリデータが含まれます。 't'（0x74）の場合は、テキストデータが含まれているため、行末をローカルフォームに変換するか、他のテキストモードを変更する必要があります。タグ「u」（0x75）は「t」と同じ意味ですが、実装がリテラルデータにUTF-8テキストが含まれていると信じていることも示しています。"
    },
    {
      "indent": 3,
      "text": "Early versions of PGP also defined a value of 'l' as a 'local' mode for machine-local conversions. RFC 1991 [RFC1991] incorrectly stated this local mode flag as '1' (ASCII numeral one). Both of these local modes are deprecated.",
      "ja": "PGPの初期のバージョンでは、「l」の値をマシンローカル変換の「ローカル」モードとして定義していました。 RFC 1991 [RFC1991]は、このローカルモードフラグを「1」（ASCII数字の1）と誤って述べています。これらのローカルモードはどちらも非推奨です。"
    },
    {
      "indent": 5,
      "text": "- File name as a string (one-octet length, followed by a file name). This may be a zero-length string. Commonly, if the source of the encrypted data is a file, this will be the name of the encrypted file. An implementation MAY consider the file name in the Literal packet to be a more authoritative name than the actual file name.",
      "ja": "- 文字列としてのファイル名（1オクテット長とそれに続くファイル名）。これは長さがゼロの文字列である場合があります。通常、暗号化されたデータのソースがファイルの場合、これは暗号化されたファイルの名前になります。実装は、リテラルパケット内のファイル名を、実際のファイル名よりも信頼できる名前であると見なす場合があります。"
    },
    {
      "indent": 3,
      "text": "If the special name \"_CONSOLE\" is used, the message is considered to be \"for your eyes only\". This advises that the message data is unusually sensitive, and the receiving program should process it more carefully, perhaps avoiding storing the received data to disk, for example.",
      "ja": "特別な名前「_CONSOLE」が使用されている場合、メッセージは「あなたの目だけのためのもの」と見なされます。これは、メッセージデータは非常に機密性が高いため、受信プログラムはより慎重に処理する必要があることを示しています。たとえば、受信したデータをディスクに保存しないようにします。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number that indicates a date associated with the literal data. Commonly, the date might be the modification date of a file, or the time the packet was created, or a zero that indicates no specific time.",
      "ja": "- リテラルデータに関連付けられた日付を示す4オクテットの数値。一般に、日付はファイルの変更日、パケットが作成された時間、または特定の時間がないことを示すゼロの場合があります。"
    },
    {
      "indent": 5,
      "text": "- The remainder of the packet is literal data.",
      "ja": "- パケットの残りはリテラルデータです。"
    },
    {
      "indent": 7,
      "text": "Text data is stored with <CR><LF> text endings (i.e., network-normal line endings). These should be converted to native line endings by the receiving software.",
      "ja": "テキストデータは、<CR> <LF>テキストエンディング（つまり、ネットワーク通常の行エンディング）で保存されます。これらは、受信ソフトウェアによってネイティブの行末に変換される必要があります。"
    },
    {
      "indent": 0,
      "text": "5.10. Trust Packet (Tag 12)",
      "section_title": true,
      "ja": "5.10. 信頼パケット（タグ12）"
    },
    {
      "indent": 3,
      "text": "The Trust packet is used only within keyrings and is not normally exported. Trust packets contain data that record the user's specifications of which key holders are trustworthy introducers, along with other information that implementing software uses for trust information. The format of Trust packets is defined by a given implementation.",
      "ja": "Trustパケットはキーリング内でのみ使用され、通常はエクスポートされません。信頼パケットには、キーホルダーが信頼できる紹介者であるというユーザーの仕様を記録するデータと、実装ソフトウェアが信頼情報に使用する他の情報が含まれています。 Trustパケットの形式は、特定の実装によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Trust packets SHOULD NOT be emitted to output streams that are transferred to other users, and they SHOULD be ignored on any input other than local keyring files.",
      "ja": "信頼パケットは、他のユーザーに転送される出力ストリームに送信されるべきではなく（SHOULD NOT）、ローカルキーリングファイル以外の入力では無視されるべきです（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "5.11. User ID Packet (Tag 13)",
      "section_title": true,
      "ja": "5.11. ユーザーIDパケット（タグ13）"
    },
    {
      "indent": 3,
      "text": "A User ID packet consists of UTF-8 text that is intended to represent the name and email address of the key holder. By convention, it includes an RFC 2822 [RFC2822] mail name-addr, but there are no restrictions on its content. The packet length in the header specifies the length of the User ID.",
      "ja": "ユーザーIDパケットは、キーホルダーの名前と電子メールアドレスを表すことを目的としたUTF-8テキストで構成されています。慣例により、RFC 2822 [RFC2822]メール名アドレスが含まれますが、その内容に制限はありません。ヘッダーのパケット長は、ユーザーIDの長さを指定します。"
    },
    {
      "indent": 0,
      "text": "5.12. User Attribute Packet (Tag 17)",
      "section_title": true,
      "ja": "5.12. ユーザー属性パケット（タグ17）"
    },
    {
      "indent": 3,
      "text": "The User Attribute packet is a variation of the User ID packet. It is capable of storing more types of data than the User ID packet, which is limited to text. Like the User ID packet, a User Attribute packet may be certified by the key owner (\"self-signed\") or any other key owner who cares to certify it. Except as noted, a User Attribute packet may be used anywhere that a User ID packet may be used.",
      "ja": "ユーザー属性パケットは、ユーザーIDパケットのバリエーションです。テキストに制限されているユーザーIDパケットよりも多くの種類のデータを保存できます。 User IDパケットと同様に、User Attributeパケットは、鍵の所有者（「自己署名」）またはそれを認証することに関心のある他のすべての鍵の所有者によって認証されます。特に明記しない限り、ユーザー属性パケットは、ユーザーIDパケットを使用できる場所であればどこでも使用できます。"
    },
    {
      "indent": 3,
      "text": "While User Attribute packets are not a required part of the OpenPGP standard, implementations SHOULD provide at least enough compatibility to properly handle a certification signature on the User Attribute packet. A simple way to do this is by treating the User Attribute packet as a User ID packet with opaque contents, but an implementation may use any method desired.",
      "ja": "ユーザー属性パケットはOpenPGP標準の必須部分ではありませんが、実装は、ユーザー属性パケットの認証署名を適切に処理するために少なくとも十分な互換性を提供する必要があります（SHOULD）。これを行う簡単な方法は、ユーザー属性パケットを不透明な内容のユーザーIDパケットとして扱うことですが、実装では任意の方法を使用できます。"
    },
    {
      "indent": 3,
      "text": "The User Attribute packet is made up of one or more attribute subpackets. Each subpacket consists of a subpacket header and a body. The header consists of:",
      "ja": "ユーザー属性パケットは、1つ以上の属性サブパケットで構成されています。各サブパケットは、サブパケットヘッダーと本文で構成されます。ヘッダーは次のもので構成されます。"
    },
    {
      "indent": 5,
      "text": "- the subpacket length (1, 2, or 5 octets)",
      "ja": "- サブパケットの長さ（1、2、または5オクテット）"
    },
    {
      "indent": 5,
      "text": "- the subpacket type (1 octet)",
      "ja": "- サブパケットタイプ（1オクテット）"
    },
    {
      "indent": 3,
      "text": "and is followed by the subpacket specific data.",
      "ja": "その後にサブパケット固有のデータが続きます。"
    },
    {
      "indent": 3,
      "text": "The only currently defined subpacket type is 1, signifying an image. An implementation SHOULD ignore any subpacket of a type that it does not recognize. Subpacket types 100 through 110 are reserved for private or experimental use.",
      "ja": "現在定義されている唯一のサブパケットタイプは1で、イメージを示します。実装は、認識しないタイプのサブパケットを無視する必要があります（SHOULD）。サブパケットタイプ100〜110は、プライベートまたは実験用に予約されています。"
    },
    {
      "indent": 0,
      "text": "5.12.1. The Image Attribute Subpacket",
      "section_title": true,
      "ja": "5.12.1. 画像属性サブパケット"
    },
    {
      "indent": 3,
      "text": "The Image Attribute subpacket is used to encode an image, presumably (but not required to be) that of the key owner.",
      "ja": "Image Attributeサブパケットは、おそらくキー所有者の（おそらく必須ではない）画像をエンコードするために使用されます。"
    },
    {
      "indent": 0,
      "text": " The Image Attribute subpacket begins with an image header. The first two octets of the image header contain the length of the image header. Note that unlike other multi-octet numerical values in this document, due to a historical accident this value is encoded as a little-endian number. The image header length is followed by a single octet for the image header version. The only currently defined version of the image header is 1, which is a 16-octet image header. The first three octets of a version 1 image header are thus 0x10, 0x00, 0x01.",
      "ja": "画像属性サブパケットは画像ヘッダーで始まります。画像ヘッダーの最初の2つのオクテットには、画像ヘッダーの長さが含まれています。このドキュメントの他のマルチオクテットの数値とは異なり、歴史的な事故により、この値はリトルエンディアン数としてエンコードされています。画像ヘッダーの長さの後には、画像ヘッダーバージョンの単一オクテットが続きます。現在定義されているイメージヘッダーの唯一のバージョンは1で、16オクテットのイメージヘッダーです。したがって、バージョン1の画像ヘッダーの最初の3つのオクテットは0x10、0x00、0x01です。"
    },
    {
      "indent": 3,
      "text": "The fourth octet of a version 1 image header designates the encoding format of the image. The only currently defined encoding format is the value 1 to indicate JPEG. Image format types 100 through 110 are reserved for private or experimental use. The rest of the version 1 image header is made up of 12 reserved octets, all of which MUST be set to 0.",
      "ja": "バージョン1の画像ヘッダーの4番目のオクテットは、画像のエンコード形式を指定します。現在定義されている唯一のエンコード形式は、JPEGを示す値1です。画像形式タイプ100から110は、私的または実験的な使用のために予約されています。バージョン1のイメージヘッダーの残りの部分は、12の予約済みオクテットで構成されており、そのすべてを0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rest of the image subpacket contains the image itself. As the only currently defined image type is JPEG, the image is encoded in the JPEG File Interchange Format (JFIF), a standard file format for JPEG images [JFIF].",
      "ja": "イメージサブパケットの残りの部分には、イメージ自体が含まれています。現在定義されている画像タイプはJPEGだけなので、画像はJPEG画像の標準ファイル形式であるJPEGファイル交換形式（JFIF）でエンコードされます[JFIF]。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY try to determine the type of an image by examination of the image data if it is unable to handle a particular version of the image header or if a specified encoding format value is not recognized.",
      "ja": "実装は、画像ヘッダーの特定のバージョンを処理できない場合、または指定されたエンコード形式の値が認識されない場合、画像データを調べて画像のタイプを判別しようとする場合があります。"
    },
    {
      "indent": 0,
      "text": "5.13. Sym. Encrypted Integrity Protected Data Packet (Tag 18)",
      "section_title": true,
      "ja": "5.13. 対称。暗号化された整合性保護データパケット（タグ18）"
    },
    {
      "indent": 3,
      "text": "The Symmetrically Encrypted Integrity Protected Data packet is a variant of the Symmetrically Encrypted Data packet. It is a new feature created for OpenPGP that addresses the problem of detecting a modification to encrypted data. It is used in combination with a Modification Detection Code packet.",
      "ja": "対称的に暗号化された整合性保護データパケットは、対称的に暗号化されたデータパケットの変形です。これはOpenPGP用に作成された新しい機能であり、暗号化されたデータへの変更を検出する問題に対処します。変更検出コードパケットと組み合わせて使用​​されます。"
    },
    {
      "indent": 3,
      "text": "There is a corresponding feature in the features Signature subpacket that denotes that an implementation can properly use this packet type. An implementation MUST support decrypting these packets and SHOULD prefer generating them to the older Symmetrically Encrypted Data packet when possible. Since this data packet protects against modification attacks, this standard encourages its proliferation. While blanket adoption of this data packet would create interoperability problems, rapid adoption is nevertheless important. An implementation SHOULD specifically denote support for this packet, but it MAY infer it from other mechanisms.",
      "ja": "features署名サブパケットには、実装がこのパケットタイプを適切に使用できることを示す対応する機能があります。実装はこれらのパケットの復号化をサポートしなければならず（MUST）、可能な場合は古い対称暗号化データパケットにそれらを生成することを推奨する必要があります。このデータパケットは改ざん攻撃から保護するため、この標準はその拡散を促進します。このデータパケットを全面的に採用すると相互運用性の問題が発生しますが、迅速な採用は重要です。実装は、このパケットのサポートを具体的に示す必要があります（SHOULD）が、他のメカニズムからそれを推測する場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, an implementation might infer from the use of a cipher such as Advanced Encryption Standard (AES) or Twofish that a user supports this feature. It might place in the unhashed portion of another user's key signature a Features subpacket. It might also present a user with an opportunity to regenerate their own self-signature with a Features subpacket.",
      "ja": "たとえば、実装は、ユーザーがこの機能をサポートしていることをAdvanced Encryption Standard（AES）やTwofishな​​どの暗号の使用から推測する場合があります。別のユーザーの調号のハッシュ化されていない部分にFeaturesサブパケットを配置する可能性があります。また、Featuresサブパケットを使用して自分の自己署名を再生成する機会をユーザーに提示する場合もあります。"
    },
    {
      "indent": 3,
      "text": "This packet contains data encrypted with a symmetric-key algorithm and protected against modification by the SHA-1 hash algorithm. When it has been decrypted, it will typically contain other packets (often a Literal Data packet or Compressed Data packet). The last decrypted packet in this packet's payload MUST be a Modification Detection Code packet.",
      "ja": "このパケットには、対称鍵アルゴリズムで暗号化され、SHA-1ハッシュアルゴリズムによる変更から保護されたデータが含まれています。復号化されると、通常は他のパケット（多くの場合、リテラルデータパケットまたは圧縮データパケット）が含まれます。このパケットのペイロードの最後の復号化されたパケットは、変更検出コードパケットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number. The only currently defined value is 1.",
      "ja": "- 1オクテットのバージョン番号。現在定義されている唯一の値は1です。"
    },
    {
      "indent": 5,
      "text": "- Encrypted data, the output of the selected symmetric-key cipher operating in Cipher Feedback mode with shift amount equal to the block size of the cipher (CFB-n where n is the block size).",
      "ja": "- 暗号化されたデータ、シフト量が暗号のブロックサイズ（CFB-n、nはブロックサイズ）に等しい、暗号フィードバックモードで動作する選択された対称鍵暗号の出力。"
    },
    {
      "indent": 3,
      "text": "The symmetric cipher used MUST be specified in a Public-Key or Symmetric-Key Encrypted Session Key packet that precedes the Symmetrically Encrypted Data packet. In either case, the cipher algorithm octet is prefixed to the session key before it is encrypted.",
      "ja": "使用される対称暗号は、対称暗号化データパケットの前にある公開鍵または対称鍵暗号化セッションキーパケットで指定する必要があります。どちらの場合も、暗号化アルゴリズムのオクテットは、暗号化される前にセッションキーの前に付加されます。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in CFB mode, with a CFB shift size equal to the cipher's block size. The Initial Vector (IV) is specified as all zeros. Instead of using an IV, OpenPGP prefixes an octet string to the data before it is encrypted. The length of the octet string equals the block size of the cipher in octets, plus two. The first octets in the group, of length equal to the block size of the cipher, are random; the last two octets are each copies of their 2nd preceding octet. For example, with a cipher whose block size is 128 bits or 16 octets, the prefix data will contain 16 random octets, then two more octets, which are copies of the 15th and 16th octets, respectively. Unlike the Symmetrically Encrypted Data Packet, no special CFB resynchronization is done after encrypting this prefix data. See \"OpenPGP CFB Mode\" below for more details.",
      "ja": "データはCFBモードで暗号化され、CFBシフトサイズは暗号のブロックサイズと同じです。初期ベクトル（IV）はすべてゼロとして指定されます。 IVを使用する代わりに、OpenPGPは暗号化される前にデータにオクテット文字列をプレフィックスします。オクテット文字列の長さは、オクテット単位の暗号のブロックサイズに2を足したものに等しくなります。暗号のブロックサイズに等しい長さのグループの最初のオクテットはランダムです。最後の2つのオクテットは、2つ前のオクテットの各コピーです。たとえば、ブロックサイズが128ビットまたは16オクテットの暗号では、プレフィックスデータには16個のランダムオクテットが含まれ、さらに2つのオクテットが含まれます。これらはそれぞれ15番目と16番目のオクテットのコピーです。対称的に暗号化されたデータパケットとは異なり、このプレフィックスデータを暗号化した後、特別なCFB再同期は行われません。詳細については、以下の「OpenPGP CFBモード」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The repetition of 16 bits in the random data prefixed to the message allows the receiver to immediately check whether the session key is incorrect.",
      "ja": "メッセージの前に付けられたランダムデータの16ビットの繰り返しにより、受信者はセッションキーが正しくないかどうかをすぐに確認できます。"
    },
    {
      "indent": 3,
      "text": "The plaintext of the data to be encrypted is passed through the SHA-1 hash function, and the result of the hash is appended to the plaintext in a Modification Detection Code packet. The input to the hash function includes the prefix data described above; it includes all of the plaintext, and then also includes two octets of values 0xD3, 0x14. These represent the encoding of a Modification Detection Code packet tag and length field of 20 octets.",
      "ja": "暗号化されるデータの平文はSHA-1ハッシュ関数を介して渡され、ハッシュの結果は変更検出コードパケットの平文に追加されます。ハッシュ関数への入力には、上記のプレフィックスデータが含まれます。すべての平文が含まれ、次に2つのオクテットの値0xD3、0x14も含まれます。これらは、変更検出コードのパケットタグと20オクテットの長さフィールドのエンコーディングを表します。"
    },
    {
      "indent": 3,
      "text": "The resulting hash value is stored in a Modification Detection Code (MDC) packet, which MUST use the two octet encoding just given to represent its tag and length field. The body of the MDC packet is the 20-octet output of the SHA-1 hash.",
      "ja": "結果のハッシュ値は、変更検出コード（MDC）パケットに格納されます。MDCパケットは、タグと長さフィールドを表すために指定された2オクテットエンコーディングを使用する必要があります。 MDCパケットの本体は、SHA-1ハッシュの20オクテット出力です。"
    },
    {
      "indent": 3,
      "text": "The Modification Detection Code packet is appended to the plaintext and encrypted along with the plaintext using the same CFB context.",
      "ja": "変更検出コードパケットは平文に追加され、同じCFBコンテキストを使用して平文とともに暗号化されます。"
    },
    {
      "indent": 3,
      "text": "During decryption, the plaintext data should be hashed with SHA-1, including the prefix data as well as the packet tag and length field of the Modification Detection Code packet. The body of the MDC packet, upon decryption, is compared with the result of the SHA-1 hash.",
      "ja": "復号化中、プレフィックスデータ、変更検出コードパケットのパケットタグおよび長さフィールドを含む、プレーンテキストデータはSHA-1でハッシュする必要があります。 MDCパケットの本体は、復号化されると、SHA-1ハッシュの結果と比較されます。"
    },
    {
      "indent": 3,
      "text": "Any failure of the MDC indicates that the message has been modified and MUST be treated as a security problem. Failures include a difference in the hash values, but also the absence of an MDC packet, or an MDC packet in any position other than the end of the plaintext. Any failure SHOULD be reported to the user.",
      "ja": "MDCの障害は、メッセージが変更されていることを示しており、セキュリティの問題として扱われなければなりません（MUST）。失敗には、ハッシュ値の違いだけでなく、MDCパケットの欠如、またはプレーンテキストの末尾以外の任意の位置にMDCパケットが含まれます。失敗はユーザーに報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: future designs of new versions of this packet should consider rollback attacks since it will be possible for an attacker to change the version back to 1.",
      "ja": "注：このパケットの新しいバージョンの将来の設計では、攻撃者がバージョンを1に戻す可能性があるため、ロールバック攻撃を検討する必要があります。"
    },
    {
      "indent": 6,
      "text": "NON-NORMATIVE EXPLANATION",
      "ja": "非正規表現の説明"
    },
    {
      "indent": 6,
      "text": "The MDC system, as packets 18 and 19 are called, were created to provide an integrity mechanism that is less strong than a signature, yet stronger than bare CFB encryption.",
      "ja": "パケット18と19が呼び出されるMDCシステムは、署名よりも強力ではないが、CFB暗号化よりも強力な整合性メカニズムを提供するために作成されました。"
    },
    {
      "indent": 6,
      "text": "It is a limitation of CFB encryption that damage to the ciphertext will corrupt the affected cipher blocks and the block following. Additionally, if data is removed from the end of a CFB-encrypted block, that removal is undetectable. (Note also that CBC mode has a similar limitation, but data removed from the front of the block is undetectable.)",
      "ja": "CFB暗号化の制限により、暗号文に損傷を与えると、影響を受ける暗号ブロックとそれに続くブロックが破損します。さらに、CFB暗号化ブロックの最後からデータが削除された場合、その削除は検出されません。 （CBCモードにも同様の制限がありますが、ブロックの前面から削除されたデータは検出できません。）"
    },
    {
      "indent": 6,
      "text": "The obvious way to protect or authenticate an encrypted block is to digitally sign it. However, many people do not wish to habitually sign data, for a large number of reasons beyond the scope of this document. Suffice it to say that many people consider properties such as deniability to be as valuable as integrity.",
      "ja": "暗号化されたブロックを保護または認証する明白な方法は、デジタル署名することです。ただし、このドキュメントの範囲を超えた多くの理由により、多くの人々はデータに習慣的に署名することを望んでいません。多くの人々は、否認性などの特性は整合性と同じくらい価値があると考えていると言えば十分でしょう。"
    },
    {
      "indent": 6,
      "text": "OpenPGP addresses this desire to have more security than raw encryption and yet preserve deniability with the MDC system. An MDC is intentionally not a MAC. Its name was not selected by accident. It is analogous to a checksum.",
      "ja": "OpenPGPは、生の暗号化よりも高いセキュリティを確保しながら、MDCシステムでの拒否性を維持するというこの要望に対処します。 MDCは意図的にMACではありません。その名前は偶然に選ばれませんでした。これはチェックサムに似ています。"
    },
    {
      "indent": 6,
      "text": "Despite the fact that it is a relatively modest system, it has proved itself in the real world. It is an effective defense to several attacks that have surfaced since it has been created. It has met its modest goals admirably.",
      "ja": "それが比較的控えめなシステムであるという事実にもかかわらず、それは現実の世界でそれ自身を証明しました。これは、作成されてから表面化したいくつかの攻撃に対する効果的な防御策です。それは立派にそのささやかな目標を達成しました。"
    },
    {
      "indent": 6,
      "text": "Consequently, because it is a modest security system, it has modest requirements on the hash function(s) it employs. It does not rely on a hash function being collision-free, it relies on a hash function being one-way. If a forger, Frank, wishes to send Alice a (digitally) unsigned message that says, \"I've always secretly loved you, signed Bob\", it is far easier for him to construct a new message than it is to modify anything intercepted from Bob. (Note also that if Bob wishes to communicate secretly with Alice, but without authentication or identification and with a threat model that includes forgers, he has a problem that transcends mere cryptography.)",
      "ja": "したがって、これは控えめなセキュリティシステムであるため、使用するハッシュ関数には控えめな要件があります。衝突のないハッシュ関数に依存せず、一方向のハッシュ関数に依存します。偽造者のフランクが、「私はいつもあなたをこっそり愛していて、ボブに署名した」という（デジタルで）署名されていないメッセージをアリスに送信したい場合、傍受されたものを変更するよりも、新しいメッセージを作成する方がはるかに簡単です。ボブから。 （ボブがアリスと密かに通信したいが、認証も識別もなしで、偽造者を含む脅威モデルと通信したい場合、彼は単なる暗号を超越する問題を抱えていることに注意してください。）"
    },
    {
      "indent": 6,
      "text": "Note also that unlike nearly every other OpenPGP subsystem, there are no parameters in the MDC system. It hard-defines SHA-1 as its hash function. This is not an accident. It is an intentional choice to avoid downgrade and cross-grade attacks while making a simple, fast system. (A downgrade attack would be an attack that replaced SHA-256 with SHA-1, for example. A cross-grade attack would replace SHA-1 with another 160-bit hash, such as RIPE-MD/160, for example.)",
      "ja": "他のほぼすべてのOpenPGPサブシステムとは異なり、MDCシステムにはパラメーターがないことにも注意してください。 SHA-1をハッシュ関数としてハード定義します。これは偶然ではありません。これは、シンプルで高速なシステムを作成しながら、ダウングレードやクロスグレードの攻撃を回避するための意図的な選択です。 （ダウングレード攻撃は、たとえばSHA-256をSHA-1に置き換えた攻撃です。クロスグレード攻撃は、SHA-1を別の160ビットハッシュ（RIPE-MD / 160など）に置き換えます。）"
    },
    {
      "indent": 6,
      "text": "However, given the present state of hash function cryptanalysis and cryptography, it may be desirable to upgrade the MDC system to a new hash function. See Section 13.11 in the \"IANA Considerations\" for guidance.",
      "ja": "ただし、ハッシュ関数の解読と暗号化の現状を考えると、MDCシステムを新しいハッシュ関数にアップグレードすることが望ましい場合があります。ガイダンスについては、「IANAの考慮事項」のセクション13.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.14. Modification Detection Code Packet (Tag 19)",
      "section_title": true,
      "ja": "5.14. 変更検出コードパケット（タグ19）"
    },
    {
      "indent": 3,
      "text": "The Modification Detection Code packet contains a SHA-1 hash of plaintext data, which is used to detect message modification. It is only used with a Symmetrically Encrypted Integrity Protected Data packet. The Modification Detection Code packet MUST be the last packet in the plaintext data that is encrypted in the Symmetrically Encrypted Integrity Protected Data packet, and MUST appear in no other place.",
      "ja": "変更検出コードパケットには、プレーンテキストデータのSHA-1ハッシュが含まれており、メッセージの変更を検出するために使用されます。対称的に暗号化された整合性保護データパケットでのみ使用されます。変更検出コードパケットは、対称的に暗号化された整合性保護データパケットで暗号化された平文データの最後のパケットでなければならず、他の場所に出現してはなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "A Modification Detection Code packet MUST have a length of 20 octets.",
      "ja": "変更検出コードパケットの長さは20オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットの本体は、次のもので構成されています。"
    },
    {
      "indent": 5,
      "text": "- A 20-octet SHA-1 hash of the preceding plaintext data of the Symmetrically Encrypted Integrity Protected Data packet, including prefix data, the tag octet, and length octet of the Modification Detection Code packet.",
      "ja": "- プレフィックスデータ、タグオクテット、モディフィケーション検出コードパケットの長さオクテットを含む、対称的に暗号化された整合性保護データパケットの先行する平文データの20オクテットSHA-1ハッシュ。"
    },
    {
      "indent": 3,
      "text": "Note that the Modification Detection Code packet MUST always use a new format encoding of the packet tag, and a one-octet encoding of the packet length. The reason for this is that the hashing rules for modification detection include a one-octet tag and one-octet length in the data hash. While this is a bit restrictive, it reduces complexity.",
      "ja": "変更検出コードパケットは、常にパケットタグの新しい形式のエンコーディングとパケット長の1オクテットエンコーディングを使用する必要があることに注意してください。これは、変更検出のハッシュルールには、データハッシュに1オクテットのタグと1オクテットの長さが含まれているためです。これは少し制限的ですが、複雑さを軽減します。"
    },
    {
      "indent": 0,
      "text": "6. Radix-64 Conversions",
      "section_title": true,
      "ja": "6. Radix-64変換"
    },
    {
      "indent": 3,
      "text": "As stated in the introduction, OpenPGP's underlying native representation for objects is a stream of arbitrary octets, and some systems desire these objects to be immune to damage caused by character set translation, data conversions, etc.",
      "ja": "冒頭で述べたように、OpenPGPのオブジェクトのネイティブ表現は、任意のオクテットのストリームであり、一部のシステムでは、これらのオブジェクトが文字セット変換、データ変換などによって引き起こされる損傷の影響を受けないようにしています。"
    },
    {
      "indent": 3,
      "text": "In principle, any printable encoding scheme that met the requirements of the unsafe channel would suffice, since it would not change the underlying binary bit streams of the native OpenPGP data structures. The OpenPGP standard specifies one such printable encoding scheme to ensure interoperability.",
      "ja": "原則として、ネイティブのOpenPGPデータ構造の基礎となるバイナリビットストリームを変更しないため、安全でないチャネルの要件を満たす印刷可能なエンコーディングスキームで十分です。 OpenPGP標準は、相互運用性を保証するために、そのような印刷可能なエンコード方式の1つを指定しています。"
    },
    {
      "indent": 3,
      "text": "OpenPGP's Radix-64 encoding is composed of two parts: a base64 encoding of the binary data and a checksum. The base64 encoding is identical to the MIME base64 content-transfer-encoding [RFC2045].",
      "ja": "OpenPGPのRadix-64エンコーディングは、バイナリデータのbase64エンコーディングとチェックサムの2つの部分で構成されています。 base64エンコーディングは、MIME base64 content-transfer-encoding [RFC2045]と同じです。"
    },
    {
      "indent": 3,
      "text": "The checksum is a 24-bit Cyclic Redundancy Check (CRC) converted to four characters of radix-64 encoding by the same MIME base64 transformation, preceded by an equal sign (=). The CRC is computed by using the generator 0x864CFB and an initialization of 0xB704CE. The accumulation is done on the data before it is converted to radix-64, rather than on the converted data. A sample implementation of this algorithm is in the next section.",
      "ja": "チェックサムは、24ビットの巡回冗長検査（CRC）であり、同じMIME base64変換によってradix-64エンコードの4文字に変換され、前に等号（=）が付けられます。 CRCは、ジェネレータ0x864CFBおよび0xB704CEの初期化を使用して計算されます。累算は、変換されたデータではなく、基数64に変換される前のデータに対して行われます。このアルゴリズムの実装例は次のセクションにあります。"
    },
    {
      "indent": 3,
      "text": "The checksum with its leading equal sign MAY appear on the first line after the base64 encoded data.",
      "ja": "先頭の等号が付いたチェックサムは、base64でエンコードされたデータの後の最初の行に表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "Rationale for CRC-24: The size of 24 bits fits evenly into printable base64. The nonzero initialization can detect more errors than a zero initialization.",
      "ja": "CRC-24の根拠：24ビットのサイズは、印刷可能なbase64に均等に適合します。ゼロ以外の初期化では、ゼロの初期化よりも多くのエラーを検出できます。"
    },
    {
      "indent": 0,
      "text": "6.1. An Implementation of the CRC-24 in \"C\"",
      "section_title": true,
      "ja": "6.1. \"C\"でのCRC-24の実装"
    },
    {
      "indent": 6,
      "text": "#define CRC24_INIT 0xB704CEL #define CRC24_POLY 0x1864CFBL",
      "ja": "#define CRC24_INIT 0xB704CEL #define CRC24_POLY 0x1864CFBL"
    },
    {
      "indent": 6,
      "text": "typedef long crc24;\ncrc24 crc_octets(unsigned char *octets, size_t len)\n{\n    crc24 crc = CRC24_INIT;\n    int i;\n    while (len--) {\n        crc ^= (*octets++) << 16;\n        for (i = 0; i < 8; i++) {\n            crc <<= 1;\n            if (crc & 0x1000000)\n                crc ^= CRC24_POLY;\n        }\n    }\n    return crc & 0xFFFFFFL;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. Forming ASCII Armor",
      "section_title": true,
      "ja": "6.2. ASCIIアーマーの形成"
    },
    {
      "indent": 3,
      "text": "When OpenPGP encodes data into ASCII Armor, it puts specific headers around the Radix-64 encoded data, so OpenPGP can reconstruct the data later. An OpenPGP implementation MAY use ASCII armor to protect raw binary data. OpenPGP informs the user what kind of data is encoded in the ASCII armor through the use of the headers.",
      "ja": "OpenPGPがデータをASCIIアーマーにエンコードすると、Radix-64エンコードデータの周囲に特定のヘッダーが配置されるため、OpenPGPは後でデータを再構築できます。 OpenPGP実装は、ASCII鎧を使用して生のバイナリデータを保護してもよい（MAY）。 OpenPGPは、ヘッダーを使用して、ASCIIアーマーでエンコードされているデータの種類をユーザーに通知します。"
    },
    {
      "indent": 3,
      "text": "Concatenating the following data creates ASCII Armor:",
      "ja": "次のデータを連結すると、ASCIIアーマーが作成されます。"
    },
    {
      "indent": 5,
      "text": "- An Armor Header Line, appropriate for the type of data",
      "ja": "- データのタイプに適した鎧ヘッダー行"
    },
    {
      "indent": 5,
      "text": "- Armor Headers",
      "ja": "- アーマーヘッダー"
    },
    {
      "indent": 5,
      "text": "- A blank (zero-length, or containing only whitespace) line",
      "ja": "- 空白（長さがゼロ、または空白のみを含む）行"
    },
    {
      "indent": 5,
      "text": "- The ASCII-Armored data",
      "ja": "- ASCII装甲データ"
    },
    {
      "indent": 5,
      "text": "- An Armor Checksum",
      "ja": "- 鎧チェックサム"
    },
    {
      "indent": 5,
      "text": "- The Armor Tail, which depends on the Armor Header Line",
      "ja": "- アーマーテール、アーマーヘッダーラインに依存"
    },
    {
      "indent": 0,
      "text": " An Armor Header Line consists of the appropriate header line text surrounded by five (5) dashes ('-', 0x2D) on either side of the header line text. The header line text is chosen based upon the type of data that is being encoded in Armor, and how it is being encoded. Header line texts include the following strings: BEGIN PGP MESSAGE Used for signed, encrypted, or compressed files.",
      "ja": "アーマーヘッダーラインは、ヘッダーラインテキストの両側にある5つのダッシュ（ '-'、0x2D）で囲まれた適切なヘッダーラインテキストで構成されます。ヘッダー行のテキストは、Armorでエンコードされるデータのタイプと、そのエンコード方法に基づいて選択されます。ヘッダー行のテキストには、次の文字列が含まれます。BEGIN PGP MESSAGE署名、暗号化、または圧縮されたファイルに使用されます。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP PUBLIC KEY BLOCK Used for armoring public keys.",
      "ja": "BEGIN PGP PUBLIC KEY BLOCK公開鍵の防御に使用されます。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP PRIVATE KEY BLOCK Used for armoring private keys.",
      "ja": "BEGIN PGP PRIVATE KEY BLOCK秘密鍵の保護に使用されます。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP MESSAGE, PART X/Y Used for multi-part messages, where the armor is split amongst Y parts, and this is the Xth part out of Y.",
      "ja": "BEGIN PGP MESSAGE、PART X / Yマルチパートメッセージに使用されます。鎧はYパーツ間で分割され、これはYからX番目のパーツです。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP MESSAGE, PART X Used for multi-part messages, where this is the Xth part of an unspecified number of parts. Requires the MESSAGE-ID Armor Header to be used.",
      "ja": "BEGIN PGP MESSAGE、PART Xマルチパートメッセージに使用されます。これは、指定されていない数のパートのX番目のパートです。 MESSAGE-IDアーマーヘッダーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP SIGNATURE Used for detached signatures, OpenPGP/MIME signatures, and cleartext signatures. Note that PGP 2.x uses BEGIN PGP MESSAGE for detached signatures.",
      "ja": "BEGIN PGP SIGNATURE分離署名、OpenPGP / MIME署名、およびクリアテキスト署名に使用されます。 PGP 2.xは切り離された署名にBEGIN PGP MESSAGEを使用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that all these Armor Header Lines are to consist of a complete line. That is to say, there is always a line ending preceding the starting five dashes, and following the ending five dashes. The header lines, therefore, MUST start at the beginning of a line, and MUST NOT have text other than whitespace following them on the same line. These line endings are considered a part of the Armor Header Line for the purposes of determining the content they delimit. This is particularly important when computing a cleartext signature (see below).",
      "ja": "これらのすべての鎧ヘッダー行は、完全な行で構成されることに注意してください。つまり、最初の5つのダッシュの前で終了し、最後の5つのダッシュの後に続く行が常に存在します。したがって、ヘッダー行は行の先頭から開始する必要があり、同じ行でそれらの後に続く空白以外のテキストを含めることはできません。これらの行末は、それらが区切るコンテンツを決定する目的で、鎧ヘッダー行の一部と見なされます。これは、クリアテキスト署名を計算するときに特に重要です（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "The Armor Headers are pairs of strings that can give the user or the receiving OpenPGP implementation some information about how to decode or use the message. The Armor Headers are a part of the armor, not a part of the message, and hence are not protected by any signatures applied to the message.",
      "ja": "アーマーヘッダーは、ユーザーまたは受信OpenPGP実装にメッセージのデコードまたは使用方法に関する情報を提供できる文字列のペアです。アーマーヘッダーはアーマーの一部であり、メッセージの一部ではないため、メッセージに適用された署名によって保護されません。"
    },
    {
      "indent": 3,
      "text": "The format of an Armor Header is that of a key-value pair. A colon (':' 0x38) and a single space (0x20) separate the key and value. OpenPGP should consider improperly formatted Armor Headers to be corruption of the ASCII Armor. Unknown keys should be reported to the user, but OpenPGP should continue to process the message.",
      "ja": "アーマーヘッダーの形式は、キーと値のペアの形式です。コロン（ '：' 0x38）と単一のスペース（0x20）は、キーと値を区切ります。 OpenPGPは、不適切にフォーマットされたアーマーヘッダーをASCIIアーマーの破損と見なす必要があります。不明なキーはユーザーに報告されますが、OpenPGPはメッセージの処理を続行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that some transport methods are sensitive to line length. While there is a limit of 76 characters for the Radix-64 data (Section 6.3), there is no limit to the length of Armor Headers. Care should",
      "ja": "一部の転送方法は行の長さに影響されることに注意してください。 Radix-64データ（セクション6.3）には76文字の制限がありますが、鎧ヘッダーの長さに制限はありません。ケアすべき"
    },
    {
      "indent": 3,
      "text": "be taken that the Armor Headers are short enough to survive transport. One way to do this is to repeat an Armor Header key multiple times with different values for each so that no one line is overly long.",
      "ja": "装甲ヘッダーは輸送に耐えるのに十分短いと見なされます。これを行う1つの方法は、1行が過度に長くならないように、それぞれに異なる値を使用して鎧ヘッダーキーを複数回繰り返すことです。"
    },
    {
      "indent": 3,
      "text": "Currently defined Armor Header Keys are as follows:",
      "ja": "現在定義されているアーマーヘッダーキーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- \"Version\", which states the OpenPGP implementation and version used to encode the message.",
      "ja": "- 「バージョン」は、OpenPGP実装とメッセージのエンコードに使用されたバージョンを示します。"
    },
    {
      "indent": 5,
      "text": "- \"Comment\", a user-defined comment. OpenPGP defines all text to be in UTF-8. A comment may be any UTF-8 string. However, the whole point of armoring is to provide seven-bit-clean data. Consequently, if a comment has characters that are outside the US-ASCII range of UTF, they may very well not survive transport.",
      "ja": "- 「コメント」、ユーザー定義のコメント。 OpenPGPはすべてのテキストをUTF-8で定義します。コメントは任意のUTF-8文字列にすることができます。ただし、防御の要点は7ビットのクリーンなデータを提供することです。その結果、コメントにUTFのUS-ASCII範囲外の文字が含まれている場合、それらの文字はトランスポートを通過できない可能性があります。"
    },
    {
      "indent": 5,
      "text": "- \"MessageID\", a 32-character string of printable characters. The string must be the same for all parts of a multi-part message that uses the \"PART X\" Armor Header. MessageID strings should be unique enough that the recipient of the mail can associate all the parts of a message with each other. A good checksum or cryptographic hash function is sufficient.",
      "ja": "- 「MessageID」、32文字の印刷可能な文字列。文字列は、 \"PART X\"アーマーヘッダーを使用するマルチパートメッセージのすべてのパートで同じである必要があります。 MessageID文字列は、メールの受信者がメッセージのすべての部分を互いに関連付けることができるように十分に一意である必要があります。適切なチェックサムまたは暗号化ハッシュ関数で十分です。"
    },
    {
      "indent": 7,
      "text": "The MessageID SHOULD NOT appear unless it is in a multi-part message. If it appears at all, it MUST be computed from the finished (encrypted, signed, etc.) message in a deterministic fashion, rather than contain a purely random value. This is to allow the legitimate recipient to determine that the MessageID cannot serve as a covert means of leaking cryptographic key information.",
      "ja": "MessageIDは、マルチパートメッセージ内にある場合を除き、表示しないでください。まったく表示される場合は、完全にランダムな値を含めるのではなく、完成した（暗号化、署名などの）メッセージから決定論的な方法で計算する必要があります。これは、正当な受信者がMessageIDが暗号化キー情報を漏洩する潜在的な手段として機能できないことを確認できるようにするためです。"
    },
    {
      "indent": 5,
      "text": "- \"Hash\", a comma-separated list of hash algorithms used in this message. This is used only in cleartext signed messages.",
      "ja": "- 「ハッシュ」は、このメッセージで使用されるハッシュアルゴリズムのカンマ区切りのリストです。これは、クリアテキストで署名されたメッセージでのみ使用されます。"
    },
    {
      "indent": 5,
      "text": "- \"Charset\", a description of the character set that the plaintext is in. Please note that OpenPGP defines text to be in UTF-8. An implementation will get best results by translating into and out of UTF-8. However, there are many instances where this is easier said than done. Also, there are communities of users who have no need for UTF-8 because they are all happy with a character set like ISO Latin-5 or a Japanese character set. In such instances, an implementation MAY override the UTF-8 default by using this header key. An implementation MAY implement this key and any translations it cares to; an implementation MAY ignore it and assume all text is UTF-8.",
      "ja": "- 「Charset」は、プレーンテキストが含まれる文字セットの説明です。OpenPGPはテキストをUTF-8で定義することに注意してください。実装では、UTF-8への変換とUTF-8からの変換によって最良の結果が得られます。ただし、これを行うのが言うよりも簡単な場合が多くあります。また、ISO Latin-5のような文字セットや日本語の文字セットに満足しているため、UTF-8を必要としないユーザーのコミュニティもあります。このような場合、実装はこのヘッダーキーを使用してUTF-8のデフォルトをオーバーライドできます（MAY）。実装はこのキーとそれが気にする翻訳を実装してもよい（MAY）。実装はそれを無視して、すべてのテキストがUTF-8であると想定してもよい（MAY）。"
    },
    {
      "indent": 7,
      "text": "The Armor Tail Line is composed in the same manner as the Armor Header Line, except the string \"BEGIN\" is replaced by the string \"END\".",
      "ja": "アーマーテールラインは、アーマーヘッダーラインと同じように構成されていますが、文字列「BEGIN」が文字列「END」に置き換えられています。"
    },
    {
      "indent": 0,
      "text": "6.3. Encoding Binary in Radix-64",
      "section_title": true,
      "ja": "6.3. Radix-64でのバイナリのエンコード"
    },
    {
      "indent": 3,
      "text": "The encoding process represents 24-bit groups of input bits as output strings of 4 encoded characters. Proceeding from left to right, a 24-bit input group is formed by concatenating three 8-bit input groups. These 24 bits are then treated as four concatenated 6-bit groups, each of which is translated into a single digit in the Radix-64 alphabet. When encoding a bit stream with the Radix-64 encoding, the bit stream must be presumed to be ordered with the most significant bit first. That is, the first bit in the stream will be the high-order bit in the first 8-bit octet, and the eighth bit will be the low-order bit in the first 8-bit octet, and so on.",
      "ja": "エンコードプロセスは、24ビットの入力ビットのグループを4つのエンコードされた文字の出力文字列として表します。左から右へと進み、24ビット入力グループは、3つの8ビット入力グループを連結することによって形成されます。これらの24ビットは、4つの連結された6ビットグループとして扱われ、それぞれがRadix-64アルファベットの1桁に変換されます。 Radix-64エンコーディングを使用してビットストリームをエンコードする場合、ビットストリームは、最上位ビットが最初に配列されると想定する必要があります。つまり、ストリームの最初のビットは最初の8ビットオクテットの上位ビットになり、8番目のビットは最初の8ビットオクテットの下位ビットになります。"
    },
    {
      "indent": 9,
      "text": "+--first octet--+-second octet--+--third octet--+\n|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n+-----------+---+-------+-------+---+-----------+\n|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n+--1.index--+--2.index--+--3.index--+--4.index--+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each 6-bit group is used as an index into an array of 64 printable characters from the table below. The character referenced by the index is placed in the output string.",
      "ja": "各6ビットグループは、以下の表の64の印刷可能な文字の配列へのインデックスとして使用されます。インデックスによって参照される文字は、出力文字列に配置されます。"
    },
    {
      "indent": 5,
      "text": "Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y",
      "ja": "Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63/13 N 30 e 47 v 14 O 31 f 48 w（パッド）= 15 P 32 g 49 x 16 Q 33 h 50 y"
    },
    {
      "indent": 3,
      "text": "The encoded output stream must be represented in lines of no more than 76 characters each.",
      "ja": "エンコードされた出力ストリームは、76文字以下の行で表す必要があります。"
    },
    {
      "indent": 3,
      "text": "Special processing is performed if fewer than 24 bits are available at the end of the data being encoded. There are three possibilities:",
      "ja": "エンコードされるデータの最後に24ビット未満しか利用できない場合は、特別な処理が実行されます。 3つの可能性があります。"
    },
    {
      "indent": 3,
      "text": "1. The last data group has 24 bits (3 octets). No special processing is needed.",
      "ja": "1. 最後のデータグループは24ビット（3オクテット）です。特別な処理は必要ありません。"
    },
    {
      "indent": 3,
      "text": "2. The last data group has 16 bits (2 octets). The first two 6-bit groups are processed as above. The third (incomplete) data group has two zero-value bits added to it, and is processed as above. A pad character (=) is added to the output.",
      "ja": "2. 最後のデータグループは16ビット（2オクテット）です。最初の2つの6ビットグループは上記のように処理されます。 3番目の（不完全な）データグループには2つのゼロ値ビットが追加されており、上記のように処理されます。パッド文字（=）が出力に追加されます。"
    },
    {
      "indent": 3,
      "text": "3. The last data group has 8 bits (1 octet). The first 6-bit group is processed as above. The second (incomplete) data group has four zero-value bits added to it, and is processed as above. Two pad characters (=) are added to the output.",
      "ja": "3. 最後のデータグループは8ビット（1オクテット）です。最初の6ビットグループは上記のように処理されます。 2番目の（不完全な）データグループには、4つのゼロ値ビットが追加され、上記のように処理されます。 2つの埋め込み文字（=）が出力に追加されます。"
    },
    {
      "indent": 0,
      "text": "6.4. Decoding Radix-64",
      "section_title": true,
      "ja": "6.4. Radix-64のデコード"
    },
    {
      "indent": 3,
      "text": "In Radix-64 data, characters other than those in the table, line breaks, and other white space probably indicate a transmission error, about which a warning message or even a message rejection might be appropriate under some circumstances. Decoding software must ignore all white space.",
      "ja": "Radix-64データでは、表、改行、およびその他の空白以外の文字はおそらく送信エラーを示しており、状況によっては警告メッセージまたはメッセージ拒否さえも適切である可能性があります。デコードソフトウェアはすべての空白を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because it is used only for padding at the end of the data, the occurrence of any \"=\" characters may be taken as evidence that the end of the data has been reached (without truncation in transit). No such assurance is possible, however, when the number of octets transmitted was a multiple of three and no \"=\" characters are present.",
      "ja": "データの終わりにパディングするためだけに使用されるため、「=」文字の発生は、データの終わりに達したことの証拠と見なされる場合があります（途中で切り捨てられることはありません）。ただし、送信されたオクテットの数が3の倍数であり、「=」文字が存在しない場合、そのような保証は不可能です。"
    },
    {
      "indent": 0,
      "text": "6.5. Examples of Radix-64",
      "section_title": true,
      "ja": "6.5. Radix-64の例"
    },
    {
      "indent": 3,
      "text": "Input data:  0x14FB9C03D97E\nHex:     1   4    F   B    9   C     | 0   3    D   9    7   E\n8-bit:   00010100 11111011 10011100  | 00000011 11011001 11111110\n6-bit:   000101 001111 101110 011100 | 000000 111101 100111 111110\nDecimal: 5      15     46     28       0      61     37     62\nOutput:  F      P      u      c        A      9      l      +\nInput data:  0x14FB9C03D9\nHex:     1   4    F   B    9   C     | 0   3    D   9\n8-bit:   00010100 11111011 10011100  | 00000011 11011001\n                                                pad with 00\n6-bit:   000101 001111 101110 011100 | 000000 111101 100100\nDecimal: 5      15     46     28       0      61     36\n                                                   pad with =\nOutput:  F      P      u      c        A      9      k      =\nInput data:  0x14FB9C03\nHex:     1   4    F   B    9   C     | 0   3\n8-bit:   00010100 11111011 10011100  | 00000011\n                                       pad with 0000\n6-bit:   000101 001111 101110 011100 | 000000 110000\nDecimal: 5      15     46     28       0      48\n                                            pad with =      =\nOutput:  F      P      u      c        A      w      =      =",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.6. Example of an ASCII Armored Message",
      "section_title": true,
      "ja": "6.6. ASCII装甲メッセージの例"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PGP MESSAGE-----\nVersion: OpenPrivacy 0.99",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS\nvBSFjNSiVHsuAA==\n=njUN\n-----END PGP MESSAGE-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this example has extra indenting; an actual armored message would have no leading whitespace.",
      "ja": "この例には追加のインデントがあることに注意してください。実際の装甲メッセージには、先頭に空白はありません。"
    },
    {
      "indent": 0,
      "text": "7. Cleartext Signature Framework",
      "section_title": true,
      "ja": "7. クリアテキスト署名フレームワーク"
    },
    {
      "indent": 0,
      "text": " It is desirable to be able to sign a textual octet stream without ASCII armoring the stream itself, so the signed text is still readable without special software. In order to bind a signature to such a cleartext, this framework is used. (Note that this framework is not intended to be reversible. RFC 3156 [RFC3156] defines another way to sign cleartext messages for environments that support MIME.) The cleartext signed message consists of:",
      "ja": "ASCIIストリーム自体を改造することなくテキストのオクテットストリームに署名できることが望ましいので、特別なソフトウェアがなくても署名されたテキストを読み取ることができます。署名をこのようなクリアテキストにバインドするために、このフレームワークが使用されます。 （このフレームワークは可逆的であることが意図されていないことに注意してください。RFC3156 [RFC3156]は、MIMEをサポートする環境のクリアテキストメッセージに署名する別の方法を定義します。）"
    },
    {
      "indent": 5,
      "text": "- The cleartext header '-----BEGIN PGP SIGNED MESSAGE-----' on a single line,",
      "ja": "- クリアテキストヘッダー '----- BEGIN PGP SIGNED MESSAGE -----'（1行）"
    },
    {
      "indent": 5,
      "text": "- One or more \"Hash\" Armor Headers,",
      "ja": "- 1つ以上の「ハッシュ」アーマーヘッダー、"
    },
    {
      "indent": 5,
      "text": "- Exactly one empty line not included into the message digest,",
      "ja": "- メッセージダイジェストに含まれていない1行の空行"
    },
    {
      "indent": 5,
      "text": "- The dash-escaped cleartext that is included into the message digest,",
      "ja": "- メッセージダイジェストに含まれるダッシュエスケープされたクリアテキスト、"
    },
    {
      "indent": 5,
      "text": "- The ASCII armored signature(s) including the '-----BEGIN PGP SIGNATURE-----' Armor Header and Armor Tail Lines.",
      "ja": "- '----- BEGIN PGP SIGNATURE -----'アーマーヘッダーおよびアーマーテールラインを含むASCII装甲署名。"
    },
    {
      "indent": 3,
      "text": "If the \"Hash\" Armor Header is given, the specified message digest algorithm(s) are used for the signature. If there are no such headers, MD5 is used. If MD5 is the only hash used, then an implementation MAY omit this header for improved V2.x compatibility. If more than one message digest is used in the signature, the \"Hash\" armor header contains a comma-delimited list of used message digests.",
      "ja": "「ハッシュ」アーマーヘッダーが指定されている場合、指定されたメッセージダイジェストアルゴリズムが署名に使用されます。そのようなヘッダーがない場合は、MD5が使用されます。 MD5が使用される唯一のハッシュである場合、実装はV2.x互換性を向上させるためにこのヘッダーを省略してもよい（MAY）。署名で複数のメッセージダイジェストが使用されている場合、「ハッシュ」アーマーヘッダーには、使用されたメッセージダイジェストのカンマ区切りのリストが含まれます。"
    },
    {
      "indent": 3,
      "text": "Current message digest names are described below with the algorithm IDs.",
      "ja": "現在のメッセージダイジェスト名は、アルゴリズムIDとともに以下で説明されています。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD add a line break after the cleartext, but MAY omit it if the cleartext ends with a line break. This is for visual clarity.",
      "ja": "実装は、クリアテキストの後に改行を追加する必要があります（SHOULD）が、クリアテキストが改行で終わる場合は省略できます（MAY）。これは視覚的にわかりやすくするためです。"
    },
    {
      "indent": 0,
      "text": "7.1. Dash-Escaped Text",
      "section_title": true,
      "ja": "7.1. ダッシュエスケープテキスト"
    },
    {
      "indent": 3,
      "text": "The cleartext content of the message must also be dash-escaped.",
      "ja": "メッセージのクリアテキストコンテンツもダッシュエスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "Dash-escaped cleartext is the ordinary cleartext where every line starting with a dash '-' (0x2D) is prefixed by the sequence dash '-' (0x2D) and space ' ' (0x20). This prevents the parser from recognizing armor headers of the cleartext itself. An implementation MAY dash-escape any line, SHOULD dash-escape lines commencing \"From\" followed by a space, and MUST dash-escape any line commencing in a dash. The message digest is computed using the cleartext itself, not the dash-escaped form.",
      "ja": "ダッシュエスケープクリアテキストは、ダッシュ「-」（0x2D）で始まるすべての行の前にシーケンスダッシュ「-」（0x2D）とスペース ''（0x20）が前置された通常のクリアテキストです。これにより、パーサーがクリアテキスト自体のアーマーヘッダーを認識できなくなります。実装は、任意の行をダッシュ​​エスケープすることができ、「From」の後にスペースが続くダッシュエスケープ行をSHOULDにし、ダッシュで始まる行をダッシュ​​エスケープする必要があります。メッセージダイジェストは、ダッシュエスケープ形式ではなく、クリアテキスト自体を使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "As with binary signatures on text documents, a cleartext signature is\ncalculated on the text using canonical <CR><LF> line endings.  The\nline ending (i.e., the <CR><LF>) before the '-----BEGIN PGP\nSIGNATURE-----' line that terminates the signed text is not\nconsidered part of the signed text.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When reversing dash-escaping, an implementation MUST strip the string \"- \" if it occurs at the beginning of a line, and SHOULD warn on \"-\" and any character other than a space at the beginning of a line.",
      "ja": "ダッシュエスケープを元に戻す場合、実装は文字列「-」を行頭にある場合は削除する必要があり、「-」および行頭のスペース以外の文字について警告する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Also, any trailing whitespace -- spaces (0x20) and tabs (0x09) -- at the end of any line is removed when the cleartext signature is generated.",
      "ja": "また、クリアテキスト署名が生成されると、行末の空白（スペース（0x20）およびタブ（0x09））が削除されます。"
    },
    {
      "indent": 0,
      "text": "8. Regular Expressions",
      "section_title": true,
      "ja": "8. 正規表現"
    },
    {
      "indent": 3,
      "text": "A regular expression is zero or more branches, separated by '|'. It matches anything that matches one of the branches.",
      "ja": "正規表現は、 '|'で区切られた0個以上のブランチです。これは、ブランチの1つに一致するすべてのものに一致します。"
    },
    {
      "indent": 3,
      "text": "A branch is zero or more pieces, concatenated. It matches a match for the first, followed by a match for the second, etc.",
      "ja": "ブランチは連結された0個以上のピースです。最初の一致に一致し、2番目の一致が続く、など。"
    },
    {
      "indent": 3,
      "text": "A piece is an atom possibly followed by '*', '+', or '?'. An atom followed by '*' matches a sequence of 0 or more matches of the atom. An atom followed by '+' matches a sequence of 1 or more matches of the atom. An atom followed by '?' matches a match of the atom, or the null string.",
      "ja": "ピースは、「*」、「+」、または「？」が後に続く可能性のあるアトムです。 「*」が後に続くアトムは、アトムの0個以上の一致のシーケンスと一致します。 「+」が後に続くアトムは、アトムの1つ以上の一致のシーケンスと一致します。アトムの後に「？」アトムの一致、またはnull文字列に一致します。"
    },
    {
      "indent": 3,
      "text": "An atom is a regular expression in parentheses (matching a match for the regular expression), a range (see below), '.' (matching any single character), '^' (matching the null string at the beginning of the input string), '$' (matching the null string at the end of the input string), a '\\' followed by a single character (matching that character), or a single character with no other significance (matching that character).",
      "ja": "アトムは、括弧内の正規表現（正規表現の一致に一致）、範囲（下記を参照）、「。」 （任意の1文字に一致）、 '^'（入力文字列の先頭にあるnull文字列に一致）、 '$'（入力文字列の末尾にあるnull文字列に一致）、 '\\'の後に1文字が続く（その文字に一致する）、または他の重要性のない単一の文字（その文字に一致する）。"
    },
    {
      "indent": 3,
      "text": "A range is a sequence of characters enclosed in '[]'. It normally matches any single character from the sequence. If the sequence begins with '^', it matches any single character not from the rest of the sequence. If two characters in the sequence are separated by '-', this is shorthand for the full list of ASCII characters between them (e.g., '[0-9]' matches any decimal digit). To include a literal ']' in the sequence, make it the first character (following a possible '^'). To include a literal '-', make it the first or last character.",
      "ja": "範囲は、[]で囲まれた文字のシーケンスです。通常、シーケンスの任意の1文字と一致します。シーケンスが「^」で始まる場合は、シーケンスの残りの文字以外の任意の1文字と一致します。シーケンス内の2つの文字が「-」で区切られている場合、これはそれらの間のASCII文字の完全なリストの省略形です（たとえば、「[0-9]」は任意の10進数と一致します）。シーケンスにリテラル ']'を含めるには、それを最初の文字にします（可能な '^'の後）。リテラル「-」を含めるには、最初または最後の文字にします。"
    },
    {
      "indent": 0,
      "text": "9. Constants",
      "section_title": true,
      "ja": "9. 定数"
    },
    {
      "indent": 3,
      "text": "This section describes the constants used in OpenPGP.",
      "ja": "このセクションでは、OpenPGPで使用される定数について説明します。"
    },
    {
      "indent": 3,
      "text": "Note that these tables are not exhaustive lists; an implementation MAY implement an algorithm not on these lists, so long as the algorithm numbers are chosen from the private or experimental algorithm range.",
      "ja": "これらの表は完全なリストではないことに注意してください。実装は、アルゴリズム番号がプライベートまたは実験的アルゴリズムの範囲から選択される限り、これらのリストにないアルゴリズムを実装してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "See the section \"Notes on Algorithms\" below for more discussion of the algorithms.",
      "ja": "アルゴリズムの詳細については、以下の「アルゴリズムに関する注意事項」のセクションを参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. Public-Key Algorithms",
      "section_title": true,
      "ja": "9.1. 公開鍵アルゴリズム"
    },
    {
      "indent": 6,
      "text": "ID           Algorithm\n--           ---------\n1          - RSA (Encrypt or Sign) [HAC]\n2          - RSA Encrypt-Only [HAC]\n3          - RSA Sign-Only [HAC]\n16         - Elgamal (Encrypt-Only) [ELGAMAL] [HAC]\n17         - DSA (Digital Signature Algorithm) [FIPS186] [HAC]\n18         - Reserved for Elliptic Curve\n19         - Reserved for ECDSA\n20         - Reserved (formerly Elgamal Encrypt or Sign)\n21         - Reserved for Diffie-Hellman (X9.42,\n             as defined for IETF-S/MIME)\n100 to 110 - Private/Experimental algorithm",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement DSA for signatures, and Elgamal for encryption. Implementations SHOULD implement RSA keys (1). RSA Encrypt-Only (2) and RSA Sign-Only are deprecated and SHOULD NOT be generated, but may be interpreted. See Section 13.5. See Section 13.8 for notes on Elliptic Curve (18), ECDSA (19), Elgamal Encrypt or Sign (20), and X9.42 (21). Implementations MAY implement any other algorithm.",
      "ja": "実装は、署名にはDSAを実装し、暗号化にはElgamalを実装する必要があります。実装はRSAキーを実装する必要があります（1）。 RSA Encrypt-Only（2）およびRSA Sign-Onlyは非推奨であり、生成されるべきではありませんが、解釈される可能性があります。セクション13.5を参照してください。楕円曲線（18）、ECDSA（19）、Elgamal EncryptまたはSign（20）、およびX9.42（21）に関する注記については、セクション13.8を参照してください。実装は他のアルゴリズムを実装してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "9.2. Symmetric-Key Algorithms",
      "section_title": true,
      "ja": "9.2. 対称鍵アルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm\n--           ---------\n0          - Plaintext or unencrypted data\n1          - IDEA [IDEA]\n2          - TripleDES (DES-EDE, [SCHNEIER] [HAC] -\n             168 bit key derived from 192)\n3          - CAST5 (128 bit key, as per [RFC2144])\n4          - Blowfish (128 bit key, 16 rounds) [BLOWFISH]\n5          - Reserved\n6          - Reserved\n7          - AES with 128-bit key [AES]\n8          - AES with 192-bit key\n9          - AES with 256-bit key\n10         - Twofish with 256-bit key [TWOFISH]\n100 to 110 - Private/Experimental algorithm",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " Implementations MUST implement TripleDES. Implementations SHOULD implement AES-128 and CAST5. Implementations that interoperate with PGP 2.6 or earlier need to support IDEA, as that is the only symmetric cipher those versions use. Implementations MAY implement any other algorithm.",
      "ja": "実装はTripleDESを実装する必要があります。実装は、AES-128とCAST5を実装する必要があります（SHOULD）。 PGP 2.6以前と相互運用する実装は、IDEAをサポートする必要があります。これは、これらのバージョンが使用する唯一の対称暗号であるためです。実装は他のアルゴリズムを実装してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "9.3. Compression Algorithms",
      "section_title": true,
      "ja": "9.3. 圧縮アルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm\n--           ---------\n0          - Uncompressed\n1          - ZIP [RFC1951]\n2          - ZLIB [RFC1950]\n3          - BZip2 [BZ2]\n100 to 110 - Private/Experimental algorithm",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement uncompressed data. Implementations SHOULD implement ZIP. Implementations MAY implement any other algorithm.",
      "ja": "実装では、非圧縮データを実装する必要があります。実装はZIPを実装する必要があります（SHOULD）。実装は他のアルゴリズムを実装してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "9.4. Hash Algorithms",
      "section_title": true,
      "ja": "9.4. ハッシュアルゴリズム"
    },
    {
      "indent": 6,
      "text": "ID           Algorithm                             Text Name\n--           ---------                             ---------\n1          - MD5 [HAC]                             \"MD5\"\n2          - SHA-1 [FIPS180]                       \"SHA1\"\n3          - RIPE-MD/160 [HAC]                     \"RIPEMD160\"\n4          - Reserved\n5          - Reserved\n6          - Reserved\n7          - Reserved\n8          - SHA256 [FIPS180]                      \"SHA256\"\n9          - SHA384 [FIPS180]                      \"SHA384\"\n10         - SHA512 [FIPS180]                      \"SHA512\"\n11         - SHA224 [FIPS180]                      \"SHA224\"\n100 to 110 - Private/Experimental algorithm",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement SHA-1. Implementations MAY implement other algorithms. MD5 is deprecated.",
      "ja": "実装はSHA-1を実装する必要があります。実装は他のアルゴリズムを実装してもよい（MAY）。 MD5は非推奨です。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "OpenPGP is highly parameterized, and consequently there are a number of considerations for allocating parameters for extensions. This section describes how IANA should look at extensions to the protocol as described in this document.",
      "ja": "OpenPGPは高度にパラメーター化されているため、拡張機能にパラメーターを割り当てる場合、多くの考慮事項があります。このセクションでは、このドキュメントで説明されているように、IANAがプロトコルの拡張機能をどのように見るかについて説明します。"
    },
    {
      "indent": 0,
      "text": "10.1. New String-to-Key Specifier Types",
      "section_title": true,
      "ja": "10.1. 新しい文字列からキーへの指定子タイプ"
    },
    {
      "indent": 3,
      "text": "OpenPGP S2K specifiers contain a mechanism for new algorithms to turn a string into a key. This specification creates a registry of S2K specifier types. The registry includes the S2K type, the name of the S2K, and a reference to the defining specification. The initial values for this registry can be found in Section 3.7.1. Adding a new S2K specifier MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGP S2K指定子には、文字列をキーに変換する新しいアルゴリズムのメカニズムが含まれています。この仕様は、S2K指定子タイプのレジストリを作成します。レジストリには、S2Kタイプ、S2Kの名前、および定義仕様への参照が含まれています。このレジストリの初期値はセクション3.7.1にあります。 [RFC2434]で説明されているように、新しいS2K指定子を追加するには、IETF CONSENSUSメソッドを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2. New Packets",
      "section_title": true,
      "ja": "10.2. 新しいパケット"
    },
    {
      "indent": 3,
      "text": "Major new features of OpenPGP are defined through new packet types. This specification creates a registry of packet types. The registry includes the packet type, the name of the packet, and a reference to the defining specification. The initial values for this registry can be found in Section 4.3. Adding a new packet type MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPの主要な新機能は、新しいパケットタイプによって定義されます。この仕様は、パケットタイプのレジストリを作成します。レジストリには、パケットタイプ、パケットの名前、および定義仕様への参照が含まれています。このレジストリの初期値はセクション4.3にあります。 [RFC2434]で説明されているように、IETF CONSENSUSメソッドを通じて新しいパケットタイプを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.1. User Attribute Types",
      "section_title": true,
      "ja": "10.2.1. ユーザー属性タイプ"
    },
    {
      "indent": 3,
      "text": "The User Attribute packet permits an extensible mechanism for other types of certificate identification. This specification creates a registry of User Attribute types. The registry includes the User Attribute type, the name of the User Attribute, and a reference to the defining specification. The initial values for this registry can be found in Section 5.12. Adding a new User Attribute type MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "ユーザー属性パケットは、他のタイプの証明書識別のための拡張可能なメカニズムを許可します。この仕様は、ユーザー属性タイプのレジストリを作成します。レジストリには、ユーザー属性タイプ、ユーザー属性の名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.12にあります。 [RFC2434]で説明されているように、新しいユーザー属性タイプの追加は、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1. Image Format Subpacket Types",
      "section_title": true,
      "ja": "10.2.1.1. 画像形式のサブパケットタイプ"
    },
    {
      "indent": 3,
      "text": "Within User Attribute packets, there is an extensible mechanism for other types of image-based user attributes. This specification creates a registry of Image Attribute subpacket types. The registry includes the Image Attribute subpacket type, the name of the Image Attribute subpacket, and a reference to the defining specification. The initial values for this registry can be found in Section 5.12.1. Adding a new Image Attribute subpacket type MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "ユーザー属性パケット内には、他のタイプの画像ベースのユーザー属性用の拡張可能なメカニズムがあります。この仕様は、イメージ属性サブパケットタイプのレジストリを作成します。レジストリには、画像属性サブパケットタイプ、画像属性サブパケットの名前、および定義仕様への参照が含まれています。このレジストリの初期値はセクション5.12.1にあります。 [RFC2434]で説明されているように、新しい画像属性サブパケットタイプの追加は、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2. New Signature Subpackets",
      "section_title": true,
      "ja": "10.2.2. 新しい署名サブパケット"
    },
    {
      "indent": 0,
      "text": " OpenPGP signatures contain a mechanism for signed (or unsigned) data to be added to them for a variety of purposes in the Signature subpackets as discussed in Section 5.2.3.1. This specification creates a registry of Signature subpacket types. The registry includes the Signature subpacket type, the name of the subpacket, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.1. Adding a new Signature subpacket MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGP署名には、署名された（または署名されていない）データをさまざまな目的で署名サブパケットに追加するメカニズムが含まれています（セクション5.2.3.1を参照）。この仕様は、Signatureサブパケットタイプのレジストリを作成します。レジストリには、Signatureサブパケットタイプ、サブパケットの名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.1にあります。 [RFC2434]で説明されているように、IETF CONSENSUSメソッドを通じて新しい署名サブパケットを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2.1. Signature Notation Data Subpackets",
      "section_title": true,
      "ja": "10.2.2.1. 署名表記データサブパケット"
    },
    {
      "indent": 3,
      "text": "OpenPGP signatures further contain a mechanism for extensions in signatures. These are the Notation Data subpackets, which contain a key/value pair. Notations contain a user space that is completely unmanaged and an IETF space.",
      "ja": "OpenPGP署名には、署名の拡張機能のメカニズムがさらに含まれています。これらは、キー/値のペアを含む表記データサブパケットです。表記には、完全に管理されていないユーザースペースとIETFスペースが含まれます。"
    },
    {
      "indent": 3,
      "text": "This specification creates a registry of Signature Notation Data types. The registry includes the Signature Notation Data type, the name of the Signature Notation Data, its allowed values, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.16. Adding a new Signature Notation Data subpacket MUST be done through the EXPERT REVIEW method, as described in [RFC2434].",
      "ja": "この仕様は、署名表記データ型のレジストリを作成します。レジストリには、署名表記データタイプ、署名表記データの名前、許可される値、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.16にあります。 [RFC2434]で説明されているように、新しい署名表記データサブパケットを追加するには、EXPERT REVIEWメソッドを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2.2. Key Server Preference Extensions",
      "section_title": true,
      "ja": "10.2.2.2. 主要なサーバー設定拡張機能"
    },
    {
      "indent": 3,
      "text": "OpenPGP signatures contain a mechanism for preferences to be specified about key servers. This specification creates a registry of key server preferences. The registry includes the key server preference, the name of the preference, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.17. Adding a new key server preference MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPシグニチャーには、鍵サーバーについて指定される設定のメカニズムが含まれています。この仕様は、主要なサーバー設定のレジストリを作成します。レジストリには、キーサーバーの設定、設定の名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.17にあります。 [RFC2434]で説明されているように、IETF CONSENSUSメソッドを通じて新しいキーサーバー設定を追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2.3. Key Flags Extensions",
      "section_title": true,
      "ja": "10.2.2.3. キーフラグ拡張"
    },
    {
      "indent": 3,
      "text": "OpenPGP signatures contain a mechanism for flags to be specified about key usage. This specification creates a registry of key usage flags. The registry includes the key flags value, the name of the flag, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.21. Adding a new key usage flag MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPシグネチャには、キーの使用法についてフラグを指定するためのメカニズムが含まれています。この仕様は、キー使用フラグのレジストリを作成します。レジストリには、キーフラグ値、フラグの名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.21にあります。 [RFC2434]で説明されているように、IETF CONSENSUSメソッドを通じて新しいキー使用フラグを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2.4. Reason for Revocation Extensions",
      "section_title": true,
      "ja": "10.2.2.4. 失効拡張の理由"
    },
    {
      "indent": 3,
      "text": "OpenPGP signatures contain a mechanism for flags to be specified about why a key was revoked. This specification creates a registry of \"Reason for Revocation\" flags. The registry includes the \"Reason for Revocation\" flags value, the name of the flag, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.23. Adding a new feature flag MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGP署名には、キーが取り消された理由についてフラグを指定するメカニズムが含まれています。この仕様は、「Reason for Revocation」フラグのレジストリを作成します。レジストリには、「Reason for Revocation」フラグの値、フラグの名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.23にあります。 [RFC2434]で説明されているように、新しい機能フラグの追加はIETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.2.5. Implementation Features",
      "section_title": true,
      "ja": "10.2.2.5. 実装機能"
    },
    {
      "indent": 3,
      "text": "OpenPGP signatures contain a mechanism for flags to be specified stating which optional features an implementation supports. This specification creates a registry of feature-implementation flags. The registry includes the feature-implementation flags value, the name of the flag, and a reference to the defining specification. The initial values for this registry can be found in Section 5.2.3.24. Adding a new feature-implementation flag MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPシグネチャには、実装がサポートするオプション機能を指定するフラグを指定するメカニズムが含まれています。この仕様は、機能実装フラグのレジストリを作成します。レジストリには、機能実装フラグの値、フラグの名前、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション5.2.3.24にあります。 [RFC2434]で説明されているように、新しい機能実装フラグの追加は、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Also see Section 13.12 for more information about when feature flags are needed.",
      "ja": "機能フラグが必要な場合の詳細については、セクション13.12も参照してください。"
    },
    {
      "indent": 0,
      "text": "10.2.3. New Packet Versions",
      "section_title": true,
      "ja": "10.2.3. 新しいパケットバージョン"
    },
    {
      "indent": 3,
      "text": "The core OpenPGP packets all have version numbers, and can be revised by introducing a new version of an existing packet. This specification creates a registry of packet types. The registry includes the packet type, the number of the version, and a reference to the defining specification. The initial values for this registry can be found in Section 5. Adding a new packet version MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "コアOpenPGPパケットにはすべてバージョン番号があり、既存のパケットの新しいバージョンを導入することで変更できます。この仕様は、パケットタイプのレジストリを作成します。レジストリには、パケットタイプ、バージョン番号、および定義仕様への参照が含まれています。このレジストリの初期値はセクション5にあります。新しいパケットバージョンの追加は、[RFC2434]で説明されているように、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3. New Algorithms",
      "section_title": true,
      "ja": "10.3. 新しいアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 9 lists the core algorithms that OpenPGP uses. Adding in a new algorithm is usually simple. For example, adding in a new symmetric cipher usually would not need anything more than allocating a constant for that cipher. If that cipher had other than a 64-bit or 128-bit block size, there might need to be additional documentation describing how OpenPGP-CFB mode would be adjusted. Similarly, when DSA was expanded from a maximum of 1024-bit public keys to 3072-bit public keys, the revision of FIPS 186 contained enough information itself to allow implementation. Changes to this document were made mainly for emphasis.",
      "ja": "セクション9は、OpenPGPが使用するコアアルゴリズムの一覧です。新しいアルゴリズムの追加は、通常は簡単です。たとえば、新しい対称暗号を追加する場合、通常はその暗号に定数を割り当てるだけで十分です。その暗号のブロックサイズが64ビットまたは128ビット以外の場合、OpenPGP-CFBモードを調整する方法を説明する追加のドキュメントが必要になる場合があります。同様に、DSAが最大1024ビットの公開鍵から3072ビットの公開鍵に拡張された場合、FIPS 186のリビジョンには、実装を可能にするのに十分な情報自体が含まれていました。このドキュメントに対する変更は、主に強調のために行われました。"
    },
    {
      "indent": 0,
      "text": "10.3.1. Public-Key Algorithms",
      "section_title": true,
      "ja": "10.3.1. 公開鍵アルゴリズム"
    },
    {
      "indent": 3,
      "text": "OpenPGP specifies a number of public-key algorithms. This specification creates a registry of public-key algorithm identifiers. The registry includes the algorithm name, its key sizes and parameters, and a reference to the defining specification. The initial values for this registry can be found in Section 9. Adding a new public-key algorithm MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPは、いくつかの公開鍵アルゴリズムを指定します。この仕様は、公開鍵アルゴリズム識別子のレジストリを作成します。レジストリには、アルゴリズム名、そのキーサイズとパラメータ、および定義仕様への参照が含まれています。このレジストリの初期値はセクション9にあります。新しい公開鍵アルゴリズムの追加は、[RFC2434]で説明されているように、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.2. Symmetric-Key Algorithms",
      "section_title": true,
      "ja": "10.3.2. 対称鍵アルゴリズム"
    },
    {
      "indent": 3,
      "text": "OpenPGP specifies a number of symmetric-key algorithms. This specification creates a registry of symmetric-key algorithm identifiers. The registry includes the algorithm name, its key sizes and block size, and a reference to the defining specification. The initial values for this registry can be found in Section 9. Adding a new symmetric-key algorithm MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPは、いくつかの対称鍵アルゴリズムを指定します。この仕様は、対称鍵アルゴリズム識別子のレジストリを作成します。レジストリには、アルゴリズム名、そのキーサイズとブロックサイズ、および定義仕様への参照が含まれています。このレジストリの初期値はセクション9にあります。新しい対称鍵アルゴリズムの追加は、[RFC2434]で説明されているように、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.3. Hash Algorithms",
      "section_title": true,
      "ja": "10.3.3. ハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "OpenPGP specifies a number of hash algorithms. This specification creates a registry of hash algorithm identifiers. The registry includes the algorithm name, a text representation of that name, its block size, an OID hash prefix, and a reference to the defining specification. The initial values for this registry can be found in Section 9 for the algorithm identifiers and text names, and Section 5.2.2 for the OIDs and expanded signature prefixes. Adding a new hash algorithm MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPは、いくつかのハッシュアルゴリズムを指定します。この仕様は、ハッシュアルゴリズム識別子のレジストリを作成します。レジストリには、アルゴリズム名、その名前のテキスト表現、そのブロックサイズ、OIDハッシュプレフィックス、および定義仕様への参照が含まれています。このレジストリの初期値は、セクション9のアルゴリズム識別子とテキスト名、セクション5.2.2のOIDと拡張署名プレフィックスにあります。 [RFC2434]で説明されているように、新しいハッシュアルゴリズムの追加は、IETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.4. Compression Algorithms",
      "section_title": true,
      "ja": "10.3.4. 圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "OpenPGP specifies a number of compression algorithms. This specification creates a registry of compression algorithm identifiers. The registry includes the algorithm name and a reference to the defining specification. The initial values for this registry can be found in Section 9.3. Adding a new compression key algorithm MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "OpenPGPは、いくつかの圧縮アルゴリズムを指定します。この仕様は、圧縮アルゴリズム識別子のレジストリを作成します。レジストリには、アルゴリズム名と定義仕様への参照が含まれています。このレジストリの初期値はセクション9.3にあります。 [RFC2434]で説明されているように、IETF CONSENSUSメソッドを通じて新しい圧縮キーアルゴリズムを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. Packet Composition",
      "section_title": true,
      "ja": "11. パケット構成"
    },
    {
      "indent": 3,
      "text": "OpenPGP packets are assembled into sequences in order to create messages and to transfer keys. Not all possible packet sequences are meaningful and correct. This section describes the rules for how packets should be placed into sequences.",
      "ja": "OpenPGPパケットは、メッセージを作成し、鍵を転送するために、シーケンスに組み立てられます。すべての可能なパケットシーケンスが意味があり、正しいわけではありません。このセクションでは、パケットをシーケンスに配置する方法の規則について説明します。"
    },
    {
      "indent": 0,
      "text": "11.1. Transferable Public Keys",
      "section_title": true,
      "ja": "11.1. 譲渡可能な公開鍵"
    },
    {
      "indent": 3,
      "text": "OpenPGP users may transfer public keys. The essential elements of a transferable public key are as follows:",
      "ja": "OpenPGPユーザーは公開鍵を転送できます。転送可能な公開鍵の重要な要素は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- One Public-Key packet",
      "ja": "- 1つの公開鍵パケット"
    },
    {
      "indent": 5,
      "text": "- Zero or more revocation signatures",
      "ja": "- ゼロ以上の失効署名"
    },
    {
      "indent": 5,
      "text": "- One or more User ID packets",
      "ja": "- 1つ以上のユーザーIDパケット"
    },
    {
      "indent": 5,
      "text": "- After each User ID packet, zero or more Signature packets (certifications)",
      "ja": "- 各ユーザーIDパケットの後、0個以上の署名パケット（認証）"
    },
    {
      "indent": 5,
      "text": "- Zero or more User Attribute packets",
      "ja": "- 0個以上のユーザー属性パケット"
    },
    {
      "indent": 5,
      "text": "- After each User Attribute packet, zero or more Signature packets (certifications)",
      "ja": "- 各ユーザー属性パケットの後、0個以上の署名パケット（認証）"
    },
    {
      "indent": 5,
      "text": "- Zero or more Subkey packets",
      "ja": "- 0個以上のサブキーパケット"
    },
    {
      "indent": 5,
      "text": "- After each Subkey packet, one Signature packet, plus optionally a revocation",
      "ja": "- 各サブキーパケットの後、1つの署名パケット、およびオプションで失効"
    },
    {
      "indent": 3,
      "text": "The Public-Key packet occurs first. Each of the following User ID packets provides the identity of the owner of this public key. If there are multiple User ID packets, this corresponds to multiple means of identifying the same unique individual user; for example, a user may have more than one email address, and construct a User ID for each one.",
      "ja": "公開鍵パケットが最初に発生します。次の各ユーザーIDパケットは、この公開鍵の所有者のIDを提供します。複数のユーザーIDパケットがある場合、これは同じ一意の個々のユーザーを識別する複数の手段に対応します。たとえば、ユーザーが複数のメールアドレスを持っている場合、それぞれにユーザーIDを作成します。"
    },
    {
      "indent": 3,
      "text": "Immediately following each User ID packet, there are zero or more Signature packets. Each Signature packet is calculated on the immediately preceding User ID packet and the initial Public-Key packet. The signature serves to certify the corresponding public key and User ID. In effect, the signer is testifying to his or her belief that this public key belongs to the user identified by this User ID.",
      "ja": "各ユーザーIDパケットの直後に、0個以上の署名パケットがあります。各署名パケットは、直前のユーザーIDパケットと最初の公開鍵パケットで計算されます。署名は、対応する公開鍵とユーザーIDを証明する役割を果たします。実際、署名者は、この公開鍵がこのユーザーIDで識別されるユーザーに属しているという信念を表明しています。"
    },
    {
      "indent": 3,
      "text": "Within the same section as the User ID packets, there are zero or more User Attribute packets. Like the User ID packets, a User Attribute packet is followed by zero or more Signature packets calculated on the immediately preceding User Attribute packet and the initial Public-Key packet.",
      "ja": "ユーザーIDパケットと同じセクション内に、0個以上のユーザー属性パケットがあります。ユーザーIDパケットと同様に、ユーザー属性パケットの後には、直前のユーザー属性パケットと最初の公開鍵パケットで計算された0個以上の署名パケットが続きます。"
    },
    {
      "indent": 3,
      "text": "User Attribute packets and User ID packets may be freely intermixed in this section, so long as the signatures that follow them are maintained on the proper User Attribute or User ID packet.",
      "ja": "ユーザー属性パケットとユーザーIDパケットは、後続の署名が適切なユーザー属性またはユーザーIDパケットで維持されている限り、このセクションで自由に混在させることができます。"
    },
    {
      "indent": 3,
      "text": "After the User ID packet or Attribute packet, there may be zero or more Subkey packets. In general, subkeys are provided in cases where the top-level public key is a signature-only key. However, any V4 key may have subkeys, and the subkeys may be encryption-only keys, signature-only keys, or general-purpose keys. V3 keys MUST NOT have subkeys.",
      "ja": "ユーザーIDパケットまたは属性パケットの後に、0個以上のサブキーパケットが存在する場合があります。一般に、トップレベルの公開キーが署名のみのキーである場合、サブキーが提供されます。ただし、どのV4キーにもサブキーがあり、サブキーは暗号化のみのキー、署名のみのキー、または汎用のキーである場合があります。 V3キーにはサブキーがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "Each Subkey packet MUST be followed by one Signature packet, which should be a subkey binding signature issued by the top-level key. For subkeys that can issue signatures, the subkey binding signature MUST contain an Embedded Signature subpacket with a primary key binding signature (0x19) issued by the subkey on the top-level key.",
      "ja": "各サブキーパケットの後には、1つの署名パケットが続く必要があります。これは、トップレベルのキーによって発行されたサブキーバインディング署名である必要があります。署名を発行できるサブキーの場合、サブキーバインディング署名には、トップレベルキーのサブキーによって発行されたプライマリキーバインディング署名（0x19）が埋め込まれた署名サブパケットが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "Subkey and Key packets may each be followed by a revocation Signature packet to indicate that the key is revoked. Revocation signatures are only accepted if they are issued by the key itself, or by a key that is authorized to issue revocations via a Revocation Key subpacket in a self-signature by the top-level key.",
      "ja": "サブキーパケットとキーパケットのそれぞれの後に、キーが失効したことを示す失効署名パケットが続く場合があります。失効署名は、キー自体、またはトップレベルのキーによる自己署名の失効キーサブパケットを介して失効を発行することが許可されているキーによって発行された場合にのみ受け入れられます。"
    },
    {
      "indent": 3,
      "text": "Transferable public-key packet sequences may be concatenated to allow transferring multiple public keys in one operation.",
      "ja": "転送可能な公開鍵パケットシーケンスを連結して、1回の操作で複数の公開鍵を転送できます。"
    },
    {
      "indent": 0,
      "text": "11.2. Transferable Secret Keys",
      "section_title": true,
      "ja": "11.2. 譲渡可能な秘密鍵"
    },
    {
      "indent": 3,
      "text": "OpenPGP users may transfer secret keys. The format of a transferable secret key is the same as a transferable public key except that secret-key and secret-subkey packets are used instead of the public key and public-subkey packets. Implementations SHOULD include self-signatures on any user IDs and subkeys, as this allows for a complete public key to be automatically extracted from the transferable secret key. Implementations MAY choose to omit the self-signatures, especially if a transferable public key accompanies the transferable secret key.",
      "ja": "OpenPGPユーザーは秘密鍵を転送できます。転送可能な秘密鍵の形式は、公開鍵と公開サブキーのパケットの代わりに秘密鍵と秘密サブ鍵のパケットが使用されることを除いて、転送可能な公開鍵と同じです。実装には、転送可能な秘密鍵から完全な公開鍵を自動的に抽出できるようにするため、すべてのユーザーIDとサブ鍵に自己署名を含める必要があります（SHOULD）。特に転送可能な公開鍵が転送可能な秘密鍵を伴う場合、実装は自己署名を省略することを選択してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "11.3. OpenPGP Messages",
      "section_title": true,
      "ja": "11.3. OpenPGPメッセージ"
    },
    {
      "indent": 3,
      "text": "An OpenPGP message is a packet or sequence of packets that corresponds to the following grammatical rules (comma represents sequential composition, and vertical bar separates alternatives):",
      "ja": "OpenPGPメッセージは、次の文法規則に対応するパケットまたはパケットのシーケンスです（カンマは順次構成を表し、縦棒は代替を区切ります）。"
    },
    {
      "indent": 3,
      "text": "OpenPGP Message :- Encrypted Message | Signed Message | Compressed Message | Literal Message.",
      "ja": "OpenPGPメッセージ：-暗号化されたメッセージ|署名付きメッセージ|圧縮メッセージ|リテラルメッセージ。"
    },
    {
      "indent": 3,
      "text": "Compressed Message :- Compressed Data Packet.",
      "ja": "圧縮メッセージ：-圧縮データパケット。"
    },
    {
      "indent": 3,
      "text": "Literal Message :- Literal Data Packet.",
      "ja": "リテラルメッセージ：-リテラルデータパケット。"
    },
    {
      "indent": 3,
      "text": "ESK :- Public-Key Encrypted Session Key Packet | Symmetric-Key Encrypted Session Key Packet.",
      "ja": "ESK：-公開鍵暗号化セッション鍵パケット|対称鍵暗号化セッション鍵パケット。"
    },
    {
      "indent": 3,
      "text": "ESK Sequence :- ESK | ESK Sequence, ESK.",
      "ja": "ESKシーケンス：-ESK | ESKシーケンス、ESK。"
    },
    {
      "indent": 3,
      "text": "Encrypted Data :- Symmetrically Encrypted Data Packet | Symmetrically Encrypted Integrity Protected Data Packet",
      "ja": "暗号化されたデータ：-対称的に暗号化されたデータパケット|対称的に暗号化された整合性保護データパケット"
    },
    {
      "indent": 3,
      "text": "Encrypted Message :- Encrypted Data | ESK Sequence, Encrypted Data.",
      "ja": "暗号化されたメッセージ：-暗号化されたデータ| ESKシーケンス、暗号化データ。"
    },
    {
      "indent": 3,
      "text": "One-Pass Signed Message :- One-Pass Signature Packet, OpenPGP Message, Corresponding Signature Packet.",
      "ja": "ワンパス署名付きメッセージ：-ワンパス署名パケット、OpenPGPメッセージ、対応する署名パケット。"
    },
    {
      "indent": 3,
      "text": "Signed Message :- Signature Packet, OpenPGP Message | One-Pass Signed Message.",
      "ja": "署名付きメッセージ：-署名パケット、OpenPGPメッセージ|ワンパス署名メッセージ。"
    },
    {
      "indent": 3,
      "text": "In addition, decrypting a Symmetrically Encrypted Data packet or a Symmetrically Encrypted Integrity Protected Data packet as well as decompressing a Compressed Data packet must yield a valid OpenPGP Message.",
      "ja": "さらに、対称的に暗号化されたデータパケットまたは対称的に暗号化された整合性保護データパケットを復号化し、圧縮データパケットを解凍すると、有効なOpenPGPメッセージが生成される必要があります。"
    },
    {
      "indent": 0,
      "text": "11.4. Detached Signatures",
      "section_title": true,
      "ja": "11.4. 切り離された署名"
    },
    {
      "indent": 3,
      "text": "Some OpenPGP applications use so-called \"detached signatures\". For example, a program bundle may contain a file, and with it a second file that is a detached signature of the first file. These detached signatures are simply a Signature packet stored separately from the data for which they are a signature.",
      "ja": "一部のOpenPGPアプリケーションは、いわゆる「切り離された署名」を使用します。たとえば、プログラムバンドルにはファイルが含まれ、それに2番目のファイルが最初のファイルの切り離された署名になります。これらの分離された署名は、署名であるデータとは別に保存された署名パケットです。"
    },
    {
      "indent": 0,
      "text": "12. Enhanced Key Formats",
      "section_title": true,
      "ja": "12. 強化されたキー形式"
    },
    {
      "indent": 0,
      "text": "12.1. Key Structures",
      "section_title": true,
      "ja": "12.1. 主な構造"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP V3 key is as follows. Entries in square brackets are optional and ellipses indicate repetition.",
      "ja": "OpenPGP V3鍵の形式は次のとおりです。大括弧内の項目はオプションであり、省略記号は繰り返しを示します。"
    },
    {
      "indent": 11,
      "text": "RSA Public Key\n   [Revocation Self Signature]\n    User ID [Signature ...]\n   [User ID [Signature ...] ...]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each signature certifies the RSA public key and the preceding User ID. The RSA public key can have many User IDs and each User ID can have many signatures. V3 keys are deprecated. Implementations MUST NOT generate new V3 keys, but MAY continue to use existing ones.",
      "ja": "各署名は、RSA公開鍵とその前のユーザーIDを証明します。 RSA公開鍵は多くのユーザーIDを持つことができ、各ユーザーIDは多くの署名を持つことができます。 V3キーは非推奨です。実装は新しいV3鍵を生成してはならない（MUST NOT）が、既存の鍵を引き続き使用してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP V4 key that uses multiple public keys is similar except that the other keys are added to the end as \"subkeys\" of the primary key.",
      "ja": "複数の公開鍵を使用するOpenPGP V4鍵のフォーマットは、他の鍵が主鍵の「サブ鍵」として末尾に追加されることを除いて、似ています。"
    },
    {
      "indent": 11,
      "text": "Primary-Key\n   [Revocation Self Signature]\n   [Direct Key Signature...]\n    User ID [Signature ...]\n   [User ID [Signature ...] ...]\n   [User Attribute [Signature ...] ...]\n   [[Subkey [Binding-Signature-Revocation]\n           Primary-Key-Binding-Signature] ...]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A subkey always has a single signature after it that is issued using the primary key to tie the two keys together. This binding signature may be in either V3 or V4 format, but SHOULD be V4. Subkeys that can issue signatures MUST have a V4 binding signature due to the REQUIRED embedded primary key binding signature.",
      "ja": "サブキーは、主キーを使用して2つのキーを結合して発行された後、常に1つの署名を持っています。このバインディング署名はV3またはV4形式のいずれかですが、V4である必要があります。署名を発行できるサブキーには、必須の埋め込み主キーバインディング署名があるため、V4バインディング署名が必要です。"
    },
    {
      "indent": 3,
      "text": "In the above diagram, if the binding signature of a subkey has been revoked, the revoked key may be removed, leaving only one key.",
      "ja": "上の図で、サブキーのバインド署名が取り消された場合、取り消されたキーが削除され、キーが1つだけ残る場合があります。"
    },
    {
      "indent": 3,
      "text": "In a V4 key, the primary key MUST be a key capable of certification. The subkeys may be keys of any other type. There may be other constructions of V4 keys, too. For example, there may be a single-key RSA key in V4 format, a DSA primary key with an RSA encryption key, or RSA primary key with an Elgamal subkey, etc.",
      "ja": "V4キーでは、主キーは認証可能なキーである必要があります。サブキーは、他のタイプのキーでもかまいません。 V4キーの他の構造もあるかもしれません。たとえば、V4形式の単一キーのRSAキー、RSA暗号化キーを持つDSA主キー、またはElgamalサブキーを持つRSA主キーなどがあります。"
    },
    {
      "indent": 3,
      "text": "It is also possible to have a signature-only subkey. This permits a primary key that collects certifications (key signatures), but is used only for certifying subkeys that are used for encryption and signatures.",
      "ja": "署名のみのサブキーを持つことも可能です。これにより、証明書（キー署名）を収集する主キーが許可されますが、暗号化と署名に使用されるサブキーの認証にのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "12.2. Key IDs and Fingerprints",
      "section_title": true,
      "ja": "12.2. キーIDと指紋"
    },
    {
      "indent": 3,
      "text": "For a V3 key, the eight-octet Key ID consists of the low 64 bits of the public modulus of the RSA key.",
      "ja": "V3キーの場合、8オクテットのキーIDは、RSAキーの公開モジュラスの下位64ビットで構成されます。"
    },
    {
      "indent": 3,
      "text": "The fingerprint of a V3 key is formed by hashing the body (but not the two-octet length) of the MPIs that form the key material (public modulus n, followed by exponent e) with MD5. Note that both V3 keys and MD5 are deprecated.",
      "ja": "V3キーのフィンガープリントは、キーマテリアル（パブリックモジュラスn、指数e）を形成するMPIの本体（2オクテット長ではない）をMD5でハッシュすることによって形成されます。 V3キーとMD5はどちらも非推奨であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A V4 fingerprint is the 160-bit SHA-1 hash of the octet 0x99, followed by the two-octet packet length, followed by the entire Public-Key packet starting with the version field. The Key ID is the low-order 64 bits of the fingerprint. Here are the fields of the hash material, with the example of a DSA key:",
      "ja": "V4フィンガープリントは、オクテット0x99の160ビットSHA-1ハッシュで、2オクテットのパケット長が続き、その後にバージョンフィールドで始まる公開鍵パケット全体が続きます。キーIDは、指紋の下位64ビットです。ハッシュマテリアルのフィールドとDSAキーの例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "a.1) 0x99 (1 octet)",
      "ja": "a.1）0x99（1オクテット）"
    },
    {
      "indent": 0,
      "text": " a.2) high-order length octet of (b)-(e) (1 octet) a.3) low-order length octet of (b)-(e) (1 octet)",
      "ja": "a.2）（b）-（e）（1オクテット）の高次長オクテットa.3）（b）-（e）（1オクテット）の低次長オクテット"
    },
    {
      "indent": 5,
      "text": "b) version number = 4 (1 octet);",
      "ja": "b) バージョン番号= 4（1オクテット）;"
    },
    {
      "indent": 5,
      "text": "c) timestamp of key creation (4 octets);",
      "ja": "c) キー作成のタイムスタンプ（4オクテット）;"
    },
    {
      "indent": 5,
      "text": "d) algorithm (1 octet): 17 = DSA (example);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "e) Algorithm-specific fields.",
      "ja": "e) アルゴリズム固有のフィールド。"
    },
    {
      "indent": 3,
      "text": "Algorithm-Specific Fields for DSA keys (example):",
      "ja": "DSAキーのアルゴリズム固有のフィールド（例）："
    },
    {
      "indent": 3,
      "text": "e.1) MPI of DSA prime p;",
      "ja": "e.1）DSA素数pのMPI。"
    },
    {
      "indent": 3,
      "text": "e.2) MPI of DSA group order q (q is a prime divisor of p-1);",
      "ja": "e.2）DSAグループ次数qのMPI（qはp-1の素数）。"
    },
    {
      "indent": 3,
      "text": "e.3) MPI of DSA group generator g;",
      "ja": "e.3）DSAグループジェネレーターgのMPI;"
    },
    {
      "indent": 3,
      "text": "e.4) MPI of DSA public-key value y (= g**x mod p where x is secret).",
      "ja": "e.4）DSA公開鍵値y（= g ** x mod p、xは秘密）のMPI。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible for there to be collisions of Key IDs -- two different keys with the same Key ID. Note that there is a much smaller, but still non-zero, probability that two different keys have the same fingerprint.",
      "ja": "キーIDの衝突が発生する可能性があることに注意してください-同じキーIDを持つ2つの異なるキー。 2つの異なるキーが同じフィンガープリントを持っている確率はずっと小さいですが、それでもゼロではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Also note that if V3 and V4 format keys share the same RSA key material, they will have different Key IDs as well as different fingerprints.",
      "ja": "また、V3およびV4形式のキーが同じRSAキーマテリアルを共有する場合、それらは異なるキーIDと異なるフィンガープリントを持つことにも注意してください。"
    },
    {
      "indent": 3,
      "text": "Finally, the Key ID and fingerprint of a subkey are calculated in the same way as for a primary key, including the 0x99 as the first octet (even though this is not a valid packet ID for a public subkey).",
      "ja": "最後に、サブキーのキーIDとフィンガープリントは、最初のオクテットとして0x99を含めて、プライマリキーと同じ方法で計算されます（これは公開サブキーの有効なパケットIDではありません）。"
    },
    {
      "indent": 0,
      "text": "13. Notes on Algorithms",
      "section_title": true,
      "ja": "13. アルゴリズムに関する注意"
    },
    {
      "indent": 0,
      "text": "13.1. PKCS#1 Encoding in OpenPGP",
      "section_title": true,
      "ja": "13.1. OpenPGPでのPKCS＃1エンコーディング"
    },
    {
      "indent": 3,
      "text": "This standard makes use of the PKCS#1 functions EME-PKCS1-v1_5 and EMSA-PKCS1-v1_5. However, the calling conventions of these functions has changed in the past. To avoid potential confusion and interoperability problems, we are including local copies in this document, adapted from those in PKCS#1 v2.1 [RFC3447]. RFC 3447 should be treated as the ultimate authority on PKCS#1 for OpenPGP. Nonetheless, we believe that there is value in having a self-contained document that avoids problems in the future with needed changes in the conventions.",
      "ja": "この標準は、PKCS＃1機能EME-PKCS1-v1_5およびEMSA-PKCS1-v1_5を使用します。ただし、これらの関数の呼び出し規約は過去に変更されています。潜在的な混乱と相互運用性の問題を回避するために、このドキュメントには、PKCS＃1 v2.1 [RFC3447]のローカルコピーを採用したローカルコピーを含めています。 RFC 3447は、OpenPGPのPKCS＃1の最終的な権限として扱われるべきです。それにもかかわらず、必要に応じて規則を変更することで、将来の問題を回避する自己完結型のドキュメントを作成することには価値があると考えています。"
    },
    {
      "indent": 0,
      "text": "13.1.1. EME-PKCS1-v1_5-ENCODE",
      "section_title": true,
      "ja": "13.1.1. EME-PKCS1-v1_5-ENCODE"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "k  = the length in octets of the key modulus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "M  = message to be encoded, an octet string of length mLen, where\n     mLen <= k - 11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "EM = encoded message, an octet string of length k",
      "ja": "EM =エンコードされたメッセージ、長さkのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Error: \"message too long\"",
      "ja": "エラー：「メッセージが長すぎます」"
    },
    {
      "indent": 5,
      "text": "1. Length checking: If mLen > k - 11, output \"message too long\" and stop.",
      "ja": "1. 長さチェック：mLen> k-11の場合、「メッセージが長すぎます」と出力して停止します。"
    },
    {
      "indent": 5,
      "text": "2. Generate an octet string PS of length k - mLen - 3 consisting of pseudo-randomly generated nonzero octets. The length of PS will be at least eight octets.",
      "ja": "2. 疑似ランダムに生成されたゼロ以外のオクテットで構成される長さk-mLen-3のオクテット文字列PSを生成します。 PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 5,
      "text": "3. Concatenate PS, the message M, and other padding to form an encoded message EM of length k octets as",
      "ja": "3. PS、メッセージM、および他のパディングを連結して、長さkオクテットのエンコードされたメッセージEMを形成します。"
    },
    {
      "indent": 8,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "ja": "EM = 0x00 || 0x02 || PS || 0x00 || M."
    },
    {
      "indent": 5,
      "text": "4. Output EM.",
      "ja": "4. 出力EM。"
    },
    {
      "indent": 0,
      "text": "13.1.2. EME-PKCS1-v1_5-DECODE",
      "section_title": true,
      "ja": "13.1.2. EME-PKCS1-v1_5-DECODE"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "EM = encoded message, an octet string",
      "ja": "EM =エンコードされたメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "M = message, an octet string",
      "ja": "M =メッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Error: \"decryption error\"",
      "ja": "エラー：「復号化エラー」"
    },
    {
      "indent": 3,
      "text": "To decode an EME-PKCS1_v1_5 message, separate the encoded message EM into an octet string PS consisting of nonzero octets and a message M as follows",
      "ja": "EME-PKCS1_v1_5メッセージをデコードするには、エンコードされたメッセージEMを、次のようにゼロ以外のオクテットとメッセージMで構成されるオクテットストリングPSに分離します。"
    },
    {
      "indent": 5,
      "text": "EM = 0x00 || 0x02 || PS || 0x00 || M.",
      "ja": "EM = 0x00 || 0x02 || PS || 0x00 || M."
    },
    {
      "indent": 3,
      "text": "If the first octet of EM does not have hexadecimal value 0x00, if the second octet of EM does not have hexadecimal value 0x02, if there is no octet with hexadecimal value 0x00 to separate PS from M, or if the length of PS is less than 8 octets, output \"decryption error\" and stop. See also the security note in Section 14 regarding differences in reporting between a decryption error and a padding error.",
      "ja": "EMの最初のオクテットに16進値0x00がない場合、EMの2番目のオクテットに16進値0x02がない場合、16進値0x00のオクテットがないためPSをMから分離できない場合、またはPSの長さが短い場合8オクテット、「復号化エラー」を出力して停止。復号化エラーとパディングエラーのレポートの違いについては、セクション14のセキュリティノートも参照してください。"
    },
    {
      "indent": 0,
      "text": "13.1.3. EMSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "13.1.3. EMSA-PKCS1-v1_5"
    },
    {
      "indent": 3,
      "text": "This encoding method is deterministic and only has an encoding operation.",
      "ja": "このエンコード方式は確定的であり、エンコード操作のみを含みます。"
    },
    {
      "indent": 3,
      "text": "Option:",
      "ja": "オプション："
    },
    {
      "indent": 3,
      "text": "Hash - a hash function in which hLen denotes the length in octets of the hash function output",
      "ja": "Hash-hLenがハッシュ関数出力のオクテット単位の長さを示すハッシュ関数"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "M  = message to be encoded",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "mL = intended length in octets of the encoded message, at least tLen + 11, where tLen is the octet length of the DER encoding T of a certain value computed during the encoding operation",
      "ja": "mL =エンコードされたメッセージのオクテット単位の意図された長さ、少なくともtLen + 11、ここでtLenは、エンコード操作中に計算された特定の値のDERエンコードTのオクテット長"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "EM = encoded message, an octet string of length emLen",
      "ja": "EM =エンコードされたメッセージ、長さがemLenのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "Errors: \"message too long\"; \"intended encoded message length too short\"",
      "ja": "エラー：「メッセージが長すぎます」; 「意図されたエンコードされたメッセージの長さが短すぎる」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "手順："
    },
    {
      "indent": 5,
      "text": "1. Apply the hash function to the message M to produce a hash value H:",
      "ja": "1. ハッシュ関数をメッセージMに適用して、ハッシュ値Hを生成します。"
    },
    {
      "indent": 8,
      "text": "H = Hash(M).",
      "ja": "H =ハッシュ（M）。"
    },
    {
      "indent": 8,
      "text": "If the hash function outputs \"message too long,\" output \"message too long\" and stop.",
      "ja": "ハッシュ関数が「メッセージが長すぎる」と出力した場合は、「メッセージが長すぎる」と出力して停止します。"
    },
    {
      "indent": 5,
      "text": "2. Using the list in Section 5.2.2, produce an ASN.1 DER value for the hash function used. Let T be the full hash prefix from Section 5.2.2, and let tLen be the length in octets of T.",
      "ja": "2. セクション5.2.2のリストを使用して、使用するハッシュ関数のASN.1 DER値を生成します。 Tをセクション5.2.2の完全なハッシュプレフィックスとし、tLenをTのオクテット単位の長さとします。"
    },
    {
      "indent": 5,
      "text": "3. If emLen < tLen + 11, output \"intended encoded message length too short\" and stop.",
      "ja": "3. emLen <tLen + 11の場合、「意図したエンコードメッセージの長さが短すぎる」と出力して停止します。"
    },
    {
      "indent": 5,
      "text": "4. Generate an octet string PS consisting of emLen - tLen - 3 octets with hexadecimal value 0xFF. The length of PS will be at least 8 octets.",
      "ja": "4. 16進値0xFFのemLen-tLen-3オクテットで構成されるオクテット文字列PSを生成します。 PSの長さは少なくとも8オクテットになります。"
    },
    {
      "indent": 5,
      "text": "5. Concatenate PS, the hash prefix T, and other padding to form the encoded message EM as",
      "ja": "5. PS、ハッシュプレフィックスT、およびその他のパディングを連結して、エンコードされたメッセージEMを次のように形成します。"
    },
    {
      "indent": 8,
      "text": "EM = 0x00 || 0x01 || PS || 0x00 || T.",
      "ja": "EM = 0x00 || 0x01 || PS || 0x00 || T."
    },
    {
      "indent": 5,
      "text": "6. Output EM.",
      "ja": "6. 出力EM。"
    },
    {
      "indent": 0,
      "text": "13.2. Symmetric Algorithm Preferences",
      "section_title": true,
      "ja": "13.2. 対称アルゴリズムの設定"
    },
    {
      "indent": 3,
      "text": "The symmetric algorithm preference is an ordered list of algorithms that the keyholder accepts. Since it is found on a self-signature, it is possible that a keyholder may have multiple, different preferences. For example, Alice may have TripleDES only specified for \"alice@work.com\" but CAST5, Blowfish, and TripleDES specified for \"alice@home.org\". Note that it is also possible for preferences to be in a subkey's binding signature.",
      "ja": "対称アルゴリズム設定は、キーホルダーが受け入れるアルゴリズムの順序付きリストです。自己署名に記載されているため、キーホルダーに複数の異なる設定がある可能性があります。たとえば、アリスは、「alice@work.com」に対してのみ指定されたTripleDESを持つことができますが、「alice@home.org」に対して指定されたCAST5、Blowfish、およびTripleDESを持つことができます。設定がサブキーのバインディング署名に含まれることも可能であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since TripleDES is the MUST-implement algorithm, if it is not explicitly in the list, it is tacitly at the end. However, it is good form to place it there explicitly. Note also that if an implementation does not implement the preference, then it is implicitly a TripleDES-only implementation.",
      "ja": "TripleDESは必須の実装アルゴリズムであるため、リストに明示的に記載されていない場合、暗黙的に最後にあります。ただし、明示的に配置することをお勧めします。実装が設定を実装しない場合、それは暗黙的にTripleDESのみの実装であることにも注意してください。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT use a symmetric algorithm that is not in the recipient's preference list. When encrypting to more than one recipient, the implementation finds a suitable algorithm by taking the intersection of the preferences of the recipients. Note that the MUST-implement algorithm, TripleDES, ensures that the intersection is not null. The implementation may use any mechanism to pick an algorithm in the intersection.",
      "ja": "実装は、受信者の優先リストにない対称アルゴリズムを使用してはなりません（MUST NOT）。複数の受信者に対して暗号化する場合、実装は受信者の設定の共通部分をとることによって適切なアルゴリズムを見つけます。 MUST実装アルゴリズムであるTripleDESは、交差がnullではないことを保証することに注意してください。実装では、任意のメカニズムを使用して、交差点でアルゴリズムを選択できます。"
    },
    {
      "indent": 3,
      "text": "If an implementation can decrypt a message that a keyholder doesn't have in their preferences, the implementation SHOULD decrypt the message anyway, but MUST warn the keyholder that the protocol has been violated. For example, suppose that Alice, above, has software that implements all algorithms in this specification. Nonetheless, she prefers subsets for work or home. If she is sent a message encrypted with IDEA, which is not in her preferences, the software warns her that someone sent her an IDEA-encrypted message, but it would ideally decrypt it anyway.",
      "ja": "実装がキーホルダーに設定にないメッセージを復号化できる場合、実装はとにかくメッセージを復号化する必要がありますが、プロトコルに違反していることをキーホルダーに警告する必要があります。たとえば、上記のアリスに、この仕様のすべてのアルゴリズムを実装するソフトウェアがあるとします。それにもかかわらず、彼女は仕事や家のためにサブセットを好みます。 IDEAで暗号化されたメッセージが送信されたが、それが自分の好みではない場合、ソフトウェアは、誰かが彼女にIDEA暗号化メッセージを送信したことを警告しますが、とにかくそれを復号化するのが理想的です。"
    },
    {
      "indent": 0,
      "text": "13.3. Other Algorithm Preferences",
      "section_title": true,
      "ja": "13.3. その他のアルゴリズム設定"
    },
    {
      "indent": 3,
      "text": "Other algorithm preferences work similarly to the symmetric algorithm preference, in that they specify which algorithms the keyholder accepts. There are two interesting cases that other comments need to be made about, though, the compression preferences and the hash preferences.",
      "ja": "他のアルゴリズムの設定は、対称アルゴリズムの設定と同様に機能し、キーホルダーが受け入れるアルゴリズムを指定します。ただし、他のコメントについては、圧縮設定とハッシュ設定の2つの興味深いケースがあります。"
    },
    {
      "indent": 0,
      "text": "13.3.1. Compression Preferences",
      "section_title": true,
      "ja": "13.3.1. 圧縮設定"
    },
    {
      "indent": 3,
      "text": "Compression has been an integral part of PGP since its first days. OpenPGP and all previous versions of PGP have offered compression. In this specification, the default is for messages to be compressed, although an implementation is not required to do so. Consequently, the compression preference gives a way for a keyholder to request that messages not be compressed, presumably because they are using a minimal implementation that does not include compression. Additionally, this gives a keyholder a way to state that it can support alternate algorithms.",
      "ja": "圧縮は、PGPの最初の頃から不可欠な要素でした。 OpenPGPと以前のすべてのバージョンのPGPは圧縮を提供しています。この仕様では、デフォルトではメッセージが圧縮されますが、実装で圧縮する必要はありません。その結果、圧縮プリファレンスは、キーホルダーがメッセージを圧縮しないように要求する方法を提供します。これはおそらく、圧縮を含まない最小限の実装を使用しているためです。さらに、これにより、キーホルダーは代替アルゴリズムをサポートできることを示すことができます。"
    },
    {
      "indent": 3,
      "text": "Like the algorithm preferences, an implementation MUST NOT use an algorithm that is not in the preference vector. If the preferences are not present, then they are assumed to be [ZIP(1), Uncompressed(0)].",
      "ja": "アルゴリズム設定と同様に、実装は設定ベクトルにないアルゴリズムを使用してはなりません（MUST NOT）。設定が存在しない場合は、[ZIP（1）、Uncompressed（0）]であると見なされます。"
    },
    {
      "indent": 3,
      "text": "Additionally, an implementation MUST implement this preference to the degree of recognizing when to send an uncompressed message. A robust implementation would satisfy this requirement by looking at the recipient's preference and acting accordingly. A minimal implementation can satisfy this requirement by never generating a compressed message, since all implementations can handle messages that have not been compressed.",
      "ja": "さらに、実装は、非圧縮メッセージを送信するタイミングを認識する程度にこの設定を実装する必要があります。堅牢な実装は、受信者の好みを見て、それに応じて行動することにより、この要件を満たします。すべての実装は圧縮されていないメッセージを処理できるため、最小限の実装では、圧縮されたメッセージを生成しないことでこの要件を満たすことができます。"
    },
    {
      "indent": 0,
      "text": "13.3.2. Hash Algorithm Preferences",
      "section_title": true,
      "ja": "13.3.2. ハッシュアルゴリズムの設定"
    },
    {
      "indent": 3,
      "text": "Typically, the choice of a hash algorithm is something the signer does, rather than the verifier, because a signer rarely knows who is going to be verifying the signature. This preference, though, allows a protocol based upon digital signatures ease in negotiation.",
      "ja": "通常、ハッシュアルゴリズムの選択は、検証者ではなく署名者が行うことです。これは、署名者が署名を検証することを誰が知っているかはめったにないためです。ただし、この設定により、デジタル署名に基づくプロトコルのネゴシエーションが容易になります。"
    },
    {
      "indent": 3,
      "text": "Thus, if Alice is authenticating herself to Bob with a signature, it makes sense for her to use a hash algorithm that Bob's software uses. This preference allows Bob to state in his key which algorithms Alice may use.",
      "ja": "したがって、アリスが署名付きでボブに対して自分自身を認証している場合、ボブのソフトウェアが使用するハッシュアルゴリズムを使用することは理にかなっています。この設定により、ボブは、アリスが使用するアルゴリズムを自分のキーに記述することができます。"
    },
    {
      "indent": 3,
      "text": "Since SHA1 is the MUST-implement hash algorithm, if it is not explicitly in the list, it is tacitly at the end. However, it is good form to place it there explicitly.",
      "ja": "SHA1は、MUST実装のハッシュアルゴリズムであるため、リストに明示的に指定されていない場合、暗黙的に最後に配置されます。ただし、明示的に配置することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "13.4. Plaintext",
      "section_title": true,
      "ja": "13.4. 平文"
    },
    {
      "indent": 3,
      "text": "Algorithm 0, \"plaintext\", may only be used to denote secret keys that are stored in the clear. Implementations MUST NOT use plaintext in Symmetrically Encrypted Data packets; they must use Literal Data packets to encode unencrypted or literal data.",
      "ja": "アルゴリズム0、「プレーンテキスト」は、平文で保存されている秘密鍵を示すためにのみ使用できます。実装では、対称的に暗号化されたデータパケットでプレーンテキストを使用してはなりません。暗号化されていないデータまたはリテラルデータをエンコードするには、リテラルデータパケットを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.5. RSA",
      "section_title": true,
      "ja": "13.5. RSA"
    },
    {
      "indent": 3,
      "text": "There are algorithm types for RSA Sign-Only, and RSA Encrypt-Only keys. These types are deprecated. The \"key flags\" subpacket in a signature is a much better way to express the same idea, and generalizes it to all algorithms. An implementation SHOULD NOT create such a key, but MAY interpret it.",
      "ja": "RSA Sign-OnlyキーとRSA Encrypt-Onlyキーには、アルゴリズムタイプがあります。これらのタイプは非推奨です。シグネチャ内の「キーフラグ」サブパケットは、同じアイデアを表現するためのより優れた方法であり、それをすべてのアルゴリズムに一般化します。実装はそのようなキーを作成すべきではありませんが、それを解釈してもよいものです（MAY）。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement RSA keys of size less than 1024 bits.",
      "ja": "実装は、1024ビット未満のサイズのRSA鍵を実装してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 0,
      "text": "13.6. DSA",
      "section_title": true,
      "ja": "13.6. DSA"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement DSA keys of size less than 1024 bits. It MUST NOT implement a DSA key with a q size of less than 160 bits. DSA keys MUST also be a multiple of 64 bits, and the q size MUST be a multiple of 8 bits. The Digital Signature Standard (DSS) [FIPS186] specifies that DSA be used in one of the following ways:",
      "ja": "実装は、1024ビット未満のサイズのDSA鍵を実装してはなりません（SHOULD NOT）。 160ビット未満のqサイズのDSA鍵を実装してはならない（MUST NOT）。 DSAキーも64ビットの倍数である必要があり、qサイズは8ビットの倍数である必要があります。デジタル署名標準（DSS）[FIPS186]は、DSAが次のいずれかの方法で使用されることを指定しています。"
    },
    {
      "indent": 5,
      "text": "* 1024-bit key, 160-bit q, SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512 hash",
      "ja": "* 1024ビットキー、160ビットq、SHA-1、SHA-224、SHA-256、SHA-384、またはSHA-512ハッシュ"
    },
    {
      "indent": 5,
      "text": "* 2048-bit key, 224-bit q, SHA-224, SHA-256, SHA-384, or SHA-512 hash",
      "ja": "* 2048ビットキー、224ビットq、SHA-224、SHA-256、SHA-384、またはSHA-512ハッシュ"
    },
    {
      "indent": 5,
      "text": "* 2048-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash",
      "ja": "* 2048ビットキー、256ビットq、SHA-256、SHA-384、またはSHA-512ハッシュ"
    },
    {
      "indent": 5,
      "text": "* 3072-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash",
      "ja": "* 3072ビットキー、256ビットq、SHA-256、SHA-384、またはSHA-512ハッシュ"
    },
    {
      "indent": 3,
      "text": "The above key and q size pairs were chosen to best balance the strength of the key with the strength of the hash. Implementations SHOULD use one of the above key and q size pairs when generating DSA keys. If DSS compliance is desired, one of the specified SHA hashes must be used as well. [FIPS186] is the ultimate authority on DSS, and should be consulted for all questions of DSS compliance.",
      "ja": "上記のキーとqサイズのペアは、キーの強度とハッシュの強度のバランスを最適にするために選択されました。実装では、DSAキーを生成するときに、上記のキーとqサイズのペアのいずれかを使用する必要があります。 DSS準拠が必要な場合は、指定されたSHAハッシュの1つも使用する必要があります。 [FIPS186]はDSSの最終的な権限であり、DSSコンプライアンスのすべての質問について相談する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that earlier versions of this standard only allowed a 160-bit q with no truncation allowed, so earlier implementations may not be able to handle signatures with a different q size or a truncated hash.",
      "ja": "この標準の以前のバージョンでは、切り捨てが許可されていない160ビットのqのみが許可されていたため、以前の実装では、異なるqサイズまたは切り捨てられたハッシュで署名を処理できない場合があります。"
    },
    {
      "indent": 0,
      "text": "13.7. Elgamal",
      "section_title": true,
      "ja": "13.7. エルガマル"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement Elgamal keys of size less than 1024 bits.",
      "ja": "実装は、1024ビット未満のサイズのElgamal鍵を実装してはなりません（SHOULD NOT）。"
    },
    {
      "indent": 0,
      "text": "13.8. Reserved Algorithm Numbers",
      "section_title": true,
      "ja": "13.8. 予約済みアルゴリズム番号"
    },
    {
      "indent": 3,
      "text": "A number of algorithm IDs have been reserved for algorithms that would be useful to use in an OpenPGP implementation, yet there are issues that prevent an implementer from actually implementing the algorithm. These are marked in Section 9.1, \"Public-Key Algorithms\", as \"reserved for\".",
      "ja": "いくつかのアルゴリズムIDは、OpenPGP実装での使用に役立つアルゴリズム用に予約されていますが、実装者が実際にアルゴリズムを実装できない問題があります。これらは、「予約済み」としてセクション9.1「公開鍵アルゴリズム」でマークされています。"
    },
    {
      "indent": 3,
      "text": "The reserved public-key algorithms, Elliptic Curve (18), ECDSA (19), and X9.42 (21), do not have the necessary parameters, parameter order, or semantics defined.",
      "ja": "予約済みの公開鍵アルゴリズムである楕円曲線（18）、ECDSA（19）、およびX9.42（21）には、必要なパラメーター、パラメーターの順序、またはセマンティクスが定義されていません。"
    },
    {
      "indent": 3,
      "text": "Previous versions of OpenPGP permitted Elgamal [ELGAMAL] signatures with a public-key identifier of 20. These are no longer permitted. An implementation MUST NOT generate such keys. An implementation MUST NOT generate Elgamal signatures. See [BLEICHENBACHER].",
      "ja": "OpenPGPの以前のバージョンでは、公開鍵識別子が20のElgamal [ELGAMAL]署名が許可されていました。これらは許可されなくなりました。実装はそのようなキーを生成してはいけません。実装はElgamal署名を生成してはなりません（MUST NOT）。 [BLEICHENBACHER]を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.9. OpenPGP CFB Mode",
      "section_title": true,
      "ja": "13.9. OpenPGP CFBモード"
    },
    {
      "indent": 3,
      "text": "OpenPGP does symmetric encryption using a variant of Cipher Feedback mode (CFB mode). This section describes the procedure it uses in detail. This mode is what is used for Symmetrically Encrypted Data Packets; the mechanism used for encrypting secret-key material is similar, and is described in the sections above.",
      "ja": "OpenPGPは、暗号フィードバックモード（CFBモード）のバリアントを使用して対称暗号化を行います。このセクションでは、使用する手順について詳しく説明します。このモードは、対称的に暗号化されたデータパケットに使用されるものです。秘密鍵マテリアルの暗号化に使用されるメカニズムは類似しており、上記のセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "In the description below, the value BS is the block size in octets of the cipher. Most ciphers have a block size of 8 octets. The AES and Twofish have a block size of 16 octets. Also note that the description below assumes that the IV and CFB arrays start with an index of 1 (unlike the C language, which assumes arrays start with a zero index).",
      "ja": "以下の説明では、値BSは暗号のオクテット単位のブロックサイズです。ほとんどの暗号のブロックサイズは8オクテットです。 AESとTwofishのブロックサイズは16オクテットです。また、以下の説明では、IV配列とCFB配列が1のインデックスで始まることを前提としています（C言語とは異なり、配列はゼロのインデックスで始まると想定しています）。"
    },
    {
      "indent": 3,
      "text": "OpenPGP CFB mode uses an initialization vector (IV) of all zeros, and prefixes the plaintext with BS+2 octets of random data, such that octets BS+1 and BS+2 match octets BS-1 and BS. It does a CFB resynchronization after encrypting those BS+2 octets.",
      "ja": "OpenPGP CFBモードは、すべてゼロの初期化ベクトル（IV）を使用し、プレーンテキストの前にランダムデータのBS + 2オクテットを付け、オクテットBS + 1およびBS + 2がオクテットBS-1およびBSと一致するようにします。これらのBS + 2オクテットを暗号化した後、CFBの再同期を行います。"
    },
    {
      "indent": 3,
      "text": "Thus, for an algorithm that has a block size of 8 octets (64 bits), the IV is 10 octets long and octets 7 and 8 of the IV are the same as octets 9 and 10. For an algorithm with a block size of 16 octets (128 bits), the IV is 18 octets long, and octets 17 and 18 replicate octets 15 and 16. Those extra two octets are an easy check for a correct key.",
      "ja": "したがって、8オクテット（64ビット）のブロックサイズを持つアルゴリズムの場合、IVは10オクテット長であり、IVのオクテット7および8はオクテット9および10と同じです。ブロックサイズが16のアルゴリズムの場合オクテット（128ビット）、IVは18オクテット長、オクテット17と18はオクテット15と16を複製します。これらの追加の2オクテットは、正しいキーの簡単なチェックです。"
    },
    {
      "indent": 3,
      "text": "Step by step, here is the procedure:",
      "ja": "ステップバイステップ、これが手順です："
    },
    {
      "indent": 3,
      "text": "1. The feedback register (FR) is set to the IV, which is all zeros.",
      "ja": "1. フィードバックレジスタ（FR）はIVに設定されます。IVはすべてゼロです。"
    },
    {
      "indent": 3,
      "text": "2. FR is encrypted to produce FRE (FR Encrypted). This is the encryption of an all-zero value.",
      "ja": "2. FRは暗号化されてFRE（FR Encrypted）を生成します。これはすべてゼロの値の暗号化です。"
    },
    {
      "indent": 3,
      "text": "3. FRE is xored with the first BS octets of random data prefixed to the plaintext to produce C[1] through C[BS], the first BS octets of ciphertext.",
      "ja": "3. 暗号文の最初のBSオクテットであるC [1]からC [BS]を生成するために、FREは、プレーンテキストにプレフィックスが付けられたランダムデータの最初のBSオクテットでxorされます。"
    },
    {
      "indent": 3,
      "text": "4. FR is loaded with C[1] through C[BS].",
      "ja": "4. FRにはC [1]〜C [BS]がロードされます。"
    },
    {
      "indent": 3,
      "text": "5. FR is encrypted to produce FRE, the encryption of the first BS octets of ciphertext.",
      "ja": "5. FRは暗号化されて、暗号文の最初のBSオクテットの暗号化であるFREを生成します。"
    },
    {
      "indent": 3,
      "text": "6. The left two octets of FRE get xored with the next two octets of data that were prefixed to the plaintext. This produces C[BS+1] and C[BS+2], the next two octets of ciphertext.",
      "ja": "6. FREの左の2オクテットは、プレーンテキストのプレフィックスが付けられた次の2オクテットのデータとxorされます。これにより、暗号文の次の2オクテットであるC [BS + 1]とC [BS + 2]が生成されます。"
    },
    {
      "indent": 3,
      "text": "7. (The resynchronization step) FR is loaded with C[3] through C[BS+2].",
      "ja": "7. （再同期ステップ）FRには、C [3]〜C [BS + 2]がロードされます。"
    },
    {
      "indent": 3,
      "text": "8. FR is encrypted to produce FRE.",
      "ja": "8. FRはFREを生成するために暗号化されます。"
    },
    {
      "indent": 3,
      "text": "9. FRE is xored with the first BS octets of the given plaintext, now that we have finished encrypting the BS+2 octets of prefixed data. This produces C[BS+3] through C[BS+(BS+2)], the next BS octets of ciphertext.",
      "ja": "9. FREは、プレフィックス付きデータのBS + 2オクテットの暗号化を完了したので、指定された平文の最初のBSオクテットとxorされます。これにより、暗号文の次のBSオクテットであるC [BS + 3]からC [BS +（BS + 2）]が生成されます。"
    },
    {
      "indent": 3,
      "text": "10. FR is loaded with C[BS+3] to C[BS + (BS+2)] (which is C11-C18 for an 8-octet block).",
      "ja": "10. FRにはC [BS + 3]からC [BS +（BS + 2）]（8オクテットブロックの場合はC11-C18）がロードされます。"
    },
    {
      "indent": 7,
      "text": "11. FR is encrypted to produce FRE.",
      "ja": "11. FRはFREを生成するために暗号化されます。"
    },
    {
      "indent": 7,
      "text": "12. FRE is xored with the next BS octets of plaintext, to produce the next BS octets of ciphertext. These are loaded into FR, and the process is repeated until the plaintext is used up.",
      "ja": "12. FREは、平文の次のBSオクテットとxorされて、暗号文の次のBSオクテットを生成します。これらはFRにロードされ、プレーンテキストが使い果たされるまでこのプロセスが繰り返されます。"
    },
    {
      "indent": 0,
      "text": "13.10. Private or Experimental Parameters",
      "section_title": true,
      "ja": "13.10. プライベートまたは実験パラメータ"
    },
    {
      "indent": 3,
      "text": "S2K specifiers, Signature subpacket types, user attribute types, image format types, and algorithms described in Section 9 all reserve the range 100 to 110 for private and experimental use. Packet types reserve the range 60 to 63 for private and experimental use. These are intentionally managed with the PRIVATE USE method, as described in [RFC2434].",
      "ja": "S2K指定子、署名サブパケットタイプ、ユーザー属性タイプ、画像フォーマットタイプ、およびセクション9で説明されているアルゴリズムはすべて、プライベートおよび実験的使用のために100〜110の範囲を予約しています。パケットタイプは、プライベートおよび実験用に60〜63の範囲を予約します。これらは、[RFC2434]で説明されているように、PRIVATE USEメソッドで意図的に管理されます。"
    },
    {
      "indent": 3,
      "text": "However, implementations need to be careful with these and promote them to full IANA-managed parameters when they grow beyond the original, limited system.",
      "ja": "ただし、実装はこれらに注意し、元の限られたシステムを超えて成長したときに、IANA管理の完全なパラメーターにそれらを昇格する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.11. Extension of the MDC System",
      "section_title": true,
      "ja": "13.11. MDCシステムの拡張"
    },
    {
      "indent": 3,
      "text": "As described in the non-normative explanation in Section 5.13, the MDC system is uniquely unparameterized in OpenPGP. This was an intentional decision to avoid cross-grade attacks. If the MDC system is extended to a stronger hash function, care must be taken to avoid downgrade and cross-grade attacks.",
      "ja": "セクション5.13の非規範的な説明で説明されているように、MDCシステムはOpenPGPで一意にパラメーター化されていません。これは、クロスグレード攻撃を回避するための意図的な決定でした。 MDCシステムがより強力なハッシュ関数に拡張される場合、ダウングレードおよびクロスグレードの攻撃を回避するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "One simple way to do this is to create new packets for a new MDC. For example, instead of the MDC system using packets 18 and 19, a new MDC could use 20 and 21. This has obvious drawbacks (it uses two packet numbers for each new hash function in a space that is limited to a maximum of 60).",
      "ja": "これを行う簡単な方法の1つは、新しいMDC用の新しいパケットを作成することです。たとえば、パケット18と19を使用するMDCシステムの代わりに、新しいMDCは20と21を使用できます。これには明らかな欠点があります（最大60に制限されているスペース内の新しいハッシュ関数ごとに2つのパケット番号を使用します）。 。"
    },
    {
      "indent": 3,
      "text": "Another simple way to extend the MDC system is to create new versions of packet 18, and reflect this in packet 19. For example, suppose that V2 of packet 18 implicitly used SHA-256. This would require packet 19 to have a length of 32 octets. The change in the version in packet 18 and the size of packet 19 prevent a downgrade attack.",
      "ja": "MDCシステムを拡張するもう1つの簡単な方法は、パケット18の新しいバージョンを作成し、これをパケット19に反映することです。たとえば、パケット18のV2が暗黙的にSHA-256を使用したとします。これには、パケット19の長さが32オクテットである必要があります。パケット18のバージョンとパケット19のサイズの変更により、ダウングレード攻撃が防止されます。"
    },
    {
      "indent": 3,
      "text": "There are two drawbacks to this latter approach. The first is that using the version number of a packet to carry algorithm information is not tidy from a protocol-design standpoint. It is possible that there might be several versions of the MDC system in common use, but this untidiness would reflect untidiness in cryptographic consensus about hash function security. The second is that different versions of packet 19 would have to have unique sizes. If there were two versions each with 256-bit hashes, they could not both have 32-octet packet 19s without admitting the chance of a cross-grade attack.",
      "ja": "この後者のアプローチには2つの欠点があります。 1つ目は、パケットのバージョン番号を使用してアルゴリズム情報を伝達することは、プロトコル設計の観点からすっきりしないことです。一般的に使用されているMDCシステムの複数のバージョンが存在する可能性がありますが、このあいまいさは、ハッシュ関数のセキュリティに関する暗号コンセンサスのあいまいさを反映しています。 2つ目は、異なるバージョンのパケット19は一意のサイズを持つ必要があるということです。それぞれが256ビットのハッシュを持つ2つのバージョンがある場合、クロスグレード攻撃の可能性を認めずに、両方に32オクテットのパケット19を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "Yet another, complex approach to extend the MDC system would be a hybrid of the two above -- create a new pair of MDC packets that are fully parameterized, and yet protected from downgrade and cross-grade.",
      "ja": "MDCシステムを拡張するさらにもう1つの複雑なアプローチは、上記の2つのハイブリッドです。完全にパラメーター化され、ダウングレードやクロスグレードから保護されたMDCパケットの新しいペアを作成します。"
    },
    {
      "indent": 3,
      "text": "Any change to the MDC system MUST be done through the IETF CONSENSUS method, as described in [RFC2434].",
      "ja": "[RFC2434]で説明されているように、MDCシステムへの変更はIETF CONSENSUSメソッドを介して行う必要があります。"
    },
    {
      "indent": 0,
      "text": "13.12. Meta-Considerations for Expansion",
      "section_title": true,
      "ja": "13.12. 拡張のためのメタ考察"
    },
    {
      "indent": 0,
      "text": " If OpenPGP is extended in a way that is not backwards-compatible, meaning that old implementations will not gracefully handle their absence of a new feature, the extension proposal can be declared in the key holder's self-signature as part of the Features signature subpacket.",
      "ja": "OpenPGPが下位互換性のない方法で拡張される場合、つまり、古い実装が新しい機能の欠如を適切に処理できない場合、拡張提案は、機能署名サブパケットの一部としてキーホルダーの自己署名で宣言できます。"
    },
    {
      "indent": 3,
      "text": "We cannot state definitively what extensions will not be upwards-compatible, but typically new algorithms are upwards-compatible, whereas new packets are not.",
      "ja": "どの拡張機能が上位互換性がないかを明確に述べることはできませんが、通常、新しいアルゴリズムは上位互換性がありますが、新しいパケットはそうではありません。"
    },
    {
      "indent": 3,
      "text": "If an extension proposal does not update the Features system, it SHOULD include an explanation of why this is unnecessary. If the proposal contains neither an extension to the Features system nor an explanation of why such an extension is unnecessary, the proposal SHOULD be rejected.",
      "ja": "拡張提案が機能システムを更新しない場合、これがなぜ不必要であるかの説明を含める必要があります。提案にフィーチャーズシステムへの拡張も、そのような拡張が不要である理由の説明も含まれていない場合、提案は拒否されるべきです。"
    },
    {
      "indent": 0,
      "text": "14. Security Considerations",
      "section_title": true,
      "ja": "14. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "* As with any technology involving cryptography, you should check the current literature to determine if any algorithms used here have been found to be vulnerable to attack.",
      "ja": "* 暗号化を含む他のテクノロジーと同様に、現在の文献をチェックして、ここで使用されているアルゴリズムが攻撃に対して脆弱であることが判明したかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "* This specification uses Public-Key Cryptography technologies. It is assumed that the private key portion of a public-private key pair is controlled and secured by the proper party or parties.",
      "ja": "* この仕様では、公開鍵暗号化技術を使用しています。公開鍵と秘密鍵のペアの秘密鍵部分は、適切な当事者によって制御および保護されていると想定されています。"
    },
    {
      "indent": 3,
      "text": "* Certain operations in this specification involve the use of random numbers. An appropriate entropy source should be used to generate these numbers (see [RFC4086]).",
      "ja": "* この仕様の特定の操作には、乱数の使用が含まれます。これらの数値を生成するには、適切なエントロピーソースを使用する必要があります（[RFC4086]を参照）。"
    },
    {
      "indent": 3,
      "text": "* The MD5 hash algorithm has been found to have weaknesses, with collisions found in a number of cases. MD5 is deprecated for use in OpenPGP. Implementations MUST NOT generate new signatures using MD5 as a hash function. They MAY continue to consider old signatures that used MD5 as valid.",
      "ja": "* MD5ハッシュアルゴリズムには弱点があり、多くの場合衝突が見られます。 MD5はOpenPGPでの使用が非推奨です。実装は、ハッシュ関数としてMD5を使用して新しい署名を生成してはなりません（MUST NOT）。彼らは引き続き、MD5を使用した古い署名を有効であると見なします。"
    },
    {
      "indent": 3,
      "text": "* SHA-224 and SHA-384 require the same work as SHA-256 and SHA-512, respectively. In general, there are few reasons to use them outside of DSS compatibility. You need a situation where one needs more security than smaller hashes, but does not want to have the full 256-bit or 512-bit data length.",
      "ja": "* SHA-224およびSHA-384には、それぞれSHA-256およびSHA-512と同じ作業が必要です。一般に、DSSの互換性以外で使用する理由はほとんどありません。小さなハッシュよりも多くのセキュリティが必要であるが、完全な256ビットまたは512ビットのデータ長を必要としない状況が必要です。"
    },
    {
      "indent": 3,
      "text": "* Many security protocol designers think that it is a bad idea to use a single key for both privacy (encryption) and integrity (signatures). In fact, this was one of the motivating forces behind the V4 key format with separate signature and encryption keys. If you as an implementer promote dual-use keys, you should at least be aware of this controversy.",
      "ja": "* 多くのセキュリティプロトコル設計者は、プライバシー（暗号化）と整合性（署名）の両方に単一のキーを使用することは悪い考えであると考えています。実際、これは、個別の署名キーと暗号化キーを持つV4キー形式の背後にある動機の1つでした。実装者として二重使用キーを宣伝する場合は、少なくともこの論争に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The DSA algorithm will work with any hash, but is sensitive to the quality of the hash algorithm. Verifiers should be aware that even if the signer used a strong hash, an attacker could have modified the signature to use a weak one. Only signatures using acceptably strong hash algorithms should be accepted as valid.",
      "ja": "* DSAアルゴリズムはどのハッシュでも機能しますが、ハッシュアルゴリズムの品質に敏感です。検証者は、署名者が強力なハッシュを使用していたとしても、攻撃者が弱い署名を使用するように署名を変更した可能性があることに注意する必要があります。許容できるほど強力なハッシュアルゴリズムを使用する署名のみが有効として受け入れられる必要があります。"
    },
    {
      "indent": 3,
      "text": "* As OpenPGP combines many different asymmetric, symmetric, and hash algorithms, each with different measures of strength, care should be taken that the weakest element of an OpenPGP message is still sufficiently strong for the purpose at hand. While consensus about the strength of a given algorithm may evolve, NIST Special Publication 800-57 [SP800-57] recommends the following list of equivalent strengths:",
      "ja": "* OpenPGPは多くの異なる非対称、対称、およびハッシュアルゴリズムを組み合わせており、それぞれが強度の異なる測定値を持っているため、OpenPGPメッセージの最も弱い要素がまだ目前の目的に十分に強いことに注意する必要があります。特定のアルゴリズムの強さについてのコンセンサスは進化する可能性がありますが、NIST Special Publication 800-57 [SP800-57]は、以下の同等の強さのリストを推奨しています。"
    },
    {
      "indent": 11,
      "text": "Asymmetric  |  Hash  |  Symmetric\n key size   |  size  |   key size\n------------+--------+-----------\n   1024        160         80\n   2048        224        112\n   3072        256        128\n   7680        384        192\n  15360        512        256",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* There is a somewhat-related potential security problem in signatures. If an attacker can find a message that hashes to the same hash with a different algorithm, a bogus signature structure can be constructed that evaluates correctly.",
      "ja": "* 署名には、いくぶん関連する潜在的なセキュリティ問題があります。攻撃者が別のアルゴリズムで同じハッシュにハッシュするメッセージを見つけた場合、正しく評価される偽の署名構造を構築できます。"
    },
    {
      "indent": 5,
      "text": "For example, suppose Alice DSA signs message M using hash algorithm H. Suppose that Mallet finds a message M' that has the same hash value as M with H'. Mallet can then construct a signature block that verifies as Alice's signature of M' with H'. However, this would also constitute a weakness in either H or H' or both. Should this ever occur, a revision will have to be made to this document to revise the allowed hash algorithms.",
      "ja": "たとえば、アリスDSAがハッシュアルゴリズムHを使用してメッセージMに署名するとします。マレットがMとH 'と同じハッシュ値を持つメッセージM'を見つけたとします。次に、マレットは、アリスのM 'とH'の署名として検証する署名ブロックを作成できます。ただし、これはHまたはH '、あるいはその両方の弱点にもなります。これが発生した場合、許可されたハッシュアルゴリズムを改訂するために、このドキュメントに改訂を加える必要があります。"
    },
    {
      "indent": 3,
      "text": "* If you are building an authentication system, the recipient may specify a preferred signing algorithm. However, the signer would be foolish to use a weak algorithm simply because the recipient requests it.",
      "ja": "* 認証システムを構築している場合、受信者は優先署名アルゴリズムを指定できます。ただし、署名者が弱いアルゴリズムを使用するのは、受信者がそれを要求するというだけの理由でばかげています。"
    },
    {
      "indent": 3,
      "text": "* Some of the encryption algorithms mentioned in this document have been analyzed less than others. For example, although CAST5 is presently considered strong, it has been analyzed less than TripleDES. Other algorithms may have other controversies surrounding them.",
      "ja": "* このドキュメントで言及されている暗号化アルゴリズムの一部は、他のアルゴリズムよりも分析が不十分です。たとえば、CAST5は現在強力であると見なされていますが、TripleDESよりも分析が不十分です。他のアルゴリズムはそれらを取り巻く他の論争を持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "* In late summer 2002, Jallad, Katz, and Schneier published an interesting attack on the OpenPGP protocol and some of its implementations [JKS02]. In this attack, the attacker modifies a message and sends it to a user who then returns the erroneously decrypted message to the attacker. The attacker is thus using the user as a random oracle, and can often decrypt the message.",
      "ja": "* 2002年の夏の終わりに、Jallad、Katz、およびSchneierは、OpenPGPプロトコルとその実装の一部に対する興味深い攻撃を公開しました[JKS02]。この攻撃では、攻撃者はメッセージを変更してユーザーに送信し、ユーザーは誤って復号化されたメッセージを攻撃者に返します。したがって、攻撃者はユーザーをランダムなオラクルとして使用しており、メッセージを解読できることがよくあります。"
    },
    {
      "indent": 5,
      "text": "Compressing data can ameliorate this attack. The incorrectly decrypted data nearly always decompresses in ways that defeat the attack. However, this is not a rigorous fix, and leaves open some small vulnerabilities. For example, if an implementation does not compress a message before encryption (perhaps because it knows it was already compressed), then that message is vulnerable. Because of this happenstance -- that modification attacks can be thwarted by decompression errors -- an implementation SHOULD treat a decompression error as a security problem, not merely a data problem.",
      "ja": "データを圧縮すると、この攻撃を緩和できます。誤って復号化されたデータは、ほとんどの場合、攻撃に対抗する方法で解凍されます。ただし、これは厳密な修正ではなく、いくつかの小さな脆弱性が残っています。たとえば、実装が暗号化前にメッセージを圧縮しない場合（おそらく、メッセージが既に圧縮されていることがわかっているため）、そのメッセージは脆弱です。この偶然のために-その変更攻撃は解凍エラーによって阻止されることができます-実装は解凍エラーを単なるデータ問題ではなくセキュリティ問題として扱うべきです（SHOULD）。"
    },
    {
      "indent": 5,
      "text": "This attack can be defeated by the use of Modification Detection, provided that the implementation does not let the user naively return the data to the attacker. An implementation MUST treat an MDC failure as a security problem, not merely a data problem.",
      "ja": "この攻撃は、モディフィケーション検出を使用して無効にすることができます。ただし、実装では、ユーザーがデータを攻撃者に単純に返すことはできません。実装はMDC障害を単なるデータ問題ではなくセキュリティ問題として扱わなければなりません（MUST）。"
    },
    {
      "indent": 5,
      "text": "In either case, the implementation MAY allow the user access to the erroneous data, but MUST warn the user as to potential security problems should that data be returned to the sender.",
      "ja": "どちらの場合でも、実装はユーザーに誤ったデータへのアクセスを許可するかもしれませんが、データが送信者に返された場合の潜在的なセキュリティ問題についてユーザーに警告しなければなりません（MUST）。"
    },
    {
      "indent": 5,
      "text": "While this attack is somewhat obscure, requiring a special set of circumstances to create it, it is nonetheless quite serious as it permits someone to trick a user to decrypt a message. Consequently, it is important that:",
      "ja": "この攻撃はややあいまいであり、作成するために特別な一連の状況を必要としますが、ユーザーをだましてメッセージを解読させることができるため、非常に深刻です。したがって、次のことが重要です。"
    },
    {
      "indent": 6,
      "text": "1. Implementers treat MDC errors and decompression failures as security problems.",
      "ja": "1. 実装者は、MDCエラーと解凍の失敗をセキュリティの問題として扱います。"
    },
    {
      "indent": 6,
      "text": "2. Implementers implement Modification Detection with all due speed and encourage its spread.",
      "ja": "2. 実装者は修正検出をあらゆる速度で実装し、その普及を促進します。"
    },
    {
      "indent": 6,
      "text": "3. Users migrate to implementations that support Modification Detection with all due speed.",
      "ja": "3. ユーザーは修正検出をサポートする実装にすべての速度で移行します。"
    },
    {
      "indent": 3,
      "text": "* PKCS#1 has been found to be vulnerable to attacks in which a system that reports errors in padding differently from errors in decryption becomes a random oracle that can leak the private key in mere millions of queries. Implementations must be aware of this attack and prevent it from happening. The simplest solution is to report a single error code for all variants of decryption errors so as not to leak information to an attacker.",
      "ja": "* PKCS＃1は、パディングのエラーを復号化のエラーとは異なる方法で報告するシステムがランダムなオラクルになり、数百万のクエリで秘密鍵をリークできる攻撃に対して脆弱であることが判明しています。実装はこの攻撃を認識し、それが起こらないようにする必要があります。最も簡単な解決策は、攻撃者に情報を漏らさないように、すべての種類の復号化エラーの単一のエラーコードを報告することです。"
    },
    {
      "indent": 3,
      "text": "* Some technologies mentioned here may be subject to government control in some countries.",
      "ja": "* ここで言及されているテクノロジーの中には、国によっては政府の管理下にあるものがあります。"
    },
    {
      "indent": 3,
      "text": "* In winter 2005, Serge Mister and Robert Zuccherato from Entrust released a paper describing a way that the \"quick check\" in OpenPGP CFB mode can be used with a random oracle to decrypt two octets of every cipher block [MZ05]. They recommend as prevention not using the quick check at all.",
      "ja": "* 2005年冬、EntrustのSerge MisterとRobert Zuccheratoが、OpenPGP CFBモードの「クイックチェック」をランダムオラクルで使用して、すべての暗号ブロックの2オクテットを復号化する方法を説明した論文を発表しました[MZ05]。クイックチェックを一切使わない防止策としてお勧めです。"
    },
    {
      "indent": 5,
      "text": "Many implementers have taken this advice to heart for any data that is symmetrically encrypted and for which the session key is public-key encrypted. In this case, the quick check is not needed as the public-key encryption of the session key should guarantee that it is the right session key. In other cases, the implementation should use the quick check with care.",
      "ja": "多くの実装者は、対称的に暗号化され、セッションキーが公開キーで暗号化されているすべてのデータについて、このアドバイスを心に留めています。この場合、セッションキーの公開キー暗号化が正しいセッションキーであることを保証する必要があるため、クイックチェックは必要ありません。それ以外の場合、実装ではクイックチェックを注意して使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "On the one hand, there is a danger to using it if there is a random oracle that can leak information to an attacker. In plainer language, there is a danger to using the quick check if timing information about the check can be exposed to an attacker, particularly via an automated service that allows rapidly repeated queries.",
      "ja": "一方で、情報を攻撃者に漏らす可能性のあるランダムなオラクルがある場合、それを使用する危険があります。わかりやすい言葉では、特にチェックの迅速な繰り返しを可能にする自動化サービスを介して、チェックに関するタイミング情報が攻撃者に公開される可能性がある場合、クイックチェックを使用することは危険です。"
    },
    {
      "indent": 5,
      "text": "On the other hand, it is inconvenient to the user to be informed that they typed in the wrong passphrase only after a petabyte of data is decrypted. There are many cases in cryptographic engineering where the implementer must use care and wisdom, and this is one.",
      "ja": "一方、ペタバイトのデータが復号化された後にのみ、ユーザーが間違ったパスフレーズを入力したことをユーザーに通知するのは不便です。暗号工学では、実装者が注意と知恵を使わなければならない場合が多く、これはその1つです。"
    },
    {
      "indent": 0,
      "text": "15. Implementation Nits",
      "section_title": true,
      "ja": "15. 実装のNit"
    },
    {
      "indent": 3,
      "text": "This section is a collection of comments to help an implementer, particularly with an eye to backward compatibility. Previous implementations of PGP are not OpenPGP compliant. Often the differences are small, but small differences are frequently more vexing than large differences. Thus, this is a non-comprehensive list of potential problems and gotchas for a developer who is trying to be backward-compatible.",
      "ja": "このセクションは、特に下位互換性を考慮して実装者を支援するコメントのコレクションです。 PGPの以前の実装はOpenPGPに準拠していません。多くの場合、違いはわずかですが、小さな違いは大きな違いよりもしばしば厄介です。したがって、これは潜在的な問題の非包括的リストであり、下位互換性を保とうとする開発者にとっての落とし穴です。"
    },
    {
      "indent": 5,
      "text": "* The IDEA algorithm is patented, and yet it is required for PGP 2.x interoperability. It is also the de-facto preferred algorithm for a V3 key with a V3 self-signature (or no self-signature).",
      "ja": "* IDEAアルゴリズムは特許を取得していますが、PGP 2.xの相互運用性のために必要です。これは、V3自己署名付き（または自己署名なし）のV3鍵の事実上好ましいアルゴリズムでもあります。"
    },
    {
      "indent": 5,
      "text": "* When exporting a private key, PGP 2.x generates the header \"BEGIN PGP SECRET KEY BLOCK\" instead of \"BEGIN PGP PRIVATE KEY BLOCK\". All previous versions ignore the implied data type, and look directly at the packet data type.",
      "ja": "* 秘密鍵をエクスポートすると、PGP 2.xは「BEGIN PGP PRIVATE KEY BLOCK」ではなく「BEGIN PGP SECRET KEY BLOCK」というヘッダーを生成します。以前のバージョンはすべて暗黙のデータタイプを無視し、パケットデータタイプを直接調べます。"
    },
    {
      "indent": 5,
      "text": "* PGP 2.0 through 2.5 generated V2 Public-Key packets. These are identical to the deprecated V3 keys except for the version number. An implementation MUST NOT generate them and may accept or reject them as it sees fit. Some older PGP versions generated V2 PKESK packets (Tag 1) as well. An implementation may accept or reject V2 PKESK packets as it sees fit, and MUST NOT generate them.",
      "ja": "* PGP 2.0〜2.5で生成されたV2公開鍵パケット。これらは、バージョン番号を除いて、非推奨のV3キーと同じです。実装はそれらを生成してはならず（MUST NOT）、それらが適切と思われる場合にそれらを受け入れるか拒否することができます。一部の古いPGPバージョンは、V2 PKESKパケット（タグ1）も生成しました。実装は、適切と思われるV2 PKESKパケットを受け入れまたは拒否する場合があり、それらを生成してはならない（MUST NOT）。"
    },
    {
      "indent": 5,
      "text": "* PGP 2.6.x will not accept key-material packets with versions greater than 3.",
      "ja": "* PGP 2.6.xは、バージョン3以降のキーマテリアルパケットを受け入れません。"
    },
    {
      "indent": 5,
      "text": "* There are many ways possible for two keys to have the same key material, but different fingerprints (and thus Key IDs). Perhaps the most interesting is an RSA key that has been \"upgraded\" to V4 format, but since a V4 fingerprint is constructed by hashing the key creation time along with other things, two V4 keys created at different times, yet with the same key material will have different fingerprints.",
      "ja": "* 2つのキーが同じキーマテリアルを持ち、フィンガープリント（およびキーID）が異なるようにする方法は多数あります。おそらく最も興味深いのは、V4形式に「アップグレード」されたRSAキーですが、V4フィンガープリントはキーの作成時間を他のものと一緒にハッシュすることによって構築されるため、2つのV4キーは異なる時間に作成されますが、同じキーマテリアルを使用します指紋が異なります。"
    },
    {
      "indent": 5,
      "text": "* If an implementation is using zlib to interoperate with PGP 2.x, then the \"windowBits\" parameter should be set to -13.",
      "ja": "* 実装がzlibを使用してPGP 2.xと相互運用する場合、「windowBits」パラメーターを-13に設定する必要があります。"
    },
    {
      "indent": 5,
      "text": "* The 0x19 back signatures were not required for signing subkeys until relatively recently. Consequently, there may be keys in the wild that do not have these back signatures. Implementing software may handle these keys as it sees fit.",
      "ja": "* 比較的最近まで、サブキーの署名には0x19バック署名は必要ありませんでした。その結果、これらのバックシグネチャを持たない実際のキーが存在する可能性があります。実装ソフトウェアは、適切と思われるようにこれらのキーを処理します。"
    },
    {
      "indent": 5,
      "text": "* OpenPGP does not put limits on the size of public keys. However, larger keys are not necessarily better keys. Larger keys take more computation time to use, and this can quickly become impractical. Different OpenPGP implementations may also use different upper bounds for public key sizes, and so care should be taken when choosing sizes to maintain interoperability. As of 2007 most implementations have an upper bound of 4096 bits.",
      "ja": "* OpenPGPは公開鍵のサイズに制限を設けていません。ただし、大きなキーは必ずしも優れたキーであるとは限りません。キーが大きいほど、使用する計算時間が長くなり、これはすぐに実用的でなくなる可能性があります。異なるOpenPGP実装では、公開鍵のサイズに異なる上限を使用する場合があるため、相互運用性を維持するためにサイズを選択するときには注意が必要です。 2007年の時点で、ほとんどの実装の上限は4096ビットです。"
    },
    {
      "indent": 0,
      "text": " * ASCII armor is an optional feature of OpenPGP. The OpenPGP working group strives for a minimal set of mandatory-to-implement features, and since there could be useful implementations that only use binary object formats, this is not a \"MUST\" feature for an implementation. For example, an implementation that is using OpenPGP as a mechanism for file signatures may find ASCII armor unnecessary. OpenPGP permits an implementation to declare what features it does and does not support, but ASCII armor is not one of these. Since most implementations allow binary and armored objects to be used indiscriminately, an implementation that does not implement ASCII armor may find itself with compatibility issues with general-purpose implementations. Moreover, implementations of OpenPGP-MIME [RFC3156] already have a requirement for ASCII armor so those implementations will necessarily have support.",
      "ja": "* ASCIIアーマーはOpenPGPのオプション機能です。 OpenPGPワーキンググループは、実装に必須の機能の最小限のセットを目指しており、バイナリオブジェクト形式のみを使用する有用な実装が存在する可能性があるため、これは実装の「必須」機能ではありません。たとえば、ファイル署名のメカニズムとしてOpenPGPを使用している実装では、ASCII鎧が不要な場合があります。 OpenPGPは、実装がどの機能をサポートしていないかを宣言することを許可しますが、ASCIIアーマーはこれらの1つではありません。ほとんどの実装ではバイナリオブジェクトと装甲オブジェクトを無差別に使用できるため、ASCII鎧を実装しない実装では、汎用実装との互換性の問題が発生する可能性があります。さらに、OpenPGP-MIME [RFC3156]の実装にはすでにASCIIアーマーの要件があるため、これらの実装は必ずサポートされます。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES]            NIST, FIPS PUB 197, \"Advanced Encryption Standard\n                 (AES),\" November 2001.\n                 http://csrc.nist.gov/publications/fips/fips197/fips-\n                 197.{ps,pdf}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[BLOWFISH] Schneier, B. \"Description of a New Variable-Length Key, 64-Bit Block Cipher (Blowfish)\" Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp191-204 <http://www.counterpane.com/bfsverlag.html>",
      "ja": "[BLOWFISH] Schneier、B。「新しい可変長キーの説明、64ビットブロック暗号（Blowfish）」Fast Software Encryption、Cambridge Security Workshop Proceedings（1993年12月）、Springer-Verlag、1994、pp191-204 <http ：//www.counterpane.com/bfsverlag.html>"
    },
    {
      "indent": 3,
      "text": "[BZ2]            J. Seward, jseward@acm.org, \"The Bzip2 and libbzip2\n                 home page\" <http://www.bzip.org/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ELGAMAL] T. Elgamal, \"A Public-Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms,\" IEEE Transactions on Information Theory, v. IT-31, n. 4, 1985, pp. 469-472.",
      "ja": "[ELGAMAL] T. Elgamal、「公開鍵暗号システムと離散対数に基づく署名方式」、IEEE Transactions on Information Theory、v。IT-31、n。 4、1985、pp。469-472。"
    },
    {
      "indent": 3,
      "text": "[FIPS180]        Secure Hash Signature Standard (SHS) (FIPS PUB 180-\n                 2).\n                 <http://csrc.nist.gov/publications/fips/fips180-\n                 2/fips180-2withchangenotice.pdf>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FIPS186]        Digital Signature Standard (DSS) (FIPS PUB 186-2).\n                 <http://csrc.nist.gov/publications/fips/fips186-2/\n                  fips186-2-change1.pdf> FIPS 186-3 describes keys\n                 greater than 1024 bits.  The latest draft is at:\n                 <http://csrc.nist.gov/publications/drafts/\n                 fips_186-3/Draft-FIPS-186-3%20_March2006.pdf>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[HAC]            Alfred Menezes, Paul van Oorschot, and Scott\n                 Vanstone, \"Handbook of Applied Cryptography,\" CRC\n                 Press, 1996.\n                 <http://www.cacr.math.uwaterloo.ca/hac/>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[IDEA] Lai, X, \"On the design and security of block ciphers\", ETH Series in Information Processing, J.L. Massey (editor), Vol. 1, Hartung-Gorre Verlag Knostanz, Technische Hochschule (Zurich), 1992",
      "ja": "[IDEA] Lai、X、「ブロック暗号の設計とセキュリティについて」、情報処理のETHシリーズ、J.L。Massey（編集者）、Vol。 1、Hartung-Gorre Verlag Knostanz、Technische Hochschule（チューリッヒ）、1992"
    },
    {
      "indent": 3,
      "text": "[ISO10646] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane.",
      "ja": "[ISO10646] ISO / IEC 10646-1：1993。国際標準-情報技術-ユニバーサル複数オクテットコード化文字セット（UCS）-パート1：アーキテクチャと基本的な多言語プレーン。"
    },
    {
      "indent": 3,
      "text": "[JFIF] JPEG File Interchange Format (Version 1.02). Eric Hamilton, C-Cube Microsystems, Milpitas, CA, September 1, 1992.",
      "ja": "[JFIF] JPEGファイル交換形式（バージョン1.02）。エリックハミルトン、C-Cube Microsystems、カリフォルニア州ミルピタス、1992年9月1日。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, P. and J-L. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950] Deutsch、P. and J-L。ゲイリー、「ZLIB圧縮データ形式仕様バージョン3.3」、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[RFC1951] Deutsch、P。、「DEFLATE Compressed Data Format Specification version 1.3」、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996",
      "ja": "[RFC2045] Freed、N。およびN. Borenstein、「Multipurpose Internet Mail Extensions（MIME）Part One：Format of Internet Message Bodies」、RFC 2045、1996年11月"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2144] Adams, C., \"The CAST-128 Encryption Algorithm\", RFC 2144, May 1997.",
      "ja": "[RFC2144] Adams、C。、「CAST-128暗号化アルゴリズム」、RFC 2144、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2822] Resnick, P., \"Internet Message Format\", RFC 2822, April 2001.",
      "ja": "[RFC2822] Resnick、P。、「インターネットメッセージ形式」、RFC 2822、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3156] Elkins, M., Del Torto, D., Levien, R., and T. Roessler, \"MIME Security with OpenPGP\", RFC 3156, August 2001.",
      "ja": "[RFC3156] Elkins、M.、Del Torto、D.、Levien、R。、およびT. Roessler、「OpenPGPを使用したMIMEセキュリティ」、RFC 3156、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[SCHNEIER] Schneier, B., \"Applied Cryptography Second Edition: protocols, algorithms, and source code in C\", 1996.",
      "ja": "[シュナイアー]シュナイアーB。、「Applied Cryptography Second Edition：protocol、algorithm、and source code in C」、1996年。"
    },
    {
      "indent": 3,
      "text": "[TWOFISH] B. Schneier, J. Kelsey, D. Whiting, D. Wagner, C. Hall, and N. Ferguson, \"The Twofish Encryption Algorithm\", John Wiley & Sons, 1999.",
      "ja": "[TWOFISH] B.シュナイアー、J。ケルシー、D。ホワイティング、D。ワグナー、C。ホール、N。ファーガソン、「The Twofish Encryption Algorithm」、John Wiley＆Sons、1999年。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BLEICHENBACHER] Bleichenbacher, Daniel, \"Generating Elgamal\n                 signatures without knowing the secret key,\"\n                 Eurocrypt 96. Note that the version in the\n                 proceedings has an error. A revised version is\n                 available at the time of writing from\n                 <ftp://ftp.inf.ethz.ch/pub/publications/papers/ti\n                 /isc/ElGamal.ps>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[JKS02] Kahil Jallad, Jonathan Katz, Bruce Schneier \"Implementation of Chosen-Ciphertext Attacks against PGP and GnuPG\" http://www.counterpane.com/pgp-attack.html",
      "ja": "[JKS02] Kahil Jallad、Jonathan Katz、Bruce Schneier「PGPおよびGnuPGに対する選択された暗号文攻撃の実装」http://www.counterpane.com/pgp-attack.html"
    },
    {
      "indent": 3,
      "text": "[MAURER] Ueli Maurer, \"Modelling a Public-Key Infrastructure\", Proc. 1996 European Symposium on Research in Computer Security (ESORICS' 96), Lecture Notes in Computer Science, Springer-Verlag, vol. 1146, pp. 325-350, Sep 1996.",
      "ja": "[マウラー] Ueli Maurer、「Modeling a Public-Key Infrastructure」、Proc。 1996コンピュータセキュリティの研究に関するヨーロッパシンポジウム（ESORICS '96）、コンピュータサイエンスの講義ノート、Springer-Verlag、vol。 1146、pp。325-350、1996年9月。"
    },
    {
      "indent": 3,
      "text": "[MZ05]           Serge Mister, Robert Zuccherato, \"An Attack on CFB\n                 Mode Encryption As Used By OpenPGP,\" IACR ePrint\n                 Archive: Report 2005/033, 8 Feb 2005\n                 http://eprint.iacr.org/2005/033",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[REGEX] Jeffrey Friedl, \"Mastering Regular Expressions,\" O'Reilly, ISBN 0-596-00289-0.",
      "ja": "[REGEX] Jeffrey Friedl、「Mastering Regular Expressions」、O'Reilly、ISBN 0-596-00289-0。"
    },
    {
      "indent": 3,
      "text": "[RFC1423] Balenson, D., \"Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers\", RFC 1423, February 1993.",
      "ja": "[RFC1423]バレンソン、D。、「インターネット電子メールのプライバシー強化：パートIII：アルゴリズム、モード、および識別子」、RFC 1423、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC1991] Atkins, D., Stallings, W., and P. Zimmermann, \"PGP Message Exchange Formats\", RFC 1991, August 1996.",
      "ja": "[RFC1991] Atkins、D.、Stallings、W。、およびP. Zimmermann、「PGP Message Exchange Formats」、RFC 1991、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2440] Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, \"OpenPGP Message Format\", RFC 2440, November 1998.",
      "ja": "[RFC2440] Callas、J.、Donnerhacke、L.、Finney、H。、およびR. Thayer、「OpenPGP Message Format」、RFC 2440、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[SP800-57]       NIST Special Publication 800-57, Recommendation on\n                 Key Management\n                 <http://csrc.nist.gov/publications/nistpubs/ 800-\n                 57/SP800-57-Part1.pdf>\n                 <http://csrc.nist.gov/publications/nistpubs/ 800-\n                 57/SP800-57-Part2.pdf>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This memo also draws on much previous work from a number of other authors, including: Derek Atkins, Charles Breed, Dave Del Torto, Marc Dyksterhouse, Gail Haspert, Gene Hoffman, Paul Hoffman, Ben Laurie, Raph Levien, Colin Plumb, Will Price, David Shaw, William Stallings, Mark Weaver, and Philip R. Zimmermann.",
      "ja": "このメモは、Derek Atkins、Charles Breed、Dave Del Torto、Marc Dyksterhouse、Gail Haspert、Gene Hoffman、Paul Hoffman、Ben Laurie、Raph Levien、Colin Plumb、Will Priceなど、他の多くの著者からの以前の多くの作品も利用しています。 、David Shaw、William Stallings、Mark Weaver、およびPhilip R. Zimmermann。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "The working group can be contacted via the current chair:",
      "ja": "ワーキンググループは、現在の議長を通じて連絡を取ることができます。"
    },
    {
      "indent": 6,
      "text": "Derek Atkins IHTFP Consulting, Inc. 4 Farragut Ave Somerville, MA 02144 USA",
      "ja": "Derek Atkins IHTFP Consulting、Inc. 4 Farragut Ave Somerville、MA 02144 USA"
    },
    {
      "indent": 6,
      "text": "EMail: derek@ihtfp.com\nTel: +1 617 623 3745",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The principal authors of this document are as follows:",
      "ja": "このドキュメントの主な著者は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Jon Callas EMail: jon@callas.org",
      "ja": "Jon Callas EMail：jon@callas.org"
    },
    {
      "indent": 6,
      "text": "Lutz Donnerhacke IKS GmbH Wildenbruchstr. 15 07745 Jena, Germany EMail: lutz@iks-jena.de",
      "ja": "Lutz Donnerhacke IKS GmbH Wildenbruchstr。 15 07745ドイツ、イェーナEメール：lutz@iks-jena.de"
    },
    {
      "indent": 6,
      "text": "Hal Finney EMail: hal@finney.org",
      "ja": "Hal Finneyメール：hal@finney.org"
    },
    {
      "indent": 6,
      "text": "David Shaw EMail: dshaw@jabberwocky.com",
      "ja": "David Shaw EMail：dshaw@jabberwocky.com"
    },
    {
      "indent": 6,
      "text": "Rodney Thayer EMail: rodney@canola-jones.com",
      "ja": "Rodney Thayer Eメール：rodney@canola-jones.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "Copyright（C）IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します。明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および使用可能にされるライセンスの保証、または一般ライセンスを取得する試みの結果、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得できるhttp://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    }
  ]
}