{
  "title": {
    "text": "RFC 4226 - HOTP: An HMAC-Based One-Time Password Algorithm",
    "ja": "RFC 4226 - HOTP：HMACベースのワンタイムパスワードアルゴリズム"
  },
  "number": 4226,
  "created_at": "2021-04-10 09:52:53.286153+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         D. M'Raihi\nRequest for Comments: 4226                                      VeriSign\nCategory: Informational                                       M. Bellare\n                                                                    UCSD\n                                                            F. Hoornaert\n                                                                   Vasco\n                                                             D. Naccache\n                                                                 Gemplus\n                                                                O. Ranen\n                                                                 Aladdin\n                                                           December 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "HOTP: An HMAC-Based One-Time Password Algorithm",
      "ja": "HOTP：HMACベースのワンタイムパスワードアルゴリズム"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティに関する情報を提供します。インターネット規格はあらゆる種類の標準を指定していません。このメモの分布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット社会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes an algorithm to generate one-time password values, based on Hashed Message Authentication Code (HMAC). A security analysis of the algorithm is presented, and important parameters related to the secure deployment of the algorithm are discussed. The proposed algorithm can be used across a wide range of network applications ranging from remote Virtual Private Network (VPN) access, Wi-Fi network logon to transaction-oriented Web applications.",
      "ja": "このドキュメントでは、ハッシュされたメッセージ認証コード（HMAC）に基づいて、1回限りのパスワード値を生成するためのアルゴリズムについて説明します。アルゴリズムのセキュリティ分析が提示され、アルゴリズムの安全な展開に関連する重要なパラメータが議論されている。提案されたアルゴリズムは、リモート仮想プライベートネットワーク（VPN）アクセス、Wi-Fiネットワークログオンからトランザクション指向Webアプリケーションまでの幅広いネットワークアプリケーションにまたがって使用できます。"
    },
    {
      "indent": 3,
      "text": "This work is a joint effort by the OATH (Open AuTHentication) membership to specify an algorithm that can be freely distributed to the technical community. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations.",
      "ja": "この作品は、技術コミュニティに自由に配布できるアルゴリズムを指定するための宣誓（認証）メンバーシップによる共同努力です。著者らは、コモンと共有アルゴリズムが、商業およびオープンソースの実装にまたがる相互運用性を可能にすることによって、インターネット上の2要素認証の採用を促進すると考えています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Overview ........................................................3\n2. Introduction ....................................................3\n3. Requirements Terminology ........................................4\n4. Algorithm Requirements ..........................................4\n5. HOTP Algorithm ..................................................5\n   5.1. Notation and Symbols .......................................5\n   5.2. Description ................................................6\n   5.3. Generating an HOTP Value ...................................6\n   5.4. Example of HOTP Computation for Digit = 6 ..................7\n6. Security Considerations .........................................8\n7. Security Requirements ...........................................9\n   7.1. Authentication Protocol Requirements .......................9\n   7.2. Validation of HOTP Values .................................10\n   7.3. Throttling at the Server ..................................10\n   7.4. Resynchronization of the Counter ..........................11\n   7.5. Management of Shared Secrets ..............................11\n8. Composite Shared Secrets .......................................14\n9. Bi-Directional Authentication ..................................14\n10. Conclusion ....................................................15\n11. Acknowledgements ..............................................15\n12. Contributors ..................................................15\n13. References ....................................................15\n   13.1. Normative References .....................................15\n   13.2. Informative References ...................................16\nAppendix A - HOTP Algorithm Security: Detailed Analysis ...........17\n   A.1. Definitions and Notations .................................17\n   A.2. The Idealized Algorithm: HOTP-IDEAL .......................17\n   A.3. Model of Security .........................................18\n   A.4. Security of the Ideal Authentication Algorithm ............19\n        A.4.1. From Bits to Digits ................................19\n        A.4.2. Brute Force Attacks ................................21\n        A.4.3. Brute force attacks are the best possible attacks ..22\n   A.5. Security Analysis of HOTP .................................23\nAppendix B - SHA-1 Attacks ........................................25\n   B.1. SHA-1 Status ..............................................25\n   B.2. HMAC-SHA-1 Status .........................................26\n   B.3. HOTP Status ...............................................26\nAppendix C - HOTP Algorithm: Reference Implementation .............27\nAppendix D - HOTP Algorithm: Test Values ..........................32\nAppendix E - Extensions ...........................................33\n   E.1. Number of Digits ..........................................33\n   E.2. Alphanumeric Values .......................................33\n   E.3. Sequence of HOTP values ...................................34\n   E.4. A Counter-Based Resynchronization Method ..................34\n   E.5. Data Field ................................................35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Overview",
      "section_title": true,
      "ja": "1. 概要"
    },
    {
      "indent": 3,
      "text": "The document introduces first the context around an algorithm that generates one-time password values based on HMAC [BCK1] and, thus, is named the HMAC-Based One-Time Password (HOTP) algorithm. In Section 4, the algorithm requirements are listed and in Section 5, the HOTP algorithm is described. Sections 6 and 7 focus on the algorithm security. Section 8 proposes some extensions and improvements, and Section 10 concludes this document. In Appendix A, the interested reader will find a detailed, full-fledged analysis of the algorithm security: an idealized version of the algorithm is evaluated, and then the HOTP algorithm security is analyzed.",
      "ja": "この文書は、HMAC [BCK1]に基づいて1回限りのパスワード値を生成するアルゴリズムの周囲のコンテキストを最初に導入し、したがって、HMACベースのワンタイムパスワード（HOTP）アルゴリズムと呼ばれます。セクション4では、アルゴリズムの要件をリストし、セクション5では、HOTPアルゴリズムについて説明します。セクション6と7はアルゴリズムのセキュリティに焦点を当てています。セクション8はいくつかの拡張と改善を提案し、セクション10はこの文書を締めくくります。付録Aでは、興味のあるリーダーがアルゴリズムのセキュリティの詳細で本格的な分析を見つけるでしょう：アルゴリズムの理想的なバージョンが評価され、その後HOTPアルゴリズムのセキュリティが分析されます。"
    },
    {
      "indent": 0,
      "text": "2. Introduction",
      "section_title": true,
      "ja": "2. はじめに"
    },
    {
      "indent": 3,
      "text": "Today, deployment of two-factor authentication remains extremely limited in scope and scale. Despite increasingly higher levels of threats and attacks, most Internet applications still rely on weak authentication schemes for policing user access. The lack of interoperability among hardware and software technology vendors has been a limiting factor in the adoption of two-factor authentication technology. In particular, the absence of open specifications has led to solutions where hardware and software components are tightly coupled through proprietary technology, resulting in high-cost solutions, poor adoption, and limited innovation.",
      "ja": "今日、2要素認証の展開は、スコープとスケールが非常に限られています。ますます高いレベルの脅威と攻撃にもかかわらず、ほとんどのインターネットアプリケーションはまだユーザーアクセスのポリシングのための弱い認証方式に依存しています。ハードウェアおよびソフトウェア技術のベンダーの間の相互運用性の欠如は、2要素認証技術の採用における制限要因となっています。特に、オープン仕様の欠如は、ハードウェアおよびソフトウェアコンポーネントが独自の技術を介して厳重に結合されているソリューションをもたらし、高コストのソリューション、採用不良、および革新が限られています。"
    },
    {
      "indent": 3,
      "text": "In the last two years, the rapid rise of network threats has exposed the inadequacies of static passwords as the primary mean of authentication on the Internet. At the same time, the current approach that requires an end user to carry an expensive, single-function device that is only used to authenticate to the network is clearly not the right answer. For two-factor authentication to propagate on the Internet, it will have to be embedded in more flexible devices that can work across a wide range of applications.",
      "ja": "過去2年間で、ネットワークの脅威の急激な上昇は、インターネット上の認証の主な平均として静的パスワードの不適切さを公開しています。同時に、ネットワークを認証するためにのみ使用される高価な単一機能デバイスを、正しい回答ではないことを要求する現在のアプローチが明らかにはわかりません。2要素認証のためにインターネット上で伝播するためには、幅広いアプリケーションにまたがるより柔軟なデバイスに埋め込む必要があります。"
    },
    {
      "indent": 3,
      "text": "The ability to embed this base technology while ensuring broad interoperability requires that it be made freely available to the broad technical community of hardware and software developers. Only an open-system approach will ensure that basic two-factor authentication primitives can be built into the next generation of consumer devices such as USB mass storage devices, IP phones, and personal digital assistants.",
      "ja": "幅広い相互運用性を確保しながらこの基本技術を埋め込む能力は、ハードウェアおよびソフトウェア開発者の幅広い技術コミュニティに自由に利用できるようにする必要があります。オープンシステムアプローチのみが、USB大容量記憶装置、IP電話、およびパーソナルデジタルアシスタントなどの次世代のコンシューマデバイスに基本的な2要素認証プリミティブを構築できるようにするでしょう。"
    },
    {
      "indent": 0,
      "text": " One-Time Password is certainly one of the simplest and most popular forms of two-factor authentication for securing network access. For example, in large enterprises, Virtual Private Network access often requires the use of One-Time Password tokens for remote user authentication. One-Time Passwords are often preferred to stronger forms of authentication such as Public-Key Infrastructure (PKI) or biometrics because an air-gap device does not require the installation of any client desktop software on the user machine, therefore allowing them to roam across multiple machines including home computers, kiosks, and personal digital assistants.",
      "ja": "ワンタイムパスワードは確かにネットワークアクセスを保護するための2要素認証の最も簡単で人気のある形式のいずれかです。たとえば、大規模な企業では、仮想プライベートネットワークアクセスには、リモートユーザー認証のワンタイムパスワードトークンの使用が必要です。ワンタイムパスワードは、エアギャップデバイスがユーザーマシン上でのクライアントデスクトップソフトウェアのインストールを必要としないため、公開鍵インフラストラクチャ（PKI）またはバイオメトリクスなどの認証の強い形式が頻繁に優先されることがよくあります。ホームコンピュータ、キオスク、およびパーソナルデジタルアシスタントを含む複数のマシン。"
    },
    {
      "indent": 3,
      "text": "This document proposes a simple One-Time Password algorithm that can be implemented by any hardware manufacturer or software developer to create interoperable authentication devices and software agents. The algorithm is event-based so that it can be embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards. The presented algorithm is made freely available to the developer community under the terms and conditions of the IETF Intellectual Property Rights [RFC3979].",
      "ja": "この文書は、相互運用可能な認証装置やソフトウェアエージェントを作成するために、任意のハードウェア製造元またはソフトウェア開発者によって実装できる単純なワンタイムパスワードアルゴリズムを提案しています。アルゴリズムはイベントベースで、Javaスマートカード、USBドングル、GSM SIMカードなどの大容量デバイスに埋め込むことができます。提示されたアルゴリズムは、IETF知的財産権の契約条件下で開発者コミュニティで自由に利用可能にされています[RFC3979]。"
    },
    {
      "indent": 3,
      "text": "The authors of this document are members of the Open AuTHentication initiative [OATH]. The initiative was created in 2004 to facilitate collaboration among strong authentication technology providers.",
      "ja": "この文書の著者はオープン認証イニシアチブ[宣誓]のメンバーです。強力な認証技術プロバイダ間のコラボレーションを容易にするために、イニシアチブは2004年に作成されました。"
    },
    {
      "indent": 0,
      "text": "3. Requirements Terminology",
      "section_title": true,
      "ja": "3. 要求用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「必須」、「必要ではない」、「しない」、「推奨する」、「推奨する」、「5月」、および「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、「オプション」、[RFC2119]に記載されているように解釈されること。"
    },
    {
      "indent": 0,
      "text": "4. Algorithm Requirements",
      "section_title": true,
      "ja": "4. アルゴリズムの要件"
    },
    {
      "indent": 3,
      "text": "This section presents the main requirements that drove this algorithm design. A lot of emphasis was placed on end-consumer usability as well as the ability for the algorithm to be implemented by low-cost hardware that may provide minimal user interface capabilities. In particular, the ability to embed the algorithm into high-volume SIM and Java cards was a fundamental prerequisite.",
      "ja": "この節では、このアルゴリズム設計を推進した主な要件を示します。最小限のユーザインタフェース機能を提供する可能性がある低コストのハードウェアによって、エンドの消費者の使いやすさとアルゴリズムを実装する能力が大変な重点を置かれました。特に、アルゴリズムを大量のSIMおよびJavaカードに埋め込む能力は、基本的な前提条件でした。"
    },
    {
      "indent": 3,
      "text": "R1 - The algorithm MUST be sequence- or counter-based: one of the goals is to have the HOTP algorithm embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards.",
      "ja": "R1  - アルゴリズムはシーケンス - またはカウンタベースでなければなりません。ゴールの1つは、Javaスマートカード、USBドングル、GSM SIMカードなどの大量のデバイスにHOTPアルゴリズムを組み込んだことです。"
    },
    {
      "indent": 3,
      "text": "R2 - The algorithm SHOULD be economical to implement in hardware by minimizing requirements on battery, number of buttons, computational horsepower, and size of LCD display.",
      "ja": "R2  - このアルゴリズムは、バッテリの要件、ボタンの数、計算馬力、およびLCDディスプレイのサイズの要件を最小限に抑えることによって、ハードウェアで実装する経済的であるべきです。"
    },
    {
      "indent": 3,
      "text": "R3 - The algorithm MUST work with tokens that do not support any numeric input, but MAY also be used with more sophisticated devices such as secure PIN-pads.",
      "ja": "R3  - アルゴリズムは、数値入力をサポートしていないトークンで動作する必要がありますが、セキュアピンパッドなどのより洗練されたデバイスでも使用できます。"
    },
    {
      "indent": 3,
      "text": "R4 - The value displayed on the token MUST be easily read and entered by the user: This requires the HOTP value to be of reasonable length.",
      "ja": "R4  - トークンに表示されている値は、ユーザーによって簡単に読み取られて入力する必要があります。これにより、HOTP値が妥当な長さになることが必要です。"
    },
    {
      "indent": 3,
      "text": "The HOTP value must be at least a 6-digit value. It is also desirable that the HOTP value be 'numeric only' so that it can be easily entered on restricted devices such as phones.",
      "ja": "HOTP値は少なくとも6桁の値でなければなりません。HOTP値が「数値のみ」であるため、電話などの制限付き装置に簡単に入力できることも望ましい。"
    },
    {
      "indent": 3,
      "text": "R5 - There MUST be user-friendly mechanisms available to resynchronize the counter. Section 7.4 and Appendix E.4 details the resynchronization mechanism proposed in this document",
      "ja": "R5  - カウンタを再同期するために使用可能なユーザーフレンドリーなメカニズムがある必要があります。セクション7.4および付録E.4は、この文書で提案されている再同期メカニズムを詳細"
    },
    {
      "indent": 3,
      "text": "R6 - The algorithm MUST use a strong shared secret. The length of the shared secret MUST be at least 128 bits. This document RECOMMENDs a shared secret length of 160 bits.",
      "ja": "R6  - アルゴリズムは強力な共有秘密を使用しなければなりません。共有秘密の長さは少なくとも128ビットでなければなりません。この文書は160ビットの共有秘密長を推奨しています。"
    },
    {
      "indent": 0,
      "text": "5. HOTP Algorithm",
      "section_title": true,
      "ja": "5. HotPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "In this section, we introduce the notation and describe the HOTP algorithm basic blocks -- the base function to compute an HMAC-SHA-1 value and the truncation method to extract an HOTP value.",
      "ja": "このセクションでは、表記を紹介し、HOTPアルゴリズム基本ブロック -  HMAC-SHA-1値を計算するための基本関数とHotP値を抽出するためのトランケーション法を記述します。"
    },
    {
      "indent": 0,
      "text": "5.1. Notation and Symbols",
      "section_title": true,
      "ja": "5.1. 表記法と記号"
    },
    {
      "indent": 3,
      "text": "A string always means a binary string, meaning a sequence of zeros and ones.",
      "ja": "文字列は常にバイナリ文字列を意味し、ゼロと1のシーケンスを意味します。"
    },
    {
      "indent": 3,
      "text": "If s is a string, then |s| denotes its length.",
      "ja": "sが文字列の場合、その後"
    },
    {
      "indent": 3,
      "text": "If n is a number, then |n| denotes its absolute value.",
      "ja": "nが数値の場合、その後"
    },
    {
      "indent": 3,
      "text": "If s is a string, then s[i] denotes its i-th bit. We start numbering the bits at 0, so s = s[0]s[1]...s[n-1] where n = |s| is the length of s.",
      "ja": "Sが文字列である場合、s [i]はそのi番目のビットを表す。ビットの番号を0に始めますので、s = s [0] s [1] ... s [n-1]ここでn ="
    },
    {
      "indent": 3,
      "text": "Let StToNum (String to Number) denote the function that as input a string s returns the number whose binary representation is s. (For example, StToNum(110) = 6.)",
      "ja": "sttonum（文字列to numver）を入力として文字列sが2進表現がsを返す関数を表す。（例えば、Sttonum（110）= 6）"
    },
    {
      "indent": 3,
      "text": "Here is a list of symbols used in this document.",
      "ja": "これはこの文書で使用されているシンボルのリストです。"
    },
    {
      "indent": 3,
      "text": "Symbol  Represents\n-------------------------------------------------------------------\nC       8-byte counter value, the moving factor.  This counter\n        MUST be synchronized between the HOTP generator (client)\n        and the HOTP validator (server).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "K shared secret between client and server; each HOTP generator has a different and unique secret K.",
      "ja": "kクライアントとサーバー間の秘密を共有しました。各HotPジェネレータには、異なる独自の秘密Kがあります。"
    },
    {
      "indent": 3,
      "text": "T throttling parameter: the server will refuse connections from a user after T unsuccessful authentication attempts.",
      "ja": "Tスロットルパラメータ：認証失敗の試行後に、サーバーはユーザーからの接続を拒否します。"
    },
    {
      "indent": 3,
      "text": "s resynchronization parameter: the server will attempt to verify a received authenticator across s consecutive counter values.",
      "ja": "■再同期パラメータ：サーバーは、S連続したカウンタ値で受信したオーセンティケータを検証しようとします。"
    },
    {
      "indent": 3,
      "text": "Digit number of digits in an HOTP value; system parameter.",
      "ja": "桁数HOTP値の桁数。システムパラメータ"
    },
    {
      "indent": 0,
      "text": "5.2. Description",
      "section_title": true,
      "ja": "5.2. description"
    },
    {
      "indent": 3,
      "text": "The HOTP algorithm is based on an increasing counter value and a static symmetric key known only to the token and the validation service. In order to create the HOTP value, we will use the HMAC-SHA-1 algorithm, as defined in RFC 2104 [BCK2].",
      "ja": "HOTPアルゴリズムは、トークンと検証サービスにのみ知られている静的対称鍵と静的対称鍵とに基づいています。HOTP値を作成するために、RFC 2104 [BCK2]で定義されているように、HMAC-SHA-1アルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "As the output of the HMAC-SHA-1 calculation is 160 bits, we must truncate this value to something that can be easily entered by a user.",
      "ja": "HMAC-SHA-1計算の出力が160ビットであるため、ユーザーが簡単に入力できるものにこの値を切り捨てる必要があります。"
    },
    {
      "indent": 19,
      "text": "HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "ただし："
    },
    {
      "indent": 5,
      "text": "- Truncate represents the function that converts an HMAC-SHA-1 value into an HOTP value as defined in Section 5.3.",
      "ja": "- Truncateは、セクション5.3で定義されているように、HMAC-SHA-1値をHOTP値に変換する関数を表します。"
    },
    {
      "indent": 3,
      "text": "The Key (K), the Counter (C), and Data values are hashed high-order byte first.",
      "ja": "キー（k）、カウンタ（c）、およびデータ値は、最初に高次バイトをハッシュした。"
    },
    {
      "indent": 3,
      "text": "The HOTP values generated by the HOTP generator are treated as big endian.",
      "ja": "HotP Generatorによって生成されたHOTP値は大きなエンディアンとして扱われます。"
    },
    {
      "indent": 0,
      "text": "5.3. Generating an HOTP Value",
      "section_title": true,
      "ja": "5.3. HotP値を生成します"
    },
    {
      "indent": 3,
      "text": "We can describe the operations in 3 distinct steps:",
      "ja": "3つの異なるステップで操作を説明することができます。"
    },
    {
      "indent": 3,
      "text": "Step 1: Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C)  // HS\nis a 20-byte string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Step 2: Generate a 4-byte string (Dynamic Truncation)\nLet Sbits = DT(HS)   //  DT, defined below,\n                     //  returns a 31-bit string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Step 3: Compute an HOTP value\nLet Snum  = StToNum(Sbits)   // Convert S to a number in\n                                 0...2^{31}-1\nReturn D = Snum mod 10^Digit //  D is a number in the range\n                                 0...10^{Digit}-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Truncate function performs Step 2 and Step 3, i.e., the dynamic truncation and then the reduction modulo 10^Digit. The purpose of the dynamic offset truncation technique is to extract a 4-byte dynamic binary code from a 160-bit (20-byte) HMAC-SHA-1 result.",
      "ja": "切り捨て機能は、ステップ2およびステップ3、すなわち動的切り捨て、次いで減少モジュロ10 ^桁を実行する。動的オフセット切り捨て技術の目的は、160ビット（20バイト）のHMAC-SHA-1の結果から4バイトの動的バイナリコードを抽出することです。"
    },
    {
      "indent": 4,
      "text": "DT(String) // String = String[0]...String[19]\n Let OffsetBits be the low-order 4 bits of String[19]\n Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15\n Let P = String[OffSet]...String[OffSet+3]\n Return the Last 31 bits of P",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The reason for masking the most significant bit of P is to avoid confusion about signed vs. unsigned modulo computations. Different processors perform these operations differently, and masking out the signed bit removes all ambiguity.",
      "ja": "Pの最上位ビットをマスキングする理由は、符号付きVS.符号なしモジュロ計算についての混乱を避けることです。さまざまなプロセッサがこれらの操作を異ならず実行し、署名されたビットをマスキングすると、すべてのあいまいさが削除されます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST extract a 6-digit code at a minimum and possibly 7 and 8-digit code. Depending on security requirements, Digit = 7 or more SHOULD be considered in order to extract a longer HOTP value.",
      "ja": "実装は、最小およびおそらく7桁のコードで6桁のコードを抽出する必要があります。セキュリティ要件に応じて、より長いHOTP値を抽出するために、Digit = 7以上を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following paragraph is an example of using this technique for Digit = 6, i.e., that a 6-digit HOTP value is calculated from the HMAC value.",
      "ja": "次の段落は、この技術をDIGIT = 6、すなわち6桁のHOTP値をHMAC値から計算することの一例である。"
    },
    {
      "indent": 0,
      "text": "5.4. Example of HOTP Computation for Digit = 6",
      "section_title": true,
      "ja": "5.4. DIGIT = 6のHOTP計算の例"
    },
    {
      "indent": 3,
      "text": "The following code example describes the extraction of a dynamic binary code given that hmac_result is a byte array with the HMAC-SHA-1 result:",
      "ja": "次のコード例は、HMAC_RESULTがHMAC-SHA-1の結果を持つバイト配列であることを考えると、動的バイナリコードの抽出を説明しています。"
    },
    {
      "indent": 8,
      "text": "int offset   =  hmac_result[19] & 0xf ;\nint bin_code = (hmac_result[offset]  & 0x7f) << 24\n   | (hmac_result[offset+1] & 0xff) << 16\n   | (hmac_result[offset+2] & 0xff) <<  8\n   | (hmac_result[offset+3] & 0xff) ;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SHA-1 HMAC Bytes (Example)",
      "ja": "SHA-1 HMACバイト（例）"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------------------------\n| Byte Number                                               |\n-------------------------------------------------------------\n|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|\n-------------------------------------------------------------\n| Byte Value                                                |\n-------------------------------------------------------------\n|1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|\n-------------------------------***********----------------++|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* The last byte (byte 19) has the hex value 0x5a. * The value of the lower 4 bits is 0xa (the offset value). * The offset value is byte 10 (0xa). * The value of the 4 bytes starting at byte 10 is 0x50ef7f19, which is the dynamic binary code DBC1. * The MSB of DBC1 is 0x50 so DBC2 = DBC1 = 0x50ef7f19 . * HOTP = DBC2 modulo 10^6 = 872921.",
      "ja": "* 最後のバイト（バイト19）は16進値0x5aを有する。*下位4ビットの値は0xa（オフセット値）です。*オフセット値はバイト10（0xa）です。*バイト10から始まる4バイトの値は、ダイナミックバイナリコードDBC1である0x50ef7F19です。※DBC1のMSBは0x50ですので、dbc2 = dbc1 = 0x50ef7f19です。* HOTP = DBC2モジュロ10 ^ 6 = 872921。"
    },
    {
      "indent": 3,
      "text": "We treat the dynamic binary code as a 31-bit, unsigned, big-endian integer; the first byte is masked with a 0x7f.",
      "ja": "ダイナミックバイナリコードを31ビット、符号なし、ビッグエンディアン整数として扱います。最初のバイトは0x7fでマスクされています。"
    },
    {
      "indent": 3,
      "text": "We then take this number modulo 1,000,000 (10^6) to generate the 6- digit HOTP value 872921 decimal.",
      "ja": "その後、この番号モジュロ1,000,000（10 ^ 6）を取り、6桁のHOTP値872921 10進数を生成します。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The conclusion of the security analysis detailed in the Appendix is that, for all practical purposes, the outputs of the Dynamic Truncation (DT) on distinct counter inputs are uniformly and independently distributed 31-bit strings.",
      "ja": "付録に詳述されているセキュリティ分析の締結は、すべての実用的な目的のために、異なるカウンタ入力上の動的切り捨て（DT）の出力が一律に独立して31ビットの文字列に分布していることである。"
    },
    {
      "indent": 3,
      "text": "The security analysis then details the impact of the conversion from a string to an integer and the final reduction modulo 10^Digit, where Digit is the number of digits in an HOTP value.",
      "ja": "セキュリティ分析は、文字列から整数への変換の影響と最終的な削減モジュロ10 ^桁の影響を示します。"
    },
    {
      "indent": 3,
      "text": "The analysis demonstrates that these final steps introduce a negligible bias, which does not impact the security of the HOTP algorithm, in the sense that the best possible attack against the HOTP function is the brute force attack.",
      "ja": "分析は、これらの最終ステップがHOTP機能に対する最良の攻撃がブルートフォース攻撃であるという意味で、HOTPアルゴリズムのセキュリティに影響を与えない無視できないバイアスを導入することを示しています。"
    },
    {
      "indent": 3,
      "text": "Assuming an adversary is able to observe numerous protocol exchanges and collect sequences of successful authentication values. This adversary, trying to build a function F to generate HOTP values based on his observations, will not have a significant advantage over a random guess.",
      "ja": "敵対者が多数のプロトコル交換を観察し、認証値の成功したシーケンスを収集することができると仮定します。彼の観察に基づいてHotP値を生成するための関数fを構築しようとするこの敵対者は、ランダムな推測よりも大きな利点を持たないでしょう。"
    },
    {
      "indent": 3,
      "text": "The logical conclusion is simply that the best strategy will once again be to perform a brute force attack to enumerate and try all the possible values.",
      "ja": "論理的な結論は、最良の戦略が再び列挙してすべての可能な値を試してみるためにも、最良の戦略が再びブルートフォース攻撃を実行することです。"
    },
    {
      "indent": 3,
      "text": "Considering the security analysis in the Appendix of this document, without loss of generality, we can approximate closely the security of the HOTP algorithm by the following formula:",
      "ja": "一般性を失うことなく、この文書の付録のセキュリティ分析を考慮すると、次の式でHOTPアルゴリズムのセキュリティを密接に近似しています。"
    },
    {
      "indent": 28,
      "text": "Sec = sv/10^Digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Where:\n  - Sec is the probability of success of the adversary;\n  - s is the look-ahead synchronization window size;\n  - v is the number of verification attempts;\n  - Digit is the number of digits in HOTP values.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Obviously, we can play with s, T (the Throttling parameter that would limit the number of attempts by an attacker), and Digit until achieving a certain level of security, still preserving the system usability.",
      "ja": "明らかに、S、T（攻撃者による試行回数を制限するスロットルパラメータ）で再生することができ、一定レベルのセキュリティを達成するまでの数字はシステムの使いやすさを保ちます。"
    },
    {
      "indent": 0,
      "text": "7. Security Requirements",
      "section_title": true,
      "ja": "7. セキュリティ要件"
    },
    {
      "indent": 3,
      "text": "Any One-Time Password algorithm is only as secure as the application and the authentication protocols that implement it. Therefore, this section discusses the critical security requirements that our choice of algorithm imposes on the authentication protocol and validation software.",
      "ja": "1回限りのパスワードアルゴリズムは、アプリケーションと同じくらい安全なものと、実装する認証プロトコルです。したがって、このセクションでは、認証プロトコルと検証ソフトウェアにアルゴリズムの選択が課されるという重大なセキュリティ要件について説明します。"
    },
    {
      "indent": 3,
      "text": "The parameters T and s discussed in this section have a significant impact on the security -- further details in Section 6 elaborate on the relations between these parameters and their impact on the system security.",
      "ja": "このセクションで説明されているパラメータtとsは、セキュリティに大きな影響を与えます - セクション6のさらなる詳細は、これらのパラメータとシステムセキュリティへの影響の影響について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "It is also important to remark that the HOTP algorithm is not a substitute for encryption and does not provide for the privacy of data transmission. Other mechanisms should be used to defeat attacks aimed at breaking confidentiality and privacy of transactions.",
      "ja": "HOTPアルゴリズムが暗号化の代わりにならず、データ伝送のプライバシーを提供しないと注意することも重要です。他のメカニズムは、機密性と取引のプライバシーを破ることを目的とした攻撃を軽減するために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.1. Authentication Protocol Requirements",
      "section_title": true,
      "ja": "7.1. 認証プロトコルの要件"
    },
    {
      "indent": 3,
      "text": "We introduce in this section some requirements for a protocol P implementing HOTP as the authentication method between a prover and a verifier.",
      "ja": "このセクションでは、ProverとVerifierとの間の認証方法としてHOTPを実装するプロトコルPのいくつかの要件を紹介します。"
    },
    {
      "indent": 3,
      "text": "RP1 - P MUST support two-factor authentication, i.e., the communication and verification of something you know (secret code such as a Password, Pass phrase, PIN code, etc.) and something you have (token). The secret code is known only to the user and usually entered with the One-Time Password value for authentication purpose (two-factor authentication).",
      "ja": "RP1  -  Pは、2要素認証、すなわち、あなたが知っているものの通信と検証（パスワードなどの秘密コード、パスフレーズ、ピンコードなど）とあなたが持っているもの（トークン）をサポートしなければなりません。秘密コードは、ユーザーだけが知られており、通常は認証目的のためのワンタイムパスワード値（2要素認証）で入力されています。"
    },
    {
      "indent": 3,
      "text": "RP2 - P SHOULD NOT be vulnerable to brute force attacks. This implies that a throttling/lockout scheme is RECOMMENDED on the validation server side.",
      "ja": "RP2  -  Pはブルートフォース攻撃に対して脆弱ではありません。これは、検証サーバ側でスロットル/ロックアウト方式を推奨することを意味します。"
    },
    {
      "indent": 3,
      "text": "RP3 - P SHOULD be implemented over a secure channel in order to protect users' privacy and avoid replay attacks.",
      "ja": "RP3  -  Pは、ユーザーのプライバシーを保護し、再生攻撃を避けるために安全なチャネルを介して実装されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.2. Validation of HOTP Values",
      "section_title": true,
      "ja": "7.2. HOTP値の検証"
    },
    {
      "indent": 3,
      "text": "The HOTP client (hardware or software token) increments its counter and then calculates the next HOTP value HOTP client. If the value received by the authentication server matches the value calculated by the client, then the HOTP value is validated. In this case, the server increments the counter value by one.",
      "ja": "HOTPクライアント（ハードウェアまたはソフトウェアトークン）はそのカウンタをインクリメントしてから、次のHOTP値HotPクライアントを計算します。認証サーバによって受信された値がクライアントによって計算された値と一致する場合、HotP値は検証されます。この場合、サーバはカウンタ値を1つずつ増分します。"
    },
    {
      "indent": 3,
      "text": "If the value received by the server does not match the value calculated by the client, the server initiate the resynch protocol (look-ahead window) before it requests another pass.",
      "ja": "サーバーによって受信された値がクライアントによって計算された値と一致しない場合、サーバーは別のパスを要求する前にResynchプロトコル（先読みウィンドウ）を開始します。"
    },
    {
      "indent": 3,
      "text": "If the resynch fails, the server asks then for another authentication pass of the protocol to take place, until the maximum number of authorized attempts is reached.",
      "ja": "再シンチが失敗した場合、サーバーは、許可された試行の最大数に達するまで、プロトコルの別の認証パスを実行するために尋ねます。"
    },
    {
      "indent": 3,
      "text": "If and when the maximum number of authorized attempts is reached, the server SHOULD lock out the account and initiate a procedure to inform the user.",
      "ja": "許可された試行の最大数に達すると、サーバーはアカウントをロックアウトしてユーザーに通知するための手順を開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Throttling at the Server",
      "section_title": true,
      "ja": "7.3. サーバーでのスロットル"
    },
    {
      "indent": 3,
      "text": "Truncating the HMAC-SHA-1 value to a shorter value makes a brute force attack possible. Therefore, the authentication server needs to detect and stop brute force attacks.",
      "ja": "HMAC-SHA-1値を短い値に切り捨てると、ブルートフォース攻撃が可能になります。したがって、認証サーバーはブルートフォース攻撃を検出して停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND setting a throttling parameter T, which defines the maximum number of possible attempts for One-Time Password validation. The validation server manages individual counters per HOTP device in order to take note of any failed attempt. We RECOMMEND T not to be too large, particularly if the resynchronization method used on the server is window-based, and the window size is large. T SHOULD be set as low as possible, while still ensuring that usability is not significantly impacted.",
      "ja": "1回限りのパスワード検証の可能な試行の最大数を定義するスロットルパラメータTを設定することをお勧めします。検証サーバーは、失敗した試みに注目するために、HotPデバイスごとの個々のカウンタを管理します。特にサーバで使用されている再同期メソッドがウィンドウベースで、ウィンドウサイズが大きい場合は、大きすぎないことをお勧めします。使用可能性が著しく影響を与えないようにしながら、Tはできるだけ低く設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Another option would be to implement a delay scheme to avoid a brute force attack. After each failed attempt A, the authentication server would wait for an increased T*A number of seconds, e.g., say T = 5, then after 1 attempt, the server waits for 5 seconds, at the second failed attempt, it waits for 5*2 = 10 seconds, etc.",
      "ja": "もう1つの選択肢は、ブルートフォース攻撃を回避するための遅延方式を実装することです。失敗した各試行Aの後、認証サーバは、T = 5、例えばT = 5の秒数を増やすのを待ち、次に1回の試行後、サーバは5秒間待ってから5秒間待ってから、5を待つ* 2 = 10秒など"
    },
    {
      "indent": 3,
      "text": "The delay or lockout schemes MUST be across login sessions to prevent attacks based on multiple parallel guessing techniques.",
      "ja": "遅延スキームまたはロックアウトスキームは、複数の並列推測技術に基づく攻撃を防ぐためにログインセッション間でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.4. Resynchronization of the Counter",
      "section_title": true,
      "ja": "7.4. カウンタの再同期化"
    },
    {
      "indent": 3,
      "text": "Although the server's counter value is only incremented after a successful HOTP authentication, the counter on the token is incremented every time a new HOTP is requested by the user. Because of this, the counter values on the server and on the token might be out of synchronization.",
      "ja": "サーバーのカウンタ値は、HOTP認証が成功した後にのみインクリメントされますが、新しいHOTPがユーザーから要求されるたびにトークンのカウンタが増加します。このため、サーバー上のカウンタ値とトークンのカウンタ値が同期している可能性があります。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND setting a look-ahead parameter s on the server, which defines the size of the look-ahead window. In a nutshell, the server can recalculate the next s HOTP-server values, and check them against the received HOTP client.",
      "ja": "先読みウィンドウのサイズを定義するサーバーに先読みのパラメータSを設定することをお勧めします。一言で言えば、サーバーは次のH HotP-Serverの値を再計算し、受信したHotPクライアントに対してそれらをチェックすることができます。"
    },
    {
      "indent": 3,
      "text": "Synchronization of counters in this scenario simply requires the server to calculate the next HOTP values and determine if there is a match. Optionally, the system MAY require the user to send a sequence of (say, 2, 3) HOTP values for resynchronization purpose, since forging a sequence of consecutive HOTP values is even more difficult than guessing a single HOTP value.",
      "ja": "このシナリオのカウンタの同期には、サーバーが次のHOTP値を計算し、一致があるかどうかを判断する必要があります。任意選択で、システムは、連続したHOTP値の順序を単一のHOTP値を推測するよりもさらに困難であるため、ユーザに再同期的な目的のための順序（例えば、2,3）のHOTP値を送信することを要求することができる。"
    },
    {
      "indent": 3,
      "text": "The upper bound set by the parameter s ensures the server does not go on checking HOTP values forever (causing a denial-of-service attack) and also restricts the space of possible solutions for an attacker trying to manufacture HOTP values. s SHOULD be set as low as possible, while still ensuring that usability is not impacted.",
      "ja": "パラメータの上限セットSは、サーバーが永久に永遠にHOTP値を確認しないことを確認し、攻撃者がHotP値を製造しようとしているための可能な解決策のスペースを制限します。■使用可能性が影響を及ぼさないようにしながら、Sはできるだけ低く設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5. Management of Shared Secrets",
      "section_title": true,
      "ja": "7.5. 共用秘密の管理"
    },
    {
      "indent": 3,
      "text": "The operations dealing with the shared secrets used to generate and verify OTP values must be performed securely, in order to mitigate risks of any leakage of sensitive information. We describe in this section different modes of operations and techniques to perform these different operations with respect to the state of the art in data security.",
      "ja": "機密情報の漏洩のリスクを軽減するために、OTP値を生成し検証するために使用される共有秘密を処理するために使用されなければならない。このセクションでは、データセキュリティにおける最新技術に関してこれらの異なる動作を実行するためのさまざまな動作モードとテクニックのモードについて説明します。"
    },
    {
      "indent": 3,
      "text": "We can consider two different avenues for generating and storing (securely) shared secrets in the Validation system:",
      "ja": "検証システムで共有秘密を生成して保存するための2つの異なる手当を検討することができます。"
    },
    {
      "indent": 6,
      "text": "* Deterministic Generation: secrets are derived from a master seed, both at provisioning and verification stages and generated on-the-fly whenever it is required. * Random Generation: secrets are generated randomly at provisioning stage and must be stored immediately and kept secure during their life cycle.",
      "ja": "* 決定論的生成：秘密は、プロビジョニングおよび検証段階で、およびそれが必要とされるたびにオンザフライで生成されたマスターシードから派生しています。*ランダム発生：秘密は、プロビジョニング段階でランダムに生成され、すぐに保存し、ライフサイクルの間安全に保たれなければなりません。"
    },
    {
      "indent": 3,
      "text": "Deterministic Generation\n------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A possible strategy is to derive the shared secrets from a master secret. The master secret will be stored at the server only. A tamper-resistant device MUST be used to store the master key and derive the shared secrets from the master key and some public information. The main benefit would be to avoid the exposure of the shared secrets at any time and also avoid specific requirements on storage, since the shared secrets could be generated on-demand when needed at provisioning and validation time.",
      "ja": "可能な戦略は、マスターシークレットから共有秘密を導き出すことです。マスターシークレットはサーバーにのみ保存されます。マスターキーを保管し、マスターキーといくつかの公開情報から共有された秘密を導き出すために、耐タンパーのデバイスを使用する必要があります。主な利点は、共有秘密の露出を回避し、プロビジョニングおよび検証の時間に必要な場合に共有された秘密がオンデマンドで生成される可能性があるため、Shared Secretsがストレージ上の特定の要件を回避することです。"
    },
    {
      "indent": 3,
      "text": "We distinguish two different cases:",
      "ja": "2つの異なるケースを区別します。"
    },
    {
      "indent": 6,
      "text": "- A single master key MK is used to derive the shared secrets; each HOTP device has a different secret, K_i = SHA-1 (MK,i) where i stands for a public piece of information that identifies uniquely the HOTP device such as a serial number, a token ID, etc. Obviously, this is in the context of an application or service -- different application or service providers will have different secrets and settings. - Several master keys MK_i are used and each HOTP device stores a set of different derived secrets, {K_i,j = SHA-1(MK_i,j)} where j stands for a public piece of information identifying the device. The idea would be to store ONLY the active master key at the validation server, in the Hardware Security Module (HSM), and keep in a safe place, using secret sharing methods such as [Shamir] for instance. In this case, if a master secret MK_i is compromised, then it is possible to switch to another secret without replacing all the devices.",
      "ja": "- シングルマスターキーMKを使用して共有秘密を導出する。各HOTPデバイスには、シリアル番号、トークンIDなどのHOTPデバイス、トークンIDなどの一意的に識別される公開情報が明らかに、これが存在するアプリケーションまたはサービスのコンテキスト - さまざまなアプリケーションまたはサービスプロバイダーには、秘密と設定が異なります。 - いくつかのマスタキーMK_Iが使用され、各HotPデバイスは異なる派生秘密のセットを格納し、ここでJはデバイスを識別する公開情報を表す。このアイデアは、検証サーバーのアクティブマスターキーのみをハードウェアセキュリティモジュール（HSM）に格納し、例えば[Shamir]などの秘密の共有方法を使用して安全な場所に保存することです。この場合、マスターシークレットMK_Iが危険にさらされている場合、すべてのデバイスを交換することなく別の秘密に切り替えることができます。"
    },
    {
      "indent": 3,
      "text": "The drawback in the deterministic case is that the exposure of the master secret would obviously enable an attacker to rebuild any shared secret based on correct public information. The revocation of all secrets would be required, or switching to a new set of secrets in the case of multiple master keys.",
      "ja": "決定論的な場合の欠点は、マスターシークレットのエクスポージャーが明らかに攻撃者が正しい公開情報に基づいて共有秘密を再構築できることです。複数のマスターキーの場合、すべての秘密の取り消しが必要です。または複数のマスターキーの場合は新しい秘密セットに切り替えます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the device used to store the master key(s) and generate the shared secrets MUST be tamper resistant. Furthermore, the HSM will not be exposed outside the security perimeter of the validation system, therefore reducing the risk of leakage.",
      "ja": "一方、マスターキーを保存し、共有秘密を生成するために使用される装置は、耐タンパーでなければなりません。さらに、HSMは検証システムのセキュリティ境界の外側に露出しないため、漏洩のリスクが低下します。"
    },
    {
      "indent": 3,
      "text": "Random Generation\n-----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The shared secrets are randomly generated. We RECOMMEND following the recommendations in [RFC4086] and selecting a good and secure random source for generating these secrets. A (true) random generator requires a naturally occurring source of randomness. Practically, there are two possible avenues to consider for the generation of the shared secrets:",
      "ja": "共有秘密はランダムに生成されます。[RFC4086]の推奨事項に従って、これらの秘密を生成するための良い安全なランダムソースを選択することをお勧めします。（真）ランダムジェネレータでは、天然に発生したランダム性源が必要です。実際には、共有秘密の生成について考慮すべき2つの方法があります。"
    },
    {
      "indent": 3,
      "text": " * Hardware-based generators: they exploit the randomness that occurs in physical phenomena. A nice implementation can be based on oscillators and built in such ways that active attacks are more difficult to perform.",
      "ja": "*ハードウェアベースの発電機：物理現象で発生したランダム性を悪用しています。素敵な実装は発振器に基づいており、そのような方法で活発な攻撃が実行が難しいという方法で構築できます。"
    },
    {
      "indent": 3,
      "text": " * Software-based generators: designing a good software random generator is not an easy task. A simple, but efficient, implementation should be based on various sources and apply to the sampled sequence a one-way function such as SHA-1.",
      "ja": "*ソフトウェアベースのジェネレータ：優れたソフトウェアランダムジェネレータの設計は簡単な作業ではありません。シンプルだが効率的な実装は、さまざまなソースに基づいており、サンプリングされたシーケンスにSHA-1などの一方向機能に適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND selecting proven products, being hardware or software generators, for the computation of shared secrets.",
      "ja": "共有秘密の計算のために、実績のある製品、ハードウェアまたはソフトウェアジェネレータであることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "We also RECOMMEND storing the shared secrets securely, and more specifically encrypting the shared secrets when stored using tamper-resistant hardware encryption and exposing them only when required: for example, the shared secret is decrypted when needed to verify an HOTP value, and re-encrypted immediately to limit exposure in the RAM for a short period of time. The data store holding the shared secrets MUST be in a secure area, to avoid as much as possible direct attack on the validation system and secrets database.",
      "ja": "また、共有秘密を安全に保存することをお勧めし、耐タンパーのハードウェア暗号化を使用して保存したときに共有秘密を暗号化し、必要な場合にのみそれらを公開している場合は、共有秘密を暗号化することをお勧めします。たとえば、Shared Secretは、HotP値を検証するために必要なときに復号化されます。すぐに暗号化されてRAMの露出を短時間制限します。共有された秘密を保持しているデータストアは、検証システムと秘密データベースに対するできる限り直接攻撃を回避するために安全な領域になければなりません。"
    },
    {
      "indent": 3,
      "text": "Particularly, access to the shared secrets should be limited to programs and processes required by the validation system only. We will not elaborate on the different security mechanisms to put in place, but obviously, the protection of shared secrets is of the uttermost importance.",
      "ja": "特に、共有秘密へのアクセスは、検証システムのみに必要なプログラムやプロセスに限定されるべきです。私たちは整備されるさまざまなセキュリティメカニズムについて詳しく述べることはできませんが、明らかに共有秘密の保護は最新の重要性です。"
    },
    {
      "indent": 0,
      "text": "8. Composite Shared Secrets",
      "section_title": true,
      "ja": "8. コンポジット共有秘密"
    },
    {
      "indent": 3,
      "text": "It may be desirable to include additional authentication factors in the shared secret K. These additional factors can consist of any data known at the token but not easily obtained by others. Examples of such data include:",
      "ja": "これらの追加の要因は、トークンで知られているが他のものによって容易に得られないデータからなることができる。そのようなデータの例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* PIN or Password obtained as user input at the token * Phone number * Any unique identifier programmatically available at the token",
      "ja": "* トークン*電話番号でユーザー入力として取得されたPINまたはパスワード*トークンでプログラムで利用可能な一意の識別子"
    },
    {
      "indent": 3,
      "text": "In this scenario, the composite shared secret K is constructed during the provisioning process from a random seed value combined with one or more additional authentication factors. The server could either build on-demand or store composite secrets -- in any case, depending on implementation choice, the token only stores the seed value. When the token performs the HOTP calculation, it computes K from the seed value and the locally derived or input values of the other authentication factors.",
      "ja": "このシナリオでは、複合共有シークレットKは、1つまたは複数の追加の認証要因と組み合わされたランダムシード値からプロビジョニングプロセス中に構築されます。サーバーは、オンデマンドまたはストアコンポジット秘密を構築することができます - いずれに応じて、実装の選択に応じて、トークンはシード値のみを格納します。トークンがHOTP計算を実行すると、シード値と他の認証係数の局所的に導出されたまたは入力値からkを計算します。"
    },
    {
      "indent": 3,
      "text": "The use of composite shared secrets can strengthen HOTP-based authentication systems through the inclusion of additional authentication factors at the token. To the extent that the token is a trusted device, this approach has the further benefit of not requiring exposure of the authentication factors (such as the user input PIN) to other devices.",
      "ja": "コンポジット共有秘密の使用は、トークンに追加の認証要素を含めることによってHOTPベースの認証システムを強化することができます。トークンが信頼できるデバイスである限り、このアプローチは、認証要因（ユーザ入力端子など）を他の機器に露出させないというさらなる利点を有する。"
    },
    {
      "indent": 0,
      "text": "9. Bi-Directional Authentication",
      "section_title": true,
      "ja": "9. 双方向認証"
    },
    {
      "indent": 3,
      "text": "Interestingly enough, the HOTP client could also be used to authenticate the validation server, claiming that it is a genuine entity knowing the shared secret.",
      "ja": "興味深いことに、HotPクライアントは検証サーバーを認証するために使用され、それが共有された秘密を知っている本物のエンティティであると主張することもできます。"
    },
    {
      "indent": 3,
      "text": "Since the HOTP client and the server are synchronized and share the\nsame secret (or a method to recompute it), a simple 3-pass protocol\ncould be put in place:\n1- The end user enter the TokenID and a first OTP value OTP1;\n2- The server checks OTP1 and if correct, sends back OTP2;\n3- The end user checks OTP2 using his HOTP device and if correct,\n   uses the web site.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Obviously, as indicated previously, all the OTP communications have to take place over a secure channel, e.g., SSL/TLS, IPsec connections.",
      "ja": "明らかに、前述のように、すべてのOTP通信は、SSL / TLS、IPsec接続を安全なチャネルで行わなければならない。"
    },
    {
      "indent": 0,
      "text": "10. Conclusion",
      "section_title": true,
      "ja": "10. 結論"
    },
    {
      "indent": 3,
      "text": "This document describes HOTP, a HMAC-based One-Time Password algorithm. It also recommends the preferred implementation and related modes of operations for deploying the algorithm.",
      "ja": "この文書では、HOTP、HMACベースのワンタイムパスワードアルゴリズムについて説明します。アルゴリズムを展開するための好ましい実装形態および関連する動作モードもまた推奨される。"
    },
    {
      "indent": 3,
      "text": "The document also exhibits elements of security and demonstrates that the HOTP algorithm is practical and sound, the best possible attack being a brute force attack that can be prevented by careful implementation of countermeasures in the validation server.",
      "ja": "この文書はまた、セキュリティの要素を示し、HOTPアルゴリズムが実用的で健全であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Eventually, several enhancements have been proposed, in order to improve security if needed for specific applications.",
      "ja": "最終的には、特定のアプリケーションに必要な場合はセキュリティを向上させるために、いくつかの機能強化が提案されています。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Siddharth Bajaj, Alex Deacon, Loren Hart, and Nico Popp for their help during the conception and redaction of this document.",
      "ja": "著者らは、Siddharth Bajaj、Alex Deacon、Loren Hart、およびNico Poppに感謝します。"
    },
    {
      "indent": 0,
      "text": "12. Contributors",
      "section_title": true,
      "ja": "12. 貢献者"
    },
    {
      "indent": 3,
      "text": "The authors of this document would like to emphasize the role of three persons who have made a key contribution to this document:",
      "ja": "この文書の著者は、この文書に重要な貢献をした3人の人の役割を強調したいと思います。"
    },
    {
      "indent": 3,
      "text": "- Laszlo Elteto is system architect with SafeNet, Inc.",
      "ja": "- Laszlo EltetoはSafenet、Inc。のシステムアーキテクトです。"
    },
    {
      "indent": 3,
      "text": "- Ernesto Frutos is director of Engineering with Authenex, Inc.",
      "ja": "- Ernesto FrutosはAuthenex、Inc。のエンジニアリングディレクターです。"
    },
    {
      "indent": 3,
      "text": "- Fred McClain is Founder and CTO with Boojum Mobile, Inc.",
      "ja": "- Fred McClainは創設者とBoojum Mobile、Inc。"
    },
    {
      "indent": 3,
      "text": "Without their advice and valuable inputs, this document would not be the same.",
      "ja": "彼らのアドバイスや貴重な入力がなければ、この文書は同じではありません。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BCK1] M. Bellare, R. Canetti and H. Krawczyk, \"Keyed Hash Functions and Message Authentication\", Proceedings of Crypto'96, LNCS Vol. 1109, pp. 1-15.",
      "ja": "[BCK1] M. Bellare、R. CanettiおよびH. Krawczyk、「キー付きハッシュ関数およびメッセージ認証」、Crypto'96、LNCS Vol。1109、PP。1-15。"
    },
    {
      "indent": 3,
      "text": "[BCK2] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[BCK2] Krawczyk、H.、Bellare、M.、およびR. Canetti、「HMAC：メッセージ認証のための鍵付きハジング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S、「RFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3979] Bradner, S., \"Intellectual Property Rights in IETF Technology\", BCP 79, RFC 3979, March 2005.",
      "ja": "[RFC3979] BRADNER、S、「IETF技術における知的財産権」、BCP 79、RFC 3979、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレイク、D.、第3、Schiller、J.、およびS. Crocker、「セキュリティのためのランダム性要件」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[OATH] Initiative for Open AuTHentication http://www.openauthentication.org",
      "ja": "[宣誓]オープン認証のためのイニシアチブhttp://www.openauthentication.org"
    },
    {
      "indent": 3,
      "text": "[PrOo] B. Preneel and P. van Oorschot, \"MD-x MAC and building fast MACs from hash functions\", Advances in Cryptology CRYPTO '95, Lecture Notes in Computer Science Vol. 963, D. Coppersmith ed., Springer-Verlag, 1995.",
      "ja": "[PRO] B. PreneelとP. van Oorschot、「ハッシュ関数からのMD-X MacとBuilsing Fast Mac」、Cryptology Crypto '95、Computer Science Vol。963、D.Coppersmith、Springer-Verlag、1995。"
    },
    {
      "indent": 3,
      "text": "[Crack]    Crack in SHA-1 code 'stuns' security gurus\n           http://www.eetimes.com/showArticle.jhtml?\n           articleID=60402150",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Sha1]     Bruce Schneier.  SHA-1 broken.  February 15, 2005.\n           http://www.schneier.com/blog/archives/2005/02/\n           sha1_broken.html",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Res]      Researchers: Digital encryption standard flawed\n           http://news.com.com/\n           Researchers+Digital+encryption+standard+flawed/\n           2100-1002-5579881.html?part=dht&tag=ntop&tag=nl.e703",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[Shamir] How to Share a Secret, by Adi Shamir. In Communications of the ACM, Vol. 22, No. 11, pp. 612-613, November, 1979.",
      "ja": "[Shamir] ADI Shamirによって秘密を共有する方法。ACMの通信では、Vol。22、No.11、pp.612-613、1979年11月。"
    },
    {
      "indent": 0,
      "text": "Appendix A - HOTP Algorithm Security: Detailed Analysis",
      "ja": "付録A  -  HOTPアルゴリズムのセキュリティ：詳細な分析"
    },
    {
      "indent": 3,
      "text": "The security analysis of the HOTP algorithm is summarized in this section. We first detail the best attack strategies, and then elaborate on the security under various assumptions and the impact of the truncation and make some recommendations regarding the number of digits.",
      "ja": "HOTPアルゴリズムのセキュリティ分析をこのセクションにまとめる。私たちは最初に最高の攻撃戦略を詳しく説明してから、さまざまな仮定の下でセキュリティを詳しく説明し、切り捨ての影響を与え、数字の数に関していくつかの推奨事項を作成します。"
    },
    {
      "indent": 3,
      "text": "We focus this analysis on the case where Digit = 6, i.e., an HOTP function that produces 6-digit values, which is the bare minimum recommended in this document.",
      "ja": "Digit = 6、すなわち6桁の値を生成するHOTP関数は、この解析に焦点を当てます。"
    },
    {
      "indent": 0,
      "text": "A.1. Definitions and Notations",
      "section_title": true,
      "ja": "A.1. 定義と表記法"
    },
    {
      "indent": 3,
      "text": "We denote by {0,1}^l the set of all strings of length l.",
      "ja": "{0,1} ^ Lでは、長さLのすべての文字列の集合。"
    },
    {
      "indent": 3,
      "text": "Let Z_{n} = {0,.., n - 1}.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Let IntDiv(a,b) denote the integer division algorithm that takes\ninput integers a, b where a >= b >= 1 and returns integers (q,r)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the quotient and remainder, respectively, of the division of a by b. (Thus, a = bq + r and 0 <= r < b.)",
      "ja": "a by bの分割の商と残りの商品。（したがって、A = BQ R、0 <= R <b。）"
    },
    {
      "indent": 3,
      "text": "Let H: {0,1}^k x {0,1}^c --> {0,1}^n be the base function that takes a k-bit key K and c-bit counter C and returns an n-bit output H(K,C). (In the case of HOTP, H is HMAC-SHA-1; we use this formal definition for generalizing our proof of security.)",
      "ja": "h：{0,1} ^ kx {0,1} ^ ^ c  - > {0,1} ^ nは、Kビット鍵KとCビットカウンタCをとる基本関数であり、N-を返します。ビット出力H（k、c）。（HOTPの場合、HはHMAC-SHA-1です。この正式な定義は、セキュリティの証明を一般化するために使用します。）"
    },
    {
      "indent": 0,
      "text": "A.2. The Idealized Algorithm: HOTP-IDEAL",
      "section_title": true,
      "ja": "A.2. 理想化されたアルゴリズム：hotp-eidial."
    },
    {
      "indent": 3,
      "text": "We now define an idealized counterpart of the HOTP algorithm. In this algorithm, the role of H is played by a random function that forms the key.",
      "ja": "これで、HOTPアルゴリズムの理想化された相手方を定義します。このアルゴリズムでは、hの役割はキーを形成するランダムな関数によって再生されます。"
    },
    {
      "indent": 3,
      "text": "To be more precise, let Maps(c,n) denote the set of all functions\nmapping from {0,1}^c to {0,1}^n.  The idealized algorithm has key\nspace Maps(c,n), so that a \"key\" for such an algorithm is a function\nh from {0,1}^c to {0,1}^n.  We imagine this key (function) to be\ndrawn at random.  It is not feasible to implement this idealized\nalgorithm, since the key, being a function from {0,1}^c to {0,1}^n,\nis way too large to even store.  So why consider it?",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Our security analysis will show that as long as H satisfies a certain well-accepted assumption, the security of the actual and idealized algorithms is for all practical purposes the same. The task that really faces us, then, is to assess the security of the idealized algorithm.",
      "ja": "我々のセキュリティ分析は、hが一定の妥当な仮定を満たす限り、実際の理想的なアルゴリズムのセキュリティはすべて同じ目的のためのものであることを示す。本当に私たちに直面しているタスクは、理想化されたアルゴリズムのセキュリティを評価することです。"
    },
    {
      "indent": 3,
      "text": "In analyzing the idealized algorithm, we are concentrating on assessing the quality of the design of the algorithm itself, independently of HMAC-SHA-1. This is in fact the important issue.",
      "ja": "理想化されたアルゴリズムを分析する際には、HMAC-SHA-1とは無関係に、アルゴリズム自体の設計の品質を評価することに集中しています。これは実際には重要な問題です。"
    },
    {
      "indent": 0,
      "text": "A.3. Model of Security",
      "section_title": true,
      "ja": "A.3. セキュリティのモデル"
    },
    {
      "indent": 3,
      "text": "The model exhibits the type of threats or attacks that are being considered and enables one to assess the security of HOTP and HOTP-IDEAL. We denote ALG as either HOTP or HOTP-IDEAL for the purpose of this security analysis.",
      "ja": "このモデルは、検討されている脅威や攻撃の種類を示し、HOTPとHOTPのセキュリティを評価することができます。このセキュリティ分析の目的で、HOTPまたはHOTPのどちらかとしてALGを表します。"
    },
    {
      "indent": 3,
      "text": "The scenario we are considering is that a user and server share a key K for ALG. Both maintain a counter C, initially zero, and the user authenticates itself by sending ALG(K,C) to the server. The latter accepts if this value is correct.",
      "ja": "私たちが検討しているシナリオは、ユーザーとサーバーがALGのためのキーKを共有することです。カウンタC、最初はゼロを維持し、ユーザはALG（k、c）をサーバに送信することによってそれ自体を認証する。この値が正しい場合は後者が受け入れます。"
    },
    {
      "indent": 3,
      "text": "In order to protect against accidental increment of the user counter, the server, upon receiving a value z, will accept as long as z equals ALG(K,i) for some i in the range C,...,C + s-1, where s is the resynchronization parameter and C is the server counter. If it accepts with some value of i, it then increments its counter to i+1. If it does not accept, it does not change its counter value.",
      "ja": "ユーザカウンタの偶発的な増分から保護するために、値zを受信すると、サーバは、zがC、...、C S  -  1の範囲内のALG（k、i）がa al（k、i）である限り受け入れるであろう。ここで、sは再同期パラメータで、Cはサーバーカウンタです。それがいくつかの値で受け入れている場合は、そのカウンタをI 1にインクリメントします。受け入れない場合は、そのカウンタ値は変更されません。"
    },
    {
      "indent": 3,
      "text": "The model we specify captures what an adversary can do and what it needs to achieve in order to \"win\". First, the adversary is assumed to be able to eavesdrop, meaning, to see the authenticator transmitted by the user. Second, the adversary wins if it can get the server to accept an authenticator relative to a counter value for which the user has never transmitted an authenticator.",
      "ja": "モデルは、敵対者ができることとそれが「勝利」するために達成する必要があるものを捉えます。まず、敵対者は、ユーザーが送信したオーセンティケータを見るために盗聴することができると想定されています。第二に、敵対者は、ユーザが認証者を送信したことがないカウンタ値を基準にしてサーバを認証者に受け入れることができる場合に勝利する。"
    },
    {
      "indent": 3,
      "text": "The formal adversary, which we denote by B, starts out knowing which algorithm ALG is being used, knowing the system design, and knowing all system parameters. The one and only thing it is not given a priori is the key K shared between the user and the server.",
      "ja": "Bで表す正式な敵対者は、どのアルゴリズムALGが使用されているか、システム設計を知っているか、およびすべてのシステムパラメータを知ることを知っています。それが先験的に与えられていないものだけではなく、ユーザーとサーバーの間で共有されているキーKです。"
    },
    {
      "indent": 3,
      "text": "The model gives B full control of the scheduling of events. It has access to an authenticator oracle representing the user. By calling this oracle, the adversary can ask the user to authenticate itself and get back the authenticator in return. It can call this oracle as often as it wants and when it wants, using the authenticators it accumulates to perhaps \"learn\" how to make authenticators itself. At any time, it may also call a verification oracle, supplying the latter with a candidate authenticator of its choice. It wins if the server accepts this accumulator.",
      "ja": "モデルはBイベントのスケジューリングの完全な制御を与えます。ユーザーを表すオーセンティケータオラクルにアクセスできます。このOracleを呼び出すことで、敵対者はユーザーに自分自身を認証し、認証者を返すように依頼することができます。これは、このオラクルを望んでいるのと同じくらい頻繁に呼び、いつ、それが際立ったときにそれが累積した認証者を「学習」自体の作り方」を「学習」します。いつでも、検証オラクルを呼び出して、後者をその選択の候補認証者に供給することもできます。サーバーがこのアキュムレータを受け入れると勝ちます。"
    },
    {
      "indent": 3,
      "text": "Consider the following game involving an adversary B that is attempting to compromise the security of an authentication algorithm ALG: K x {0,1}^c --> R.",
      "ja": "認証アルゴリズムalgのセキュリティを危うくしようとしている敵対的Bを含む次のゲームを考慮してください.K X {0,1} ^ C  -  R."
    },
    {
      "indent": 3,
      "text": "Initializations - A key K is selected at random from K, a counter C is initialized to 0, and the Boolean value win is set to false.",
      "ja": "初期化 -  Key kがkからランダムに選択され、カウンタCが0に初期化され、ブール値Winがfalseに設定されます。"
    },
    {
      "indent": 3,
      "text": "Game execution - Adversary B is provided with the two following oracles:",
      "ja": "ゲームの実行 - 敵対者Bは、次の2つの企業があります。"
    },
    {
      "indent": 3,
      "text": "Oracle AuthO()\n--------------\n   A = ALG(K,C)\n   C = C + 1\n   Return O to B",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Oracle VerO(A)\n--------------\n   i = C\n   While (i <= C + s - 1 and Win == FALSE) do\n      If A == ALG(K,i) then Win = TRUE; C = i + 1\n      Else i = i + 1\n   Return Win to B",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AuthO() is the authenticator oracle and VerO(A) is the verification oracle.",
      "ja": "autho（）はオーセンティケーターOracleで、Vero（A）は検証Oracleです。"
    },
    {
      "indent": 3,
      "text": "Upon execution, B queries the two oracles at will. Let Adv(B) be the probability that win gets set to true in the above game. This is the probability that the adversary successfully impersonates the user.",
      "ja": "実行時に、Bは2つの造られます。上記のゲームでは、勝利が勝利する確率になる可能性があります。これは、敵対者がユーザーを首尾よく偽装する確率です。"
    },
    {
      "indent": 3,
      "text": "Our goal is to assess how large this value can be as a function of the number v of verification queries made by B, the number a of authenticator oracle queries made by B, and the running time t of B. This will tell us how to set the throttle, which effectively upper bounds v.",
      "ja": "私たちの目標は、Bによって行われたAuthenticator Oracleクエリの数字A、Bの実行時刻T、BのランニングタイムTの数値A、およびBのランニングタイムTの数値vの関数として、この値を評価することです。スロットルを設定します。これは効果的に上限vです。"
    },
    {
      "indent": 0,
      "text": "A.4. Security of the Ideal Authentication Algorithm",
      "section_title": true,
      "ja": "A.4. 理想認証アルゴリズムのセキュリティ"
    },
    {
      "indent": 3,
      "text": "This section summarizes the security analysis of HOTP-IDEAL, starting with the impact of the conversion modulo 10^Digit and then focusing on the different possible attacks.",
      "ja": "このセクションでは、変換モジュロ10 ^桁の影響から始めて、その後異なる可能な攻撃に焦点を当ててから、HOTP理想のセキュリティ分析を要約します。"
    },
    {
      "indent": 0,
      "text": "A.4.1. From Bits to Digits",
      "section_title": true,
      "ja": "A.4.1. ビットから数字へ"
    },
    {
      "indent": 0,
      "text": " The dynamic offset truncation of a random n-bit string yields a random 31-bit string. What happens to the distribution when it is taken modulo m = 10^Digit, as done in HOTP? The following lemma estimates the biases in the outputs in this case.",
      "ja": "ランダムなnビット列の動的オフセット切り捨ては、ランダムな31ビット文字列を生成します。HOTPで行われたように、M = 10 ^桁のモジュロM = 10 ^桁の桁数が得られるのは何ですか？次のLEMMAは、この場合の出力のバイアスを推定します。"
    },
    {
      "indent": 3,
      "text": "Lemma 1\n-------\nLet N >= m >= 1 be integers, and let (q,r) = IntDiv(N,m).  For z in\nZ_{m} let:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Then for any z in Z_{m}",
      "ja": "それからz_ {m}のzのzについて"
    },
    {
      "indent": 3,
      "text": "P_{N,m}(z) =   (q + 1) / N    if 0 <= z < r\n               q / N          if r <= z < m",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Proof of Lemma 1\n----------------\nLet the random variable X be uniformly distributed over Z_{N}.  Then:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "P_{N,m}(z)  = Pr [X mod m = z]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "= Pr [X < mq] * Pr [X mod m = z| X < mq]\n+ Pr [mq <= X < N] * Pr [X mod m = z| mq <= X < N]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "= mq/N * 1/m +\n   (N - mq)/N * 1 / (N - mq)     if 0 <= z < N - mq\n   0                             if N - mq <= z <= m",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "= q/N +\n   r/N * 1 / r                   if 0 <= z < N - mq\n   0                             if r <= z <= m",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simplifying yields the claimed equation.",
      "ja": "単純化は要求された式を歩留まります。"
    },
    {
      "indent": 3,
      "text": "Let N = 2^31, d = 6, and m = 10^d. If x is chosen at random from Z_{N} (meaning, is a random 31-bit string), then reducing it to a 6- digit number by taking x mod m does not yield a random 6-digit number.",
      "ja": "n = 2 ^ 31、d = 6、およびm = 10 ^ dとする。xがz_ {n}からランダムに選択された場合（つまりランダムな31ビット文字列）、x mod mを取ることによって6桁の数値を減らすことはランダムな6桁の数字を生成しません。"
    },
    {
      "indent": 3,
      "text": "Rather, x mod m is distributed as shown in the following table:",
      "ja": "むしろ、X MOD Mは次の表に示すように分散されています。"
    },
    {
      "indent": 3,
      "text": "Values               Probability that each appears as output\n----------------------------------------------------------------\n0,1,...,483647       2148/2^31 roughly equals to 1.00024045/10^6\n483648,...,999999    2147/2^31 roughly equals to 0.99977478/10^6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " If X is uniformly distributed over Z_{2^31} (meaning, is a random 31-bit string), then the above shows the probabilities for different outputs of X mod 10^6. The first set of values appears with probability slightly greater than 10^-6, the rest with probability slightly less, meaning that the distribution is slightly non-uniform.",
      "ja": "xがz_ {2 ^ 31}（つまりランダムな31ビット文字列）を介して一様に分布している場合、上記はX MOD 10 ^ 6の異なる出力に対する確率を示しています。最初の値のセットは、10 ^ -6よりわずかに大きい確率で、確率はわずかに少ない残り、つまり分布はわずかに不均一です。"
    },
    {
      "indent": 3,
      "text": "However, as the table above indicates, the bias is small, and as we will see later, negligible: the probabilities are very close to 10^-6.",
      "ja": "しかしながら、上の表は示されているので、バイアスは小さいので、後で見ても見られるように、確率は10 ^ -6に非常に近い。"
    },
    {
      "indent": 0,
      "text": "A.4.2. Brute Force Attacks",
      "section_title": true,
      "ja": "A.4.2. ブルートフォース攻撃"
    },
    {
      "indent": 3,
      "text": "If the authenticator consisted of d random digits, then a brute force attack using v verification attempts would succeed with probability sv/10^Digit.",
      "ja": "オーセンティケータがDランダムな数字で構成されている場合、V検証試行を使用したブルートフォース攻撃は確率SV / 10 ^桁で成功します。"
    },
    {
      "indent": 3,
      "text": "However, an adversary can exploit the bias in the outputs of HOTP-IDEAL, predicted by Lemma 1, to mount a slightly better attack.",
      "ja": "しかしながら、敵対者は、LEMMA 1によって予測されたHOTP  - 理想の出力におけるバイアスを利用して、わずかに優れた攻撃を取り付けることができる。"
    },
    {
      "indent": 3,
      "text": "Namely, it makes authentication attempts with authenticators that are the most likely values, meaning the ones in the range 0,...,r - 1, where (q,r) = IntDiv(2^31,10^Digit).",
      "ja": "すなわち、最も可能性の高い値であるオーセンティケーターを使用して認証を試みます。これは、0、...、R-1の範囲内のもの、ここで（q、r）= intdiv（2 ^ 31,10 ^桁）です。"
    },
    {
      "indent": 3,
      "text": "The following specifies an adversary in our model of security that mounts the attack. It estimates the success probability as a function of the number of verification queries.",
      "ja": "以下は、攻撃をマウントするセキュリティのモデルの敵対者を指定しています。それは、検証クエリの数の関数としての成功確率を推定します。"
    },
    {
      "indent": 3,
      "text": "For simplicity, we assume that the number of verification queries is at most r. With N = 2^31 and m = 10^6, we have r = 483,648, and the throttle value is certainly less than this, so this assumption is not much of a restriction.",
      "ja": "簡単にするために、検証クエリの数が最大であると仮定します。n = 2 ^ 31およびm = 10 ^ 6では、r = 483,648であり、スロットル値は確かにこれよりも小さいので、この仮定はそれほど制限のなかった。"
    },
    {
      "indent": 3,
      "text": "Proposition 1\n-------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Suppose m = 10^Digit < 2^31, and let (q,r) = IntDiv(2^31,m).  Assume\ns <= m.  The brute-force-attack adversary B-bf attacks HOTP using v\n<= r verification oracle queries.  This adversary makes no\nauthenticator oracle queries, and succeeds with probability",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Adv(B-bf) = 1 - (1 - v(q+1)/2^31)^s",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "which is roughly equal to",
      "ja": "これはほぼ同じです"
    },
    {
      "indent": 29,
      "text": "sv * (q+1)/2^31",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "With m = 10^6 we get q = 2,147. In that case, the brute force attack using v verification attempts succeeds with probability",
      "ja": "M = 10 ^ 6では、Q = 2,147が得られます。その場合、V検証試行を使用したブルートフォース攻撃は確率で成功します"
    },
    {
      "indent": 9,
      "text": "Adv(B-bf) roughly = sv * 2148/2^31 = sv * 1.00024045/10^6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As this equation shows, the resynchronization parameter s has a significant impact in that the adversary's success probability is proportional to s. This means that s cannot be made too large without compromising security.",
      "ja": "この式が示すように、再同期パラメータsは、敵の成功確率がsに比例するという点で大きな影響を及ぼします。これは、セキュリティを犠牲にすることなくSを大きすぎることができないことを意味します。"
    },
    {
      "indent": 0,
      "text": "A.4.3. Brute force attacks are the best possible attacks.",
      "ja": "A.4.3. ブルートフォース攻撃は可能な限り最高の攻撃です。"
    },
    {
      "indent": 3,
      "text": "A central question is whether there are attacks any better than the brute force one. In particular, the brute force attack did not attempt to collect authenticators sent by the user and try to cryptanalyze them in an attempt to learn how to better construct authenticators. Would doing this help? Is there some way to \"learn\" how to build authenticators that result in a higher success rate than given by the brute-force attack?",
      "ja": "中心的な問題は、ブルートフォースよりも攻撃が優れているかどうかです。特に、ブルートフォース攻撃は、ユーザーが送信した認証者を集め、認証者をより適切に構築する方法を学びようとしてみてください。この助けをしているのですか？ブルートフォース攻撃によって与えられるよりも高い成功率をもたらす認証者を構築する方法を「学ぶ」ための方法はありますか？"
    },
    {
      "indent": 3,
      "text": "The following says the answer to these questions is no. No matter what strategy the adversary uses, and even if it sees, and tries to exploit, the authenticators from authentication attempts of the user, its success probability will not be above that of the brute force attack -- this is true as long as the number of authentications it observes is not incredibly large. This is valuable information regarding the security of the scheme.",
      "ja": "次に、これらの質問に対する答えはノーです。敵対者がどのような戦略であっても、たとえそれが見ていて、そしてそれが誰かを見て、そして悪用しようとしていても、ユーザの認証の試みからの認証能力は、その成功確率はブルートフォース攻撃のそれほど上回らないであろう。それが観察する認証数は信じられないほど大きくありません。これはスキームのセキュリティに関する貴重な情報です。"
    },
    {
      "indent": 3,
      "text": "Proposition 2 ------------- Suppose m = 10^Digit < 2^31, and let\n(q,r) = IntDiv(2^31,m).  Let B be any adversary attacking HOTP-IDEAL\nusing v verification oracle queries and a <= 2^c - s authenticator\noracle queries.  Then",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Adv(B) < = sv * (q+1)/ 2^31",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: This result is conditional on the adversary not seeing more than 2^c - s authentications performed by the user, which is hardly restrictive as long as c is large enough.",
      "ja": "注：この結果は、ユーザーが2 ^ C  -  S以上の認証を見ていない致命者に関する条件付きであり、Cが十分に大きい限り制限がありません。"
    },
    {
      "indent": 3,
      "text": "With m = 10^6, we get q = 2,147. In that case, Proposition 2 says that any adversary B attacking HOTP-IDEAL and making v verification attempts succeeds with probability at most",
      "ja": "M = 10 ^ 6では、Q = 2,147になります。その場合、命題2は、HOTP理想を攻撃し、V検証の試みを行うことが一番なしに成功したと述べています。"
    },
    {
      "indent": 3,
      "text": "Equation 1\n----------\n           sv * 2148/2^31 roughly = sv * 1.00024045/10^6",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Meaning, B's success rate is not more than that achieved by the brute force attack.",
      "ja": "意味、Bの成功率は、ブルートフォース攻撃によって達成されたもの以上のものではありません。"
    },
    {
      "indent": 0,
      "text": "A.5. Security Analysis of HOTP",
      "section_title": true,
      "ja": "A.5. Hotpのセキュリティ分析"
    },
    {
      "indent": 3,
      "text": "We have analyzed, in the previous sections, the security of the idealized counterparts HOTP-IDEAL of the actual authentication algorithm HOTP. We now show that, under appropriate and well-believed assumption on H, the security of the actual algorithms is essentially the same as that of its idealized counterpart.",
      "ja": "実際の認証アルゴリズムのHOTPの理想的な理想的な理想的な対応物のセキュリティを前のセクションで分析しました。我々は今、適切でゆったりとした仮定の下で、実際のアルゴリズムのセキュリティは、その理想化された相手方のセキュリティと基本的に同じであることを示しています。"
    },
    {
      "indent": 3,
      "text": "The assumption in question is that H is a secure pseudorandom function, or PRF, meaning that its input-output values are indistinguishable from those of a random function in practice.",
      "ja": "問題の仮定は、Hが安全な疑似乱数関数、またはPRFであり、その入力出力値は実際にはランダム関数のものと区別がつかないことです。"
    },
    {
      "indent": 3,
      "text": "Consider an adversary A that is given an oracle for a function f: {0,1}^c --> {0, 1}^n and eventually outputs a bit. We denote Adv(A) as the prf-advantage of A, which represents how well the adversary does at distinguishing the case where its oracle is H(K,.) from the case where its oracle is a random function of {0,1}^c to {0,1}^n.",
      "ja": "関数f：{0,1} ^ c  - > {0,1} ^ nに対してOracleが与えられた敵対Aを検討し、最終的にビットを出力します。ADV（A）をAのPRFアドバンテージとして、OracleがOracleが{0,1のランダムな関数である場合から区別しているかを区別することができるかを表す。{0,1} ^ nから{0,1} ^ n。"
    },
    {
      "indent": 3,
      "text": "One possible attack is based on exhaustive search for the key K. If A runs for t steps and T denotes the time to perform one computation of H, its prf-advantage from this attack turns out to be (t/T)2^-k. Another possible attack is a birthday one [PrOo], whereby A can attain advantage p^2/2^n in p oracle queries and running time about pT.",
      "ja": "1つの可能な攻撃は、キーKの徹底的な検索に基づいています.TステップとTの実行がHの1つの計算を実行する時間を表す場合、この攻撃からのPRFアドバンテージは（T / T）2  - です。k。もう1つの可能な攻撃は誕生日1 [Proo]です。"
    },
    {
      "indent": 3,
      "text": "Our assumption is that these are the best possible attacks. This translates into the following.",
      "ja": "私たちの仮定は、これらが最高の可能な攻撃であることです。これは次のところに変換されます。"
    },
    {
      "indent": 3,
      "text": "Assumption 1\n------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Let T denotes the time to perform one computation of H. Then if A is any adversary with running time at most t and making at most p oracle queries,",
      "ja": "aの1つの計算を実行する時間を表す.Aが走行時間が経過し、ほとんどのP Oracle Queriesで行われた場合、"
    },
    {
      "indent": 23,
      "text": "Adv(A) <= (t/T)/2^k + p^2/2^n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In practice, this assumption means that H is very secure as PRF. For example, given that k = n = 160, an attacker with running time 2^60 and making 2^40 oracle queries has advantage at most (about) 2^-80.",
      "ja": "実際には、この仮定は、HがPRFとして非常に安全であることを意味します。たとえば、k = n = 160であることを考えると、実行時間2 ^ 60の攻撃者、および2 ^ 40 Oracleクエリには、最大（約）2 ^ -80が有利です。"
    },
    {
      "indent": 3,
      "text": "Theorem 1\n---------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   Suppose m = 10^Digit < 2^31, and let (q,r) = IntDiv(2^31,m).  Let B\n   be any adversary attacking HOTP using v verification oracle queries,\n   a <= 2^c - s authenticator oracle queries, and running time t.  Let T\n   denote the time to perform one computation of H.  If Assumption 1 is\n   true, then",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Adv(B) <= sv * (q + 1)/2^31 + (t/T)/2^k + ((sv + a)^2)/2^n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In practice, the (t/T)2^-k + ((sv + a)^2)2^-n term is much smaller than the sv(q + 1)/2^n term, so that the above says that for all practical purposes the success rate of an adversary attacking HOTP is sv(q + 1)/2^n, just as for HOTP-IDEAL, meaning the HOTP algorithm is in practice essentially as good as its idealized counterpart.",
      "ja": "実際には、（T / T）2 ^ -K（（SV A）^ 2）2 ^ -N項はSV（Q 1）/ 2 ^ N項よりもはるかに小さいので、上記はすべてについて実用的な目的は、攻撃の攻撃の成功率は、HOTP理想と同じくらいSV（Q 1）/ 2 ^ Nです。"
    },
    {
      "indent": 3,
      "text": "In the case m = 10^6 of a 6-digit output, this means that an adversary making v authentication attempts will have a success rate that is at most that of Equation 1.",
      "ja": "6桁の出力のM = 10 ^ 6の場合、これは、逆のv認証試行が、ほとんどの式1の成功率を持つことを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, consider an adversary with running time at most 2^60 that sees at most 2^40 authentication attempts of the user. Both these choices are very generous to the adversary, who will typically not have these resources, but we are saying that even such a powerful adversary will not have more success than indicated by Equation 1.",
      "ja": "たとえば、最大2 ^ 60で実行されているランニングタイムを持つ敵対者を検討してください。これらの選択は両方とも敵対者に非常に寛大ですが、通常これらのリソースを持っていませんが、そのような強力な敵対者でさえ、式1で示されるよりも多くの成功を持たないと言っています。"
    },
    {
      "indent": 3,
      "text": "We can safely assume sv <= 2^40 due to the throttling and bounds on s. So:",
      "ja": "SV <= 2 ^ 40をSV <= 2 ^ 40と仮定することができます。そう："
    },
    {
      "indent": 7,
      "text": "(t/T)/2^k + ((sv + a)^2)/2^n  <= 2^60/2^160 + (2^41)^2/2^160\n                             roughly <= 2^-78",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "which is much smaller than the success probability of Equation 1 and negligible compared to it.",
      "ja": "これは、式1の成功確率よりはるかに小さく、それと比較して無視できる。"
    },
    {
      "indent": 0,
      "text": "Appendix B - SHA-1 Attacks",
      "ja": "付録B  -  SHA-1攻撃"
    },
    {
      "indent": 3,
      "text": "This sections addresses the impact of the recent attacks on SHA-1 on the security of the HMAC-SHA-1-based HOTP. We begin with some discussion of the situation of SHA-1 and then discuss the relevance to HMAC-SHA-1 and HOTP. Cited references are in Section 13.",
      "ja": "このセクションでは、HMAC-SHA-1ベースのHOTPのセキュリティに対するSHA-1に対する最近の攻撃の影響について説明します。SHA-1の状況についてのいくつかの議論から始めて、HMAC-SHA-1とHOTPとの関連性について説明します。引用文献はセクション13にあります。"
    },
    {
      "indent": 0,
      "text": "B.1. SHA-1 Status",
      "section_title": true,
      "ja": "B.1. SHA-1ステータス"
    },
    {
      "indent": 3,
      "text": "A collision for a hash function h means a pair x,y of different inputs such that h(x)=h(y). Since SHA-1 outputs 160 bits, a birthday attack finds a collision in 2^{80} trials. (A trial means one computation of the function.) This was thought to be the best possible until Wang, Yin, and Yu announced on February 15, 2005, that they had an attack finding collisions in 2^{69} trials.",
      "ja": "ハッシュ関数hの衝突は、H（x）= h（y）のような異なる入力のペアx、yを意味する。SHA-1は160ビットを出力するので、誕生日攻撃は2 ^ {80}試験で衝突を見つけます。これは、2005年2月15日に2 ^ {69}試験で衝突を発見した攻撃を受けたことを発表したと考えられたものです。"
    },
    {
      "indent": 3,
      "text": "Is SHA-1 broken? For most practical purposes, we would say probably not, since the resources needed to mount the attack are huge. Here is one way to get a sense of it: we can estimate it is about the same as the time we would need to factor a 760-bit RSA modulus, and this is currently considered out of reach.",
      "ja": "Sha-1は壊れていますか？ほとんどの実用的な目的のために、攻撃をマウントするのに必要なリソースが大きいので、おそらく私たちはおそらく言うでしょう。ここに感覚を得る1つの方法があります。"
    },
    {
      "indent": 3,
      "text": "Burr of NIST is quoted in [Crack] as saying \"Large national intelligence agencies could do this in a reasonable amount of time with a few million dollars in computer time\". However, the computation may be out of reach of all but such well-funded agencies.",
      "ja": "「大規模な国家知能機関は、コンピュータの時間に数百万ドルで妥当な時間でこれを行うことができる」と言って、NISTのバリが「クラック」で引用されています。ただし、計算は、そのような充実した機関全ての範囲の範囲外であり得る。"
    },
    {
      "indent": 3,
      "text": "One should also ask what impact finding SHA-1 collisions actually has on security of real applications such as signatures. To exploit a collision x,y to forge signatures, you need to somehow obtain a signature of x and then you can forge a signature of y. How damaging this is depends on the content of y: the y created by the attack may not be meaningful in the application context. Also, one needs a chosen-message attack to get the signature of x. This seems possible in some contexts, but not others. Overall, it is not clear that the impact on the security of signatures is significant.",
      "ja": "SHA-1衝突を見つけることは、実際に署名などの実際のアプリケーションのセキュリティに与える影響についても尋ねるべきです。衝突X、Yを求めるために衝突Xを搾取するには、どういうわけかXの署名を取得する必要があります。これがどのように損害を与えるかはYの内容によって異なります。攻撃によって作成されたYは、アプリケーションのコンテキストでは意味がありません。また、xの署名を取得するための選択されたメッセージ攻撃が必要です。これはいくつかの状況では可能性がありますが、他のものではありません。全体として、署名のセキュリティへの影響が重要であることは明らかではありません。"
    },
    {
      "indent": 3,
      "text": "Indeed, one can read in the press that SHA-1 is \"broken\" [Sha1] and that encryption and SSL are \"broken\" [Res]. The media have a tendency to magnify events: it would hardly be interesting to announce in the news that a team of cryptanalysts did very interesting theoretical work in attacking SHA-1.",
      "ja": "確かに、SHA-1が「壊れた」[SHA1]であり、その暗号化とSSLが「壊れた」[RES]であるプレスで読むことができます。メディアはイベントを拡大する傾向があります。暗号化のチームがSHA-1を攻撃する際に非常に興味深い仕事をしたというニュースで発表するのは面白いでしょう。"
    },
    {
      "indent": 3,
      "text": "Cryptographers are excited too. But mainly because this is an important theoretical breakthrough. Attacks can only get better with time: it is therefore important to monitor any progress in hash functions cryptanalysis and be prepared for any really practical break with a sound migration plan for the future.",
      "ja": "暗号化器も興奮しています。しかし主にこれは重要な理論的な進歩です。攻撃は時間とともに良くなることができるだけです。したがって、ハッシュ関数の暗号解読の進歩を監視し、将来のサウンド移行計画で本当に実用的な休憩のために準備することが重要です。"
    },
    {
      "indent": 0,
      "text": "B.2. HMAC-SHA-1 Status",
      "section_title": true,
      "ja": "B.2. HMAC-SHA-1ステータス"
    },
    {
      "indent": 3,
      "text": "The new attacks on SHA-1 have no impact on the security of HMAC-SHA-1. The best attack on the latter remains one needing a sender to authenticate 2^{80} messages before an adversary can create a forgery. Why?",
      "ja": "SHA-1への新しい攻撃は、HMAC-SHA-1のセキュリティに影響を与えません。後者の最良の攻撃は、敵対者が偽造を作成することができる前に、送信者が2 ^ {80}メッセージを認証するために送信者を必要としています。どうして？"
    },
    {
      "indent": 3,
      "text": "HMAC is not a hash function. It is a message authentication code (MAC) that uses a hash function internally. A MAC depends on a secret key, while hash functions don't. What one needs to worry about with a MAC is forgery, not collisions. HMAC was designed so that collisions in the hash function (here SHA-1) do not yield forgeries for HMAC.",
      "ja": "HMACはハッシュ関数ではありません。それは内部的にハッシュ関数を使用するメッセージ認証コード（Mac）です。MACは秘密鍵によって異なりますが、ハッシュ関数はしません。Macで心配する必要があるのは、衝突ではなく偽造です。HACは、ハッシュ関数（ここでのSHA-1）内の衝突がHMACのための偽造物を生み出さないように設計されました。"
    },
    {
      "indent": 3,
      "text": "Recall that HMAC-SHA-1(K,x) = SHA-1(K_o,SHA-1(K_i,x)) where the keys K_o,K_i are derived from K. Suppose the attacker finds a pair x,y such that SHA-1(K_i,x) = SHA-1(K_i,y). (Call this a hidden-key collision.) Then if it can obtain the MAC of x (itself a tall order), it can forge the MAC of y. (These values are the same.) But finding hidden-key collisions is harder than finding collisions, because the attacker does not know the hidden key K_i. All it may have is some outputs of HMAC-SHA-1 with key K. To date, there are no claims or evidence that the recent attacks on SHA-1 extend to find hidden-key collisions.",
      "ja": "k_o、k_iがKから導出されるHMAC-SHA-1（K_O、SHA-1（k_i、x））を思い出します。攻撃者がペアXを見つけたとします。SHA-1（K_I、X）= SHA-1（K_I、Y）。（これは隠れた衝突を呼び出します。）次に、XのMacを取得できる場合は、Macをyのmacを鍛造できます。（これらの値は同じです。）しかし、攻撃者が隠しキーK_Iを知らないため、隠蔽キーの衝突を見つけることは衝突を見つけるよりも難しいです。今日までのHMAC-SHA-1のいくつかの出力は、これまでに、最近のSHA-1に対する最近の攻撃が隠れた衝突を見つけるために延長されたという主張または証拠はありません。"
    },
    {
      "indent": 3,
      "text": "Historically, the HMAC design has already proven itself in this regard. MD5 is considered broken in that collisions in this hash function can be found relatively easily. But there is still no attack on HMAC-MD5 better than the trivial 2^{64} time birthday one. (MD5 outputs 128 bits, not 160.) We are seeing this strength of HMAC coming into play again in the SHA-1 context.",
      "ja": "歴史的に、HMACデザインはすでにこの点でそれ自体を証明しています。MD5は、このハッシュ関数における衝突が比較的容易に見つけることができるという点で壊れていると考えられる。しかし、些細な2 ^ {64}の時間誕生日よりもHMAC-MD5にまだ攻撃はありません。（MD5出力128ビット、160）私たちは、HMACの強さがSHA-1コンテキストで再びプレイするのを見ています。"
    },
    {
      "indent": 0,
      "text": "B.3. HOTP Status",
      "section_title": true,
      "ja": "B.3. HOTPのステータス"
    },
    {
      "indent": 3,
      "text": "Since no new weakness has surfaced in HMAC-SHA-1, there is no impact on HOTP. The best attacks on HOTP remain those described in the document, namely, to try to guess output values.",
      "ja": "HMAC-SHA-1に新たな弱点が浮上していないため、HOTPに影響はありません。HOTPに対する最良の攻撃は、文書に記載されているもの、すなわち出力値を推測しようとしています。"
    },
    {
      "indent": 3,
      "text": "The security proof of HOTP requires that HMAC-SHA-1 behave like a pseudorandom function. The quality of HMAC-SHA-1 as a pseudorandom function is not impacted by the new attacks on SHA-1, and so neither is this proven guarantee.",
      "ja": "HOTPのセキュリティ証明には、HMAC-SHA-1が疑似ランダム機能のように動作することが必要です。疑似ランダム関数としてのHMAC-SHA-1の品質は、SHA-1への新しい攻撃によって影響を受けません。したがって、これは証明されていません。"
    },
    {
      "indent": 0,
      "text": "Appendix C - HOTP Algorithm: Reference Implementation",
      "ja": "付録C  -  HOTPアルゴリズム：参照実装"
    },
    {
      "indent": 3,
      "text": "/*\n * OneTimePasswordAlgorithm.java\n * OATH Initiative,\n * HOTP one-time password algorithm\n *\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Copyright (C) 2004, OATH.  All rights reserved.\n *\n * License to copy and use this software is granted provided that it\n * is identified as the \"OATH HOTP Algorithm\" in all material\n * mentioning or referencing this software or this function.\n *\n * License is also granted to make and use derivative works provided\n * that such works are identified as\n *  \"derived from OATH HOTP algorithm\"\n * in all material mentioning or referencing the derived work.\n *\n * OATH (Open AuTHentication) and its members make no\n * representations concerning either the merchantability of this\n * software or the suitability of this software for any particular\n * purpose.\n *\n * It is provided \"as is\" without express or implied warranty\n * of any kind and OATH AND ITS MEMBERS EXPRESSaLY DISCLAIMS\n * ANY WARRANTY OR LIABILITY OF ANY KIND relating to this software.\n *\n * These notices must be retained in any copies of any part of this\n * documentation and/or software.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "package org.openauthentication.otp;",
      "ja": "package org.openauthentication.OTP;"
    },
    {
      "indent": 3,
      "text": "import java.io.IOException;\nimport java.io.File;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream ;\nimport java.lang.reflect.UndeclaredThrowableException;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "import java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "import javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/**\n * This class contains static methods that are used to calculate the\n * One-Time Password (OTP) using\n * JCE to provide the HMAC-SHA-1.\n *\n * @author Loren Hart\n * @version 1.0\n */\npublic class OneTimePasswordAlgorithm {\n    private OneTimePasswordAlgorithm() {}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "// These are used to calculate the check-sum digits.\n//                                0  1  2  3  4  5  6  7  8  9\nprivate static final int[] doubleDigits =\n                { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * Calculates the checksum using the credit card algorithm.\n * This algorithm has the advantage that it detects any single\n * mistyped digit and any single transposition of\n * adjacent digits.\n *\n * @param num the number to calculate the checksum for\n * @param digits number of significant places in the number\n *\n * @return the checksum of num\n */\npublic static int calcChecksum(long num, int digits) {\n    boolean doubleDigit = true;\n    int     total = 0;\n    while (0 < digits--) {\n        int digit = (int) (num % 10);\n        num /= 10;\n        if (doubleDigit) {\n            digit = doubleDigits[digit];\n        }\n        total += digit;\n        doubleDigit = !doubleDigit;\n    }\n    int result = total % 10;\n    if (result > 0) {\n        result = 10 - result;\n    }\n    return result;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * This method uses the JCE to provide the HMAC-SHA-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "* algorithm. * HMAC computes a Hashed Message Authentication Code and * in this case SHA1 is the hash algorithm used. * * @param keyBytes the bytes to use for the HMAC-SHA-1 key * @param text the message or text to be authenticated. * * @throws NoSuchAlgorithmException if no provider makes * either HmacSHA1 or HMAC-SHA-1 * digest algorithms available. * @throws InvalidKeyException * The secret provided was not a valid HMAC-SHA-1 key. * */",
      "ja": "* アルゴリズム。* HMACはハッシュメッセージ認証コードを計算し、この場合、SHA1は使用されるハッシュアルゴリズムです。* * @param keybytes hmac-sha-1キー* @param text認証されるメッセージまたはテキストを使用するバイト。* * @THROWS NOSUCHARGORITHMExceptionプロバイダーが使用可能なHMACSHA1またはHMAC-SHA-1 *ダイジェストアルゴリズムのいずれかを作る場合。* @THROWS InvalidKeyException *提供された秘密は有効なHMAC-SHA-1キーではありませんでした。* * /"
    },
    {
      "indent": 3,
      "text": "    public static byte[] hmac_sha1(byte[] keyBytes, byte[] text)\n        throws NoSuchAlgorithmException, InvalidKeyException\n    {\n//        try {\n            Mac hmacSha1;\n            try {\n                hmacSha1 = Mac.getInstance(\"HmacSHA1\");\n            } catch (NoSuchAlgorithmException nsae) {\n                hmacSha1 = Mac.getInstance(\"HMAC-SHA-1\");\n            }\n            SecretKeySpec macKey =\n        new SecretKeySpec(keyBytes, \"RAW\");\n            hmacSha1.init(macKey);\n            return hmacSha1.doFinal(text);\n//        } catch (GeneralSecurityException gse) {\n//            throw new UndeclaredThrowableException(gse);\n//        }\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  private static final int[] DIGITS_POWER\n// 0 1  2   3    4     5      6       7        8\n= {1,10,100,1000,10000,100000,1000000,10000000,100000000};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/**\n * This method generates an OTP value for the given\n * set of parameters.\n *\n * @param secret       the shared secret\n * @param movingFactor the counter, time, or other value that\n *                     changes on a per use basis.\n * @param codeDigits   the number of digits in the OTP, not\n *                     including the checksum, if any.\n * @param addChecksum  a flag that indicates if a checksum digit",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "   *                     should be appended to the OTP.\n   * @param truncationOffset the offset into the MAC result to\n   *                     begin truncation.  If this value is out of\n   *                     the range of 0 ... 15, then dynamic\n   *                     truncation  will be used.\n   *                     Dynamic truncation is when the last 4\n   *                     bits of the last byte of the MAC are\n   *                     used to determine the start offset.\n   * @throws NoSuchAlgorithmException if no provider makes\n   *                     either HmacSHA1 or HMAC-SHA-1\n   *                     digest algorithms available.\n   * @throws InvalidKeyException\n   *                     The secret provided was not\n   *                     a valid HMAC-SHA-1 key.\n   *\n   * @return A numeric String in base 10 that includes\n   * {@link codeDigits} digits plus the optional checksum\n   * digit if requested.\n   */\n  static public String generateOTP(byte[] secret,\n             long movingFactor,\n        int codeDigits,\n             boolean addChecksum,\n        int truncationOffset)\n      throws NoSuchAlgorithmException, InvalidKeyException\n  {\n      // put movingFactor value into text byte array\nString result = null;\nint digits = addChecksum ? (codeDigits + 1) : codeDigits;\n      byte[] text = new byte[8];\n      for (int i = text.length - 1; i >= 0; i--) {\n          text[i] = (byte) (movingFactor & 0xff);\n          movingFactor >>= 8;\n      }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "// compute hmac hash\nbyte[] hash = hmac_sha1(secret, text);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      // put selected bytes into result int\n      int offset = hash[hash.length - 1] & 0xf;\nif ( (0<=truncationOffset) &&\n       (truncationOffset<(hash.length-4)) ) {\n    offset = truncationOffset;\n}\n      int binary =\n          ((hash[offset] & 0x7f) << 24)\n          | ((hash[offset + 1] & 0xff) << 16)\n          | ((hash[offset + 2] & 0xff) << 8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "| (hash[offset + 3] & 0xff);",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        int otp = binary % DIGITS_POWER[codeDigits];\n  if (addChecksum) {\n      otp =  (otp * 10) + calcChecksum(otp, codeDigits);\n  }\n  result = Integer.toString(otp);\n  while (result.length() < digits) {\n      result = \"0\" + result;\n  }\n  return result;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix D - HOTP Algorithm: Test Values",
      "ja": "付録D  -  HOTPアルゴリズムテスト値"
    },
    {
      "indent": 3,
      "text": "The following test data uses the ASCII string \"12345678901234567890\" for the secret:",
      "ja": "次のテストデータは、SecretについてASCII文字列 \"12345678901234567890\"を使用します。"
    },
    {
      "indent": 3,
      "text": "Secret = 0x3132333435363738393031323334353637383930",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 1 details for each count, the intermediate HMAC value.",
      "ja": "表1各カウント、中間HMAC値の詳細。"
    },
    {
      "indent": 3,
      "text": "Count    Hexadecimal HMAC-SHA-1(secret, count)\n0        cc93cf18508d94934c64b65d8ba7667fb7cde4b0\n1        75a48a19d4cbe100644e8ac1397eea747a2d33ab\n2        0bacb7fa082fef30782211938bc1c5e70416ff44\n3        66c28227d03a2d5529262ff016a1e6ef76557ece\n4        a904c900a64b35909874b33e61c5938a8e15ed1c\n5        a37e783d7b7233c083d4f62926c7a25f238d0316\n6        bc9cd28561042c83f219324d3c607256c03272ae\n7        a4fb960c0bc06e1eabb804e5b397cdc4b45596fa\n8        1b3c89f65e6c9e883012052823443f048b4332db\n9        1637409809a679dc698207310c8c7fc07290d9e5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 2 details for each count the truncated values (both in hexadecimal and decimal) and then the HOTP value.",
      "ja": "表2切り捨てられた値（16進数と10進数の両方）、次にHOTP値の詳細について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": " Truncated Count Hexadecimal Decimal HOTP 0 4c93cf18 1284755224 755224 1 41397eea 1094287082 287082 2 82fef30 137359152 359152 3 66ef7655 1726969429 969429 4 61c5938a 1640338314 338314 5 33c083d4 868254676 254676 6 7256c032 1918287922 287922 7 4e5b397 82162583 162583 8 2823443f 673399871 399871 9 2679dc69 645520489 520489",
      "ja": "04c93cf181284755224755224141397eea1094287082287082282fef30137359152359152366ef76551726969429969429461c5938a1640338314338314533c083d486825467625467667256c032191828792228792274e5b3978216258316258382823443f67339987139987192679dc69645520489520489進小数点HOTPカウント切り捨て"
    },
    {
      "indent": 0,
      "text": "Appendix E - Extensions",
      "ja": "付録E  - 拡張子"
    },
    {
      "indent": 3,
      "text": "We introduce in this section several enhancements to the HOTP algorithm. These are not recommended extensions or part of the standard algorithm, but merely variations that could be used for customized implementations.",
      "ja": "このセクションでは、HOTPアルゴリズムのいくつかの機能強化を紹介します。これらは推奨されていません。標準アルゴリズムの推奨されていませんが、単にカスタマイズされた実装に使用できるバリエーションです。"
    },
    {
      "indent": 0,
      "text": "E.1. Number of Digits",
      "section_title": true,
      "ja": "E.1. 数字数"
    },
    {
      "indent": 3,
      "text": "A simple enhancement in terms of security would be to extract more digits from the HMAC-SHA-1 value.",
      "ja": "セキュリティに関する単純な強化は、HMAC-SHA-1値からさらに数字を抽出することです。"
    },
    {
      "indent": 3,
      "text": "For instance, calculating the HOTP value modulo 10^8 to build an 8- digit HOTP value would reduce the probability of success of the adversary from sv/10^6 to sv/10^8.",
      "ja": "たとえば、8桁のHOTP値を構築するためにHOTP値Modulo 10 ^ 8を計算すると、SV / 10 ^ 6からSV / 10 ^ 8までの敵対者の成功の可能性が低下します。"
    },
    {
      "indent": 3,
      "text": "This could give the opportunity to improve usability, e.g., by increasing T and/or s, while still achieving a better security overall. For instance, s = 10 and 10v/10^8 = v/10^7 < v/10^6 which is the theoretical optimum for 6-digit code when s = 1.",
      "ja": "これは、依然としてより良いセキュリティを達成しながら、Tおよび/またはSを増やすことによってユーザビリティを向上させる機会を与える可能性がある。例えば、S = 1のときに6桁のコードに対して理論的に最適なS = 10および10V / 10 ^ 8 = v / 10 ^ 7 <v / 10 ^ 6。"
    },
    {
      "indent": 0,
      "text": "E.2. Alphanumeric Values",
      "section_title": true,
      "ja": "E.2. 英数字の値"
    },
    {
      "indent": 3,
      "text": "Another option is to use A-Z and 0-9 values; or rather a subset of 32 symbols taken from the alphanumerical alphabet in order to avoid any confusion between characters: 0, O, and Q as well as l, 1, and I are very similar, and can look the same on a small display.",
      "ja": "もう1つの選択肢は、A-Zと0-9の値を使用することです。またはむしろ文字数：0、O、QだけでなくL、1、およびIは非常に似ており、小さなディスプレイで同じように見えることがあります。"
    },
    {
      "indent": 3,
      "text": "The immediate consequence is that the security is now in the order of sv/32^6 for a 6-digit HOTP value and sv/32^8 for an 8-digit HOTP value.",
      "ja": "当面の結果は、セキュリティが6桁のHOTP値に対してSV / 32 ^ 6の順序で、8桁のHOTP値でSV / 32 ^ 8の順序であることです。"
    },
    {
      "indent": 3,
      "text": "32^6 > 10^9 so the security of a 6-alphanumeric HOTP code is slightly better than a 9-digit HOTP value, which is the maximum length of an HOTP code supported by the proposed algorithm.",
      "ja": "32 ^ 6> 10 ^ 9なので、6-英数字のHOTPコードのセキュリティは9桁のHOTP値よりわずかに優れており、これは提案されたアルゴリズムでサポートされているHOTPコードの最大長です。"
    },
    {
      "indent": 3,
      "text": "32^8 > 10^12 so the security of an 8-alphanumeric HOTP code is significantly better than a 9-digit HOTP value.",
      "ja": "32 ^ 8> 10 ^ 12では、8文字のHOTPコードのセキュリティは9桁のHOTP値よりもかなり優れています。"
    },
    {
      "indent": 3,
      "text": "Depending on the application and token/interface used for displaying and entering the HOTP value, the choice of alphanumeric values could be a simple and efficient way to improve security at a reduced cost and impact on users.",
      "ja": "HOTP値の表示と入力に使用されるアプリケーションとトークン/インターフェイスに応じて、英数字の値の選択は、コストの削減とユーザーへの影響でセキュリティを向上させるための簡単で効率的な方法です。"
    },
    {
      "indent": 0,
      "text": "E.3. Sequence of HOTP Values",
      "section_title": true,
      "ja": "E.3. HOTP値のシーケンス"
    },
    {
      "indent": 3,
      "text": "As we suggested for the resynchronization to enter a short sequence (say, 2 or 3) of HOTP values, we could generalize the concept to the protocol, and add a parameter L that would define the length of the HOTP sequence to enter.",
      "ja": "再同期を推奨して、HOTP値の短いシーケンス（つまり、2または3）を入力すると、概念をプロトコルに一般化し、入力するHOTPシーケンスの長さを定義するパラメータLを追加することができます。"
    },
    {
      "indent": 3,
      "text": "Per default, the value L SHOULD be set to 1, but if security needs to be increased, users might be asked (possibly for a short period of time, or a specific operation) to enter L HOTP values.",
      "ja": "デフォルトでは、値Lは1に設定する必要がありますが、セキュリティを増やす必要がある場合は、ユーザーがL HOTP値を入力するようにユーザーが求められます（おそらく特定の操作）。"
    },
    {
      "indent": 3,
      "text": "This is another way, without increasing the HOTP length or using alphanumeric values to tighten security.",
      "ja": "これは、HOTPの長さを増やすこと、または英数字の値を使用してセキュリティを締め付けることなく別の方法です。"
    },
    {
      "indent": 3,
      "text": "Note: The system MAY also be programmed to request synchronization on a regular basis (e.g., every night, twice a week, etc.) and to achieve this purpose, ask for a sequence of L HOTP values.",
      "ja": "注：システムは、定期的に同期を要求するようにプログラムされてもよく、この目的を達成するために、一連のL HOTP値を問い合わせることもできます。"
    },
    {
      "indent": 0,
      "text": "E.4. A Counter-Based Resynchronization Method",
      "section_title": true,
      "ja": "E.4. カウンタベースの再同期方式"
    },
    {
      "indent": 3,
      "text": "In this case, we assume that the client can access and send not only the HOTP value but also other information, more specifically, the counter value.",
      "ja": "この場合、クライアントはHOTP値だけでなく他の情報、より具体的にはカウンタ値にアクセスして送信できるとします。"
    },
    {
      "indent": 3,
      "text": "A more efficient and secure method for resynchronization is possible in this case. The client application will not send the HOTP-client value only, but the HOTP-client and the related C-client counter value, the HOTP value acting as a message authentication code of the counter.",
      "ja": "この場合、再同期化のためのより効率的で安全な方法が可能です。クライアントアプリケーションは、HOTPクライアント値のみを送信しませんが、HOTP-Clientと関連するCクライアントカウンタ値、HOTP値はカウンタのメッセージ認証コードとして機能します。"
    },
    {
      "indent": 3,
      "text": "Resynchronization Counter-based Protocol (RCP)\n----------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The server accepts if the following are all true, where C-server is its own current counter value:",
      "ja": "サーバーは、以下の場合、C-Serverはそれ自身の現在のカウンタ値である場合に該当する場合に受け入れます。"
    },
    {
      "indent": 3,
      "text": "1) C-client >= C-server\n2) C-client - C-server <= s\n3) Check that HOTP client is valid HOTP(K,C-Client)\n4) If true, the server sets C to C-client + 1 and client is\n   authenticated",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this case, there is no need for managing a look-ahead window anymore. The probability of success of the adversary is only v/10^6 or roughly v in one million. A side benefit is obviously to be able to increase s \"infinitely\" and therefore improve the system usability without impacting the security.",
      "ja": "この場合、先読みウィンドウを管理する必要はもうありません。敵対者の成功の可能性は、100万百万円でのV / 10 ^ 6またはおおよそVにすぎません。サイドの利点は明らかにS「無限に」を増やすことができ、したがって、セキュリティに影響を与えることなくシステムの使いやすさを向上させることです。"
    },
    {
      "indent": 3,
      "text": "This resynchronization protocol SHOULD be used whenever the related impact on the client and server applications is deemed acceptable.",
      "ja": "この再同期プロトコルは、クライアントおよびサーバーアプリケーションへの関連する影響が許容できると見なされるたびに使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "E.5. Data Field",
      "section_title": true,
      "ja": "E.5. データフィールド"
    },
    {
      "indent": 3,
      "text": "Another interesting option is the introduction of a Data field, which would be used for generating the One-Time Password values: HOTP (K, C, [Data]) where Data is an optional field that can be the concatenation of various pieces of identity-related information, e.g., Data = Address | PIN.",
      "ja": "もう1つの興味深いオプションは、データフィールドの紹介であり、ワンタイムパスワード値を生成するために使用されるであろう。 - 関連情報、例えばdata = address."
    },
    {
      "indent": 3,
      "text": "We could also use a Timer, either as the only moving factor or in combination with the Counter -- in this case, e.g., Data = Timer, where Timer could be the UNIX-time (GMT seconds since 1/1/1970) divided by some factor (8, 16, 32, etc.) in order to give a specific time step. The time window for the One-Time Password is then equal to the time step multiplied by the resynchronization parameter as defined before. For example, if we take 64 seconds as the time step and 7 for the resynchronization parameter, we obtain an acceptance window of +/- 3 minutes.",
      "ja": "この場合、この場合、Data = Timer、例えばData = Timer（1/1/1970からGMT秒から1/1/1970以降のGMT秒）になる可能性がある場合は、タイマーを使用することもできます。特定の時間段階を与えるために、ある要因（8,16,32など）によって。1回限りのパスワードのタイムウィンドウは、以前に定義されているように、再同期パラメータを乗算したときの時間ステップと同じです。たとえば、再同期パラメータの時間ステップと7として64秒かかると、/  -  3分の受付ウィンドウが得られます。"
    },
    {
      "indent": 3,
      "text": "Using a Data field opens for more flexibility in the algorithm implementation, provided that the Data field is clearly specified.",
      "ja": "データフィールドが明確に指定されている場合、データフィールドを使用すると、アルゴリズムの実装ではより柔軟性が向上します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "David M'Raihi (primary contact for sending comments and questions) VeriSign, Inc. 685 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "David M'Raihi（コメントや質問の送信のための主な連絡先）Verisign、Inc。685 E.ミドルフィールドロードマウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "Phone: 1-650-426-3832 EMail: dmraihi@verisign.com",
      "ja": "電話：1-650-426-3832 Eメール：Dmraihi@verisign.com"
    },
    {
      "indent": 3,
      "text": "Mihir Bellare Dept of Computer Science and Engineering, Mail Code 0114 University of California at San Diego 9500 Gilman Drive La Jolla, CA 92093, USA",
      "ja": "Mihir Bellare Dept of Computer Science and Engineeration、メールコード0114カリフォルニア大学San Diego 9500 Gilman Drive La Jolla、CA 92093、アメリカ"
    },
    {
      "indent": 3,
      "text": "EMail: mihir@cs.ucsd.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Frank Hoornaert VASCO Data Security, Inc. Koningin Astridlaan 164 1780 Wemmel, Belgium",
      "ja": "Frank Hoornaert Vasco Data Security、Inc。Koningin Astridlaan 164 1780 Wemmel、ベルギー"
    },
    {
      "indent": 3,
      "text": "EMail: frh@vasco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Naccache Gemplus Innovation 34 rue Guynemer, 92447, Issy les Moulineaux, France and Information Security Group, Royal Holloway, University of London, Egham, Surrey TW20 0EX, UK",
      "ja": "David Naccache Gemplus Innovation 34 Rue Guynemer、92447、Issy Les Moulineaux、フランス、情報セキュリティグループ、ロンドン大学、Egham、Surrey Tw20 0ex、UK"
    },
    {
      "indent": 3,
      "text": "EMail: david.naccache@gemplus.com, david.naccache@rhul.ac.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ohad Ranen Aladdin Knowledge Systems Ltd. 15 Beit Oved Street Tel Aviv, Israel 61110",
      "ja": "Ohad Ranen Aladdin Knowledge Systems Ltd. 15 Beit Oves Streetテルアビブ、イスラエル61110"
    },
    {
      "indent": 3,
      "text": "EMail: Ohad.Ranen@ealaddin.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全著作権宣言"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット社会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれている権利、ライセンス、制限の対象となり、その中に述べた場合を除き、著者らはすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本明細書に含まれる情報は、「現状のまま」基準で提供されており、投稿者、または（いずれかの場合）、インターネット社会とインターネットエンジニアリングのタスクフォースがすべての保証を損なう、または本明細書における情報の使用が、特定の目的のためのあらゆる権利または黙示の保証を侵害しないことを含むがこれらに限定されないが、これに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "この文書に記載されているテクノロジの実装または使用に関連すると主張される可能性がある、またはそのような権利の下でのライセンスの使用に関連すると主張される可能性がある、またはその他の権利の下にある範囲内である可能性がある、またはその他の権利の使用に関連すると主張する可能性がある、IETFは、IETFを取りません。利用可能です。そのような権利を特定するためにそれが独立した努力をしたことを表していません。RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局へのIETF事務局と利用可能なライセンスの保証のコピー、またはこの仕様書の実装者や利用者による一般的なライセンスまたは許可を得るための試みの結果を得ることができます。IETFオンラインIPRリポジトリからhttp://www.ietf.org/ipr。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、著作権、特許または特許出願、またはこの規格を実装することが要求される可能性がある技術をカバーする可能性のある他の独自の権利を注意を及ぼすように興味のある当事者を勧めます。ietf-ipr@ietf.orgのIETFに情報を宛先に宛ててください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディタ機能のための資金は、現在インターネット社会によって提供されています。"
    }
  ]
}