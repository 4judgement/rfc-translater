{
  "title": {
    "text": "RFC 4871 - DomainKeys Identified Mail (DKIM) Signatures",
    "ja": "RFC 4871 - DomainKeys Identified Mail（DKIM）署名"
  },
  "number": 4871,
  "created_at": "2020-08-16 19:19:01.591162+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          E. Allman\nRequest for Comments: 4871                                Sendmail, Inc.\nObsoletes: 4870                                                J. Callas\nCategory: Standards Track                                PGP Corporation\n                                                               M. Delany\n                                                               M. Libbey\n                                                              Yahoo! Inc\n                                                               J. Fenton\n                                                               M. Thomas\n                                                     Cisco Systems, Inc.\n                                                                May 2007",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "DomainKeys Identified Mail (DKIM) Signatures",
      "ja": "DomainKeys Identified Mail（DKIM）署名"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "Copyright（C）IETF Trust（2007）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "DomainKeys Identified Mail (DKIM) defines a domain-level authentication framework for email using public-key cryptography and key server technology to permit verification of the source and contents of messages by either Mail Transfer Agents (MTAs) or Mail User Agents (MUAs). The ultimate goal of this framework is to permit a signing domain to assert responsibility for a message, thus protecting message signer identity and the integrity of the messages they convey while retaining the functionality of Internet email as it is known today. Protection of email identity may assist in the global control of \"spam\" and \"phishing\".",
      "ja": "DomainKeys Identified Mail（DKIM）は、メール転送エージェント（MTA）またはメールユーザーエージェント（MUA）のいずれかによるメッセージのソースとコンテンツの検証を可能にする公開鍵暗号とキーサーバーテクノロジーを使用した電子メールのドメインレベルの認証フレームワークを定義します。このフレームワークの最終的な目標は、署名ドメインがメッセージに対する責任を主張できるようにすることです。これにより、今日知られているインターネット電子メールの機能を維持しながら、メッセージ署名者のIDとメッセージの整合性を保護します。電子メールIDの保護は、「スパム」および「フィッシング」のグローバルな制御に役立ちます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.1.  Signing Identity . . . . . . . . . . . . . . . . . . . . .  5\n  1.2.  Scalability  . . . . . . . . . . . . . . . . . . . . . . .  5\n  1.3.  Simple Key Management  . . . . . . . . . . . . . . . . . .  5\n2.  Terminology and Definitions  . . . . . . . . . . . . . . . . .  5\n  2.1.  Signers  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n  2.2.  Verifiers  . . . . . . . . . . . . . . . . . . . . . . . .  6\n  2.3.  Whitespace . . . . . . . . . . . . . . . . . . . . . . . .  6\n  2.4.  Common ABNF Tokens . . . . . . . . . . . . . . . . . . . .  6\n  2.5.  Imported ABNF Tokens . . . . . . . . . . . . . . . . . . .  7\n  2.6.  DKIM-Quoted-Printable  . . . . . . . . . . . . . . . . . .  7\n3.  Protocol Elements  . . . . . . . . . . . . . . . . . . . . . .  8\n  3.1.  Selectors  . . . . . . . . . . . . . . . . . . . . . . . .  8\n  3.2.  Tag=Value Lists  . . . . . . . . . . . . . . . . . . . . . 10\n  3.3.  Signing and Verification Algorithms  . . . . . . . . . . . 11\n  3.4.  Canonicalization . . . . . . . . . . . . . . . . . . . . . 13\n  3.5.  The DKIM-Signature Header Field  . . . . . . . . . . . . . 17\n  3.6.  Key Management and Representation  . . . . . . . . . . . . 25\n  3.7.  Computing the Message Hashes . . . . . . . . . . . . . . . 29\n  3.8.  Signing by Parent Domains  . . . . . . . . . . . . . . . . 31\n4.  Semantics of Multiple Signatures . . . . . . . . . . . . . . . 32\n  4.1.  Example Scenarios  . . . . . . . . . . . . . . . . . . . . 32\n  4.2.  Interpretation . . . . . . . . . . . . . . . . . . . . . . 33\n5.  Signer Actions . . . . . . . . . . . . . . . . . . . . . . . . 34\n  5.1.  Determine Whether the Email Should Be Signed and by\n        Whom . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n  5.2.  Select a Private Key and Corresponding Selector\n        Information  . . . . . . . . . . . . . . . . . . . . . . . 35\n  5.3.  Normalize the Message to Prevent Transport Conversions . . 35\n  5.4.  Determine the Header Fields to Sign  . . . . . . . . . . . 36\n  5.5.  Recommended Signature Content  . . . . . . . . . . . . . . 38\n  5.6.  Compute the Message Hash and Signature . . . . . . . . . . 39\n  5.7.  Insert the DKIM-Signature Header Field . . . . . . . . . . 40\n6.  Verifier Actions . . . . . . . . . . . . . . . . . . . . . . . 40\n  6.1.  Extract Signatures from the Message  . . . . . . . . . . . 41\n  6.2.  Communicate Verification Results . . . . . . . . . . . . . 46\n  6.3.  Interpret Results/Apply Local Policy . . . . . . . . . . . 47\n7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 48\n  7.1.  DKIM-Signature Tag Specifications  . . . . . . . . . . . . 48\n  7.2.  DKIM-Signature Query Method Registry . . . . . . . . . . . 49\n  7.3.  DKIM-Signature Canonicalization Registry . . . . . . . . . 49\n  7.4.  _domainkey DNS TXT Record Tag Specifications . . . . . . . 50\n  7.5.  DKIM Key Type Registry . . . . . . . . . . . . . . . . . . 50\n  7.6.  DKIM Hash Algorithms Registry  . . . . . . . . . . . . . . 51\n  7.7.  DKIM Service Types Registry  . . . . . . . . . . . . . . . 51\n  7.8.  DKIM Selector Flags Registry . . . . . . . . . . . . . . . 52",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  7.9.  DKIM-Signature Header Field  . . . . . . . . . . . . . . . 52\n8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 52\n  8.1.  Misuse of Body Length Limits (\"l=\" Tag)  . . . . . . . . . 52\n  8.2.  Misappropriated Private Key  . . . . . . . . . . . . . . . 53\n  8.3.  Key Server Denial-of-Service Attacks . . . . . . . . . . . 54\n  8.4.  Attacks Against the DNS  . . . . . . . . . . . . . . . . . 54\n  8.5.  Replay Attacks . . . . . . . . . . . . . . . . . . . . . . 55\n  8.6.  Limits on Revoking Keys  . . . . . . . . . . . . . . . . . 55\n  8.7.  Intentionally Malformed Key Records  . . . . . . . . . . . 56\n  8.8.  Intentionally Malformed DKIM-Signature Header Fields . . . 56\n  8.9.  Information Leakage  . . . . . . . . . . . . . . . . . . . 56\n  8.10. Remote Timing Attacks  . . . . . . . . . . . . . . . . . . 56\n  8.11. Reordered Header Fields  . . . . . . . . . . . . . . . . . 56\n  8.12. RSA Attacks  . . . . . . . . . . . . . . . . . . . . . . . 56\n  8.13. Inappropriate Signing by Parent Domains  . . . . . . . . . 57\n9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 57\n  9.1.  Normative References . . . . . . . . . . . . . . . . . . . 57\n  9.2.  Informative References . . . . . . . . . . . . . . . . . . 58\nAppendix A.  Example of Use (INFORMATIVE)  . . . . . . . . . . . . 60\n  A.1.  The user composes an email . . . . . . . . . . . . . . . . 60\n  A.2.  The email is signed  . . . . . . . . . . . . . . . . . . . 61\n  A.3.  The email signature is verified  . . . . . . . . . . . . . 61\nAppendix B.  Usage Examples (INFORMATIVE)  . . . . . . . . . . . . 62\n  B.1.  Alternate Submission Scenarios . . . . . . . . . . . . . . 63\n  B.2.  Alternate Delivery Scenarios . . . . . . . . . . . . . . . 65\nAppendix C.  Creating a Public Key (INFORMATIVE) . . . . . . . . . 67\nAppendix D.  MUA Considerations  . . . . . . . . . . . . . . . . . 68\nAppendix E.  Acknowledgements  . . . . . . . . . . . . . . . . . . 69",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DomainKeys Identified Mail (DKIM) defines a mechanism by which email messages can be cryptographically signed, permitting a signing domain to claim responsibility for the introduction of a message into the mail stream. Message recipients can verify the signature by querying the signer's domain directly to retrieve the appropriate public key, and thereby confirm that the message was attested to by a party in possession of the private key for the signing domain.",
      "ja": "DomainKeys Identified Mail（DKIM）は、電子メールメッセージに暗号で署名できるメカニズムを定義し、署名ドメインがメッセージをメールストリームに導入する責任を主張できるようにします。メッセージの受信者は、署名者のドメインに直接問い合わせて適切な公開鍵を取得することで署名を検証し、署名ドメインの秘密鍵を所持する当事者によってメッセージが証明されたことを確認できます。"
    },
    {
      "indent": 3,
      "text": "The approach taken by DKIM differs from previous approaches to message signing (e.g., Secure/Multipurpose Internet Mail Extensions (S/MIME) [RFC1847], OpenPGP [RFC2440]) in that:",
      "ja": "DKIMが採用するアプローチは、メッセージ署名への以前のアプローチとは異なります（たとえば、Secure / Multipurpose Internet Mail Extensions（S / MIME）[RFC1847]、OpenPGP [RFC2440]）。"
    },
    {
      "indent": 3,
      "text": "o the message signature is written as a message header field so that neither human recipients nor existing MUA (Mail User Agent) software is confused by signature-related content appearing in the message body;",
      "ja": "o メッセージの署名はメッセージヘッダーフィールドとして書き込まれるため、人間の受信者も既存のMUA（メールユーザーエージェント）ソフトウェアも、メッセージ本文に表示される署名関連のコンテンツによって混乱することはありません。"
    },
    {
      "indent": 3,
      "text": "o there is no dependency on public and private key pairs being issued by well-known, trusted certificate authorities;",
      "ja": "o 有名で信頼できる認証局が発行する公開鍵と秘密鍵のペアに依存しません。"
    },
    {
      "indent": 3,
      "text": "o there is no dependency on the deployment of any new Internet protocols or services for public key distribution or revocation;",
      "ja": "o 公開鍵の配布または取り消しのための新しいインターネットプロトコルまたはサービスの展開に依存しない。"
    },
    {
      "indent": 3,
      "text": "o signature verification failure does not force rejection of the message;",
      "ja": "o 署名検証の失敗は、メッセージの拒否を強制しません。"
    },
    {
      "indent": 3,
      "text": "o no attempt is made to include encryption as part of the mechanism;",
      "ja": "o メカニズムの一部として暗号化を含める試みは行われません。"
    },
    {
      "indent": 3,
      "text": "o message archiving is not a design goal.",
      "ja": "o メッセージのアーカイブは設計目標ではありません。"
    },
    {
      "indent": 3,
      "text": "DKIM:",
      "ja": "DKIM："
    },
    {
      "indent": 3,
      "text": "o is compatible with the existing email infrastructure and transparent to the fullest extent possible;",
      "ja": "o 既存の電子メールインフラストラクチャと互換性があり、可能な限り透過的です。"
    },
    {
      "indent": 3,
      "text": "o requires minimal new infrastructure;",
      "ja": "o 最小限の新しいインフラストラクチャが必要です。"
    },
    {
      "indent": 3,
      "text": "o can be implemented independently of clients in order to reduce deployment time;",
      "ja": "o 展開時間を短縮するために、クライアントとは無関係に実装できます。"
    },
    {
      "indent": 3,
      "text": "o can be deployed incrementally;",
      "ja": "o 段階的に展開できます。"
    },
    {
      "indent": 3,
      "text": "o allows delegation of signing to third parties.",
      "ja": "o 署名の委任を第三者に許可します。"
    },
    {
      "indent": 0,
      "text": "1.1. Signing Identity",
      "section_title": true,
      "ja": "1.1. アイデンティティの署名"
    },
    {
      "indent": 3,
      "text": "DKIM separates the question of the identity of the signer of the message from the purported author of the message. In particular, a signature includes the identity of the signer. Verifiers can use the signing information to decide how they want to process the message. The signing identity is included as part of the signature header field.",
      "ja": "DKIMは、メッセージの署名者の身元の質問と、メッセージの作成者との区別を行います。特に、署名には署名者の身元が含まれます。検証者は、署名情報を使用して、メッセージの処理方法を決定できます。署名IDは、署名ヘッダーフィールドの一部として含まれています。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: The signing identity specified by a DKIM signature is not required to match an address in any particular header field because of the broad methods of interpretation by recipient mail systems, including MUAs.",
      "ja": "有益な理論的根拠：DKIM署名で指定された署名IDは、MUAを含む受信者のメールシステムによる幅広い解釈方法のため、特定のヘッダーフィールドのアドレスと一致する必要はありません。"
    },
    {
      "indent": 0,
      "text": "1.2. Scalability",
      "section_title": true,
      "ja": "1.2. スケーラビリティ"
    },
    {
      "indent": 3,
      "text": "DKIM is designed to support the extreme scalability requirements that characterize the email identification problem. There are currently over 70 million domains and a much larger number of individual addresses. DKIM seeks to preserve the positive aspects of the current email infrastructure, such as the ability for anyone to communicate with anyone else without introduction.",
      "ja": "DKIMは、電子メールの識別問題を特徴付ける極端なスケーラビリティ要件をサポートするように設計されています。現在、7000万を超えるドメインとはるかに多数の個別アドレスがあります。 DKIMは、誰かが紹介なしで他の人と通信する能力など、現在の電子メールインフラストラクチャの良い面を維持しようとしています。"
    },
    {
      "indent": 0,
      "text": "1.3. Simple Key Management",
      "section_title": true,
      "ja": "1.3. シンプルなキー管理"
    },
    {
      "indent": 3,
      "text": "DKIM differs from traditional hierarchical public-key systems in that no Certificate Authority infrastructure is required; the verifier requests the public key from a repository in the domain of the claimed signer directly rather than from a third party.",
      "ja": "DKIMは、認証局インフラストラクチャが必要ないという点で、従来の階層型公開鍵システムとは異なります。検証者は、第三者からではなく、要求された署名者のドメイン内のリポジトリから直接公開鍵を要求します。"
    },
    {
      "indent": 3,
      "text": "The DNS is proposed as the initial mechanism for the public keys. Thus, DKIM currently depends on DNS administration and the security of the DNS system. DKIM is designed to be extensible to other key fetching services as they become available.",
      "ja": "DNSは、公開鍵の初期メカニズムとして提案されています。したがって、DKIMは現在、DNS管理とDNSシステムのセキュリティに依存しています。 DKIMは、他のキー取得サービスが利用可能になったときに拡張できるように設計されています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Definitions",
      "section_title": true,
      "ja": "2. 用語と定義"
    },
    {
      "indent": 3,
      "text": "This section defines terms used in the rest of the document. Syntax descriptions use the form described in Augmented BNF for Syntax Specifications [RFC4234].",
      "ja": "このセクションでは、ドキュメントの残りの部分で使用される用語を定義します。構文の説明では、構文仕様の拡張BNF [RFC4234]で説明されている形式を使用します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Signers",
      "section_title": true,
      "ja": "2.1. 署名者"
    },
    {
      "indent": 3,
      "text": "Elements in the mail system that sign messages on behalf of a domain are referred to as signers. These may be MUAs (Mail User Agents), MSAs (Mail Submission Agents), MTAs (Mail Transfer Agents), or other agents such as mailing list exploders. In general, any signer will be involved in the injection of a message into the message system in some way. The key issue is that a message must be signed before it leaves the administrative domain of the signer.",
      "ja": "ドメインに代わってメッセージに署名するメールシステムの要素は、署名者と呼ばれます。これらは、MUA（メールユーザーエージェント）、MSA（メール送信エージェント）、MTA（メール転送エージェント）、またはメーリングリストの展開などの他のエージェントです。一般に、署名者は何らかの方法でメッセージシステムへのメッセージの挿入に関与します。重要な問題は、メッセージが署名者の管理ドメインを離れる前に署名する必要があることです。"
    },
    {
      "indent": 0,
      "text": "2.2. Verifiers",
      "section_title": true,
      "ja": "2.2. 検証者"
    },
    {
      "indent": 3,
      "text": "Elements in the mail system that verify signatures are referred to as verifiers. These may be MTAs, Mail Delivery Agents (MDAs), or MUAs. In most cases it is expected that verifiers will be close to an end user (reader) of the message or some consuming agent such as a mailing list exploder.",
      "ja": "署名を検証するメールシステムの要素は、検証者と呼ばれます。これらはMTA、メール配信エージェント（MDA）、またはMUAです。ほとんどの場合、検証者はメッセージのエンドユーザー（リーダー）またはメーリングリストの爆発物などの消費エージェントの近くにいると予想されます。"
    },
    {
      "indent": 0,
      "text": "2.3. Whitespace",
      "section_title": true,
      "ja": "2.3. 空白"
    },
    {
      "indent": 3,
      "text": "There are three forms of whitespace:",
      "ja": "空白には3つの形式があります。"
    },
    {
      "indent": 3,
      "text": "o WSP represents simple whitespace, i.e., a space or a tab character (formal definition in [RFC4234]).",
      "ja": "o WSPは、単純な空白、つまりスペースまたはタブ文字を表します（[RFC4234]の正式な定義）。"
    },
    {
      "indent": 3,
      "text": "o LWSP is linear whitespace, defined as WSP plus CRLF (formal definition in [RFC4234]).",
      "ja": "o LWSPは、WSPとCRLF（[RFC4234]での正式な定義）として定義される線形空白です。"
    },
    {
      "indent": 3,
      "text": "o FWS is folding whitespace. It allows multiple lines separated by CRLF followed by at least one whitespace, to be joined.",
      "ja": "o FWSは空白を折りたたみます。 CRLFとそれに続く少なくとも1つの空白で区切られた複数の行を結合できます。"
    },
    {
      "indent": 3,
      "text": "The formal ABNF for these are (WSP and LWSP are given for information only):",
      "ja": "これらの正式なABNFは次のとおりです（WSPおよびLWSPは情報提供のみを目的としています）："
    },
    {
      "indent": 7,
      "text": "WSP =   SP / HTAB\nLWSP =  *(WSP / CRLF WSP)\nFWS =   [*WSP CRLF] 1*WSP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The definition of FWS is identical to that in [RFC2822] except for the exclusion of obs-FWS.",
      "ja": "FWSの定義は、obs-FWSを除いて[RFC2822]の定義と同じです。"
    },
    {
      "indent": 0,
      "text": "2.4. Common ABNF Tokens",
      "section_title": true,
      "ja": "2.4. 一般的なABNFトークン"
    },
    {
      "indent": 3,
      "text": "The following ABNF tokens are used elsewhere in this document:\n  hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / \"-\") (ALPHA / DIGIT) ]\n  base64string =     1*(ALPHA / DIGIT / \"+\" / \"/\" / [FWS])\n                     [ \"=\" [FWS] [ \"=\" [FWS] ] ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.5. Imported ABNF Tokens",
      "section_title": true,
      "ja": "2.5. インポートされたABNFトークン"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from other RFCs as noted. Those RFCs should be considered definitive.",
      "ja": "以下のトークンは、注記されているように他のRFCからインポートされます。これらのRFCは決定的なものと見なされます。"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC2821]:",
      "ja": "次のトークンは[RFC2821]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "o \"Local-part\" (implementation warning: this permits quoted strings)",
      "ja": "o 「ローカル部分」（実装警告：これは引用文字列を許可します）"
    },
    {
      "indent": 3,
      "text": "o \"sub-domain\"",
      "ja": "o 「サブドメイン」"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC2822]:",
      "ja": "次のトークンは[RFC2822]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "o \"field-name\" (name of a header field)",
      "ja": "o 「field-name」（ヘッダーフィールドの名前）"
    },
    {
      "indent": 3,
      "text": "o \"dot-atom-text\" (in the Local-part of an email address)",
      "ja": "o \"dot-atom-text\"（メールアドレスのローカル部分）"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC2045]:",
      "ja": "次のトークンは[RFC2045]からインポートされます。"
    },
    {
      "indent": 3,
      "text": "o \"qp-section\" (a single line of quoted-printable-encoded text)",
      "ja": "o \"qp-section\"（quoted-printable-encodedテキストの1行）"
    },
    {
      "indent": 3,
      "text": "o \"hex-octet\" (a quoted-printable encoded octet)",
      "ja": "o \"hex-octet\"（quoted-printableエンコードされたオクテット）"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Be aware that the ABNF in RFC 2045 does not obey the rules of RFC 4234 and must be interpreted accordingly, particularly as regards case folding.",
      "ja": "有益な注意：RFC 2045のABNFはRFC 4234の規則に従っていないため、特に大文字と小文字の区別に関して、それに応じて解釈する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Other tokens not defined herein are imported from [RFC4234]. These are intuitive primitives such as SP, HTAB, WSP, ALPHA, DIGIT, CRLF, etc.",
      "ja": "ここで定義されていない他のトークンは[RFC4234]からインポートされます。これらは、SP、HTAB、WSP、ALPHA、DIGIT、CRLFなどの直感的なプリミティブです。"
    },
    {
      "indent": 0,
      "text": "2.6. DKIM-Quoted-Printable",
      "section_title": true,
      "ja": "2.6. DKIM-Quoted-Printable"
    },
    {
      "indent": 3,
      "text": "The DKIM-Quoted-Printable encoding syntax resembles that described in Quoted-Printable [RFC2045], Section 6.7: any character MAY be encoded as an \"=\" followed by two hexadecimal digits from the alphabet \"0123456789ABCDEF\" (no lowercase characters permitted) representing the hexadecimal-encoded integer value of that character. All control characters (those with values < %x20), 8-bit characters (values > %x7F), and the characters DEL (%x7F), SPACE (%x20), and semicolon (\";\", %x3B) MUST be encoded. Note that all whitespace, including SPACE, CR, and LF characters, MUST be encoded. After encoding, FWS MAY be added at arbitrary locations in order to avoid excessively long lines; such whitespace is NOT part of the value, and MUST be removed before decoding.",
      "ja": "DKIM-Quoted-Printableエンコーディングの構文は、Quoted-Printable [RFC2045]のセクション6.7で説明されているものと似ています。任意の文字は、「=」の後にアルファベット「0123456789ABCDEF」からの2つの16進数字（小文字は許可されません）としてエンコードされます（MAY）。その文字の16進数でエンコードされた整数値。すべての制御文字（値<％x20の文字）、8ビット文字（値>％x7F）、および文字DEL（％x7F）、スペース（％x20）、およびセミコロン（ \";\"、％x3B）は、エンコード。空白、CR、LF文字を含むすべての空白はエンコードする必要があることに注意してください。エンコード後、過度に長い行を避けるために、FWSを任意の場所に追加してもよい（MAY）。このような空白は値の一部ではなく、デコードする前に削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "dkim-quoted-printable =\n                   *(FWS / hex-octet / dkim-safe-char)\n              ; hex-octet is from RFC 2045\ndkim-safe-char =   %x21-3A / %x3C / %x3E-7E\n              ; '!' - ':', '<', '>' - '~'\n              ; Characters not listed as \"mail-safe\" in\n              ; RFC 2049 are also not recommended.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: DKIM-Quoted-Printable differs from Quoted-Printable as defined in RFC 2045 in several important ways:",
      "ja": "有益な注意：DKIM-Quoted-Printableは、RFC 2045で定義されているQuoted-Printableといくつかの重要な点で異なります。"
    },
    {
      "indent": 6,
      "text": "1. Whitespace in the input text, including CR and LF, must be encoded. RFC 2045 does not require such encoding, and does not permit encoding of CR or LF characters that are part of a CRLF line break.",
      "ja": "1. CRとLFを含む入力テキストの空白はエンコードする必要があります。 RFC 2045はそのようなエンコードを必要とせず、CRLF改行の一部であるCRまたはLF文字のエンコードを許可しません。"
    },
    {
      "indent": 6,
      "text": "2. Whitespace in the encoded text is ignored. This is to allow tags encoded using DKIM-Quoted-Printable to be wrapped as needed. In particular, RFC 2045 requires that line breaks in the input be represented as physical line breaks; that is not the case here.",
      "ja": "2. エンコードされたテキストの空白は無視されます。これは、DKIM-Quoted-Printableを使用してエンコードされたタグを必要に応じてラップできるようにするためです。特に、RFC 2045では、入力の改行を物理的な改行として表す必要があります。ここではそうではありません。"
    },
    {
      "indent": 6,
      "text": "3. The \"soft line break\" syntax (\"=\" as the last non-whitespace character on the line) does not apply.",
      "ja": "3. 「ソフト改行」構文（行の最後の非空白文字としての「=」）は適用されません。"
    },
    {
      "indent": 6,
      "text": "4. DKIM-Quoted-Printable does not require that encoded lines be no more than 76 characters long (although there may be other requirements depending on the context in which the encoded text is being used).",
      "ja": "4. DKIM-Quoted-Printableは、エンコードされた行が76文字を超えないことを要求しません（ただし、エンコードされたテキストが使用されているコンテキストによっては、他の要件がある場合もあります）。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Elements",
      "section_title": true,
      "ja": "3. プロトコル要素"
    },
    {
      "indent": 3,
      "text": "Protocol Elements are conceptual parts of the protocol that are not specific to either signers or verifiers. The protocol descriptions for signers and verifiers are described in later sections (Signer Actions (Section 5) and Verifier Actions (Section 6)). NOTE: This section must be read in the context of those sections.",
      "ja": "プロトコル要素は、プロトコルの概念的な部分であり、署名者または検証者に固有ではありません。署名者と検証者のプロトコルの説明は、後のセクション（署名者アクション（セクション5）および検証者アクション（セクション6））で説明されています。注：このセクションは、これらのセクションのコンテキストで読む必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Selectors",
      "section_title": true,
      "ja": "3.1. セレクター"
    },
    {
      "indent": 3,
      "text": "To support multiple concurrent public keys per signing domain, the key namespace is subdivided using \"selectors\". For example, selectors might indicate the names of office locations (e.g., \"sanfrancisco\", \"coolumbeach\", and \"reykjavik\"), the signing date (e.g., \"january2005\", \"february2005\", etc.), or even the individual user.",
      "ja": "署名ドメインごとに複数の同時公開鍵をサポートするために、「名前空間」は「セレクター」を使用して細分されます。たとえば、セレクタは、オフィスの場所の名前（たとえば、「sanfrancisco」、「coolumbeach」、および「reykjavik」）、署名日（たとえば、「january2005」、「february2005」など）、または個人ユーザー。"
    },
    {
      "indent": 3,
      "text": "Selectors are needed to support some important use cases. For example:",
      "ja": "セレクターは、いくつかの重要な使用例をサポートするために必要です。例えば："
    },
    {
      "indent": 3,
      "text": "o Domains that want to delegate signing capability for a specific address for a given duration to a partner, such as an advertising provider or other outsourced function.",
      "ja": "o 広告プロバイダーやその他の外部委託機能など、特定のアドレスの署名機能を特定の期間、パートナーに委任するドメイン。"
    },
    {
      "indent": 3,
      "text": "o Domains that want to allow frequent travelers to send messages locally without the need to connect with a particular MSA.",
      "ja": "o 頻繁な旅行者が特定のMSAに接続する必要なくローカルにメッセージを送信できるようにするドメイン。"
    },
    {
      "indent": 3,
      "text": "o \"Affinity\" domains (e.g., college alumni associations) that provide forwarding of incoming mail, but that do not operate a mail submission agent for outgoing mail.",
      "ja": "o 受信メールの転送を提供するが、送信メールのメール送信エージェントを操作しない「アフィニティ」ドメイン（大学の同窓会など）。"
    },
    {
      "indent": 3,
      "text": "Periods are allowed in selectors and are component separators. When keys are retrieved from the DNS, periods in selectors define DNS label boundaries in a manner similar to the conventional use in domain names. Selector components might be used to combine dates with locations, for example, \"march2005.reykjavik\". In a DNS implementation, this can be used to allow delegation of a portion of the selector namespace.",
      "ja": "ピリオドはセレクターで使用でき、コンポーネントセパレーターです。 DNSからキーを取得する場合、セレクターのピリオドは、ドメイン名での従来の使用と同様の方法でDNSラベル境界を定義します。セレクタコンポーネントを使用して、日付を場所と組み合わせることができます（例： \"march2005.reykjavik\"）。 DNS実装では、これを使用して、セレクター名前空間の一部の委任を許可できます。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "selector = sub-domain *( \".\" sub-domain )",
      "ja": "セレクター=サブドメイン*（ \"。\"サブドメイン）"
    },
    {
      "indent": 3,
      "text": "The number of public keys and corresponding selectors for each domain is determined by the domain owner. Many domain owners will be satisfied with just one selector, whereas administratively distributed organizations may choose to manage disparate selectors and key pairs in different regions or on different email servers.",
      "ja": "各ドメインの公開鍵と対応するセレクターの数は、ドメインの所有者によって決定されます。多くのドメイン所有者は1つのセレクターで満足しますが、管理上分散している組織は、異なる地域または異なるメールサーバーで異なるセレクターとキーペアを管理することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Beyond administrative convenience, selectors make it possible to seamlessly replace public keys on a routine basis. If a domain wishes to change from using a public key associated with selector \"january2005\" to a public key associated with selector \"february2005\", it merely makes sure that both public keys are advertised in the public-key repository concurrently for the transition period during which email may be in transit prior to verification. At the start of the transition period, the outbound email servers are configured to sign with the \"february2005\" private key. At the end of the transition period, the \"january2005\" public key is removed from the public-key repository.",
      "ja": "管理者の利便性を超えて、セレクターは日常的に公開鍵をシームレスに置き換えることを可能にします。ドメインがセレクター「january2005」に関連付けられた公開鍵の使用からセレクター「february2005」に関連付けられた公開鍵への変更を希望する場合、移行期間中に両方の公開鍵が公開鍵リポジトリーで同時にアドバタイズされることを確認するだけです。確認前に転送される可能性のあるメール移行期間の開始時に、送信メールサーバーは「february2005」秘密鍵で署名するように設定されています。移行期間の終わりに、「january2005」公開鍵は公開鍵リポジトリーから削除されます。"
    },
    {
      "indent": 0,
      "text": " INFORMATIVE NOTE: A key may also be revoked as described below. The distinction between revoking and removing a key selector record is subtle. When phasing out keys as described above, a signing domain would probably simply remove the key record after the transition period. However, a signing domain could elect to revoke the key (but maintain the key record) for a further period. There is no defined semantic difference between a revoked key and a removed key.",
      "ja": "有益な注意：以下に説明するように、キーを取り消すこともできます。キーセレクタレコードの取り消しと削除の違いは微妙です。上記のようにキーを段階的に廃止する場合、署名ドメインはおそらく移行期間後にキーレコードを削除するだけです。ただし、署名ドメインは、キーを失効させる（ただし、キーレコードを維持する）ことを選択できます。取り消されたキーと削除されたキーの間には、定義された意味上の違いはありません。"
    },
    {
      "indent": 3,
      "text": "While some domains may wish to make selector values well known, others will want to take care not to allocate selector names in a way that allows harvesting of data by outside parties. For example, if per-user keys are issued, the domain owner will need to make the decision as to whether to associate this selector directly with the user name, or make it some unassociated random value, such as a fingerprint of the public key.",
      "ja": "一部のドメインはセレクター値をよく知らせたいかもしれませんが、他のドメインは、外部の関係者によるデータの収集を可能にする方法でセレクター名を割り当てないように注意したいと思うでしょう。たとえば、ユーザーごとのキーが発行された場合、ドメイン所有者は、このセレクターをユーザー名に直接関連付けるか、または公開鍵のフィンガープリントなど、関連付けられていないランダムな値にするかを決定する必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS NOTE: Reusing a selector with a new key (for example, changing the key associated with a user's name) makes it impossible to tell the difference between a message that didn't verify because the key is no longer valid versus a message that is actually forged. For this reason, signers are ill-advised to reuse selectors for new keys. A better strategy is to assign new keys to new selectors.",
      "ja": "有益な操作注：セレクタを新しいキーで再利用すると（たとえば、ユーザー名に関連付けられているキーを変更すると）、キーが無効になったために検証されなかったメッセージと、実際に偽造されています。このため、署名者は新しいキーのセレクターを再利用することをお勧めしません。より良い戦略は、新しいセレクタに新しいキーを割り当てることです。"
    },
    {
      "indent": 0,
      "text": "3.2. Tag=Value Lists",
      "section_title": true,
      "ja": "3.2. タグ=値リスト"
    },
    {
      "indent": 3,
      "text": "DKIM uses a simple \"tag=value\" syntax in several contexts, including in messages and domain signature records.",
      "ja": "DKIMは、メッセージやドメイン署名レコードなど、いくつかのコンテキストで単純な「tag = value」構文を使用します。"
    },
    {
      "indent": 3,
      "text": "Values are a series of strings containing either plain text, \"base64\" text (as defined in [RFC2045], Section 6.8), \"qp-section\" (ibid, Section 6.7), or \"dkim-quoted-printable\" (as defined in Section 2.6). The name of the tag will determine the encoding of each value. Unencoded semicolon (\";\") characters MUST NOT occur in the tag value, since that separates tag-specs.",
      "ja": "値は、プレーンテキスト、「base64」テキスト（[RFC2045]、セクション6.8で定義）、「qp-section」（同書、セクション6.7）、または「dkim-quoted-printable」（定義）のいずれかを含む一連の文字列ですセクション2.6）。タグの名前は、各値のエンコーディングを決定します。エンコードされていないセミコロン（ \";\"）文字は、タグの仕様を区切るため、タグ値に使用してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Although the \"plain text\" defined below (as \"tag-value\") only includes 7-bit characters, an implementation that wished to anticipate future standards would be advised not to preclude the use of UTF8-encoded text in tag=value lists.",
      "ja": "有益な実装注：（「タグ値」として）以下で定義されている「プレーンテキスト」には7ビット文字しか含まれていませんが、将来の標準を予想する実装では、タグでのUTF8エンコードテキストの使用を禁止しないようにしてください。 =値リスト。"
    },
    {
      "indent": 3,
      "text": "Formally, the syntax rules are as follows:",
      "ja": "正式には、構文規則は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "tag-list  =  tag-spec 0*( \";\" tag-spec ) [ \";\" ]\ntag-spec  =  [FWS] tag-name [FWS] \"=\" [FWS] tag-value [FWS]\ntag-name  =  ALPHA 0*ALNUMPUNC\ntag-value =  [ tval 0*( 1*(WSP / FWS) tval ) ]\n                  ; WSP and FWS prohibited at beginning and end\ntval      =  1*VALCHAR\nVALCHAR   =  %x21-3A / %x3C-7E\n                  ; EXCLAMATION to TILDE except SEMICOLON\nALNUMPUNC =  ALPHA / DIGIT / \"_\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that WSP is allowed anywhere around tags. In particular, any WSP after the \"=\" and any WSP before the terminating \";\" is not part of the value; however, WSP inside the value is significant.",
      "ja": "WSPはタグの周囲のどこでも許可されることに注意してください。特に、「=」の後のすべてのWSPおよび終了する「;」の前のすべてのWSP値の一部ではありません。ただし、値内のWSPは重要です。"
    },
    {
      "indent": 3,
      "text": "Tags MUST be interpreted in a case-sensitive manner. Values MUST be processed as case sensitive unless the specific tag description of semantics specifies case insensitivity.",
      "ja": "タグは大文字と小文字を区別して解釈する必要があります。セマンティクスの特定のタグの説明で大文字と小文字の区別が指定されていない限り、値は大文字と小文字を区別して処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Tags with duplicate names MUST NOT occur within a single tag-list; if a tag name does occur more than once, the entire tag-list is invalid.",
      "ja": "重複した名前のタグは、単一のタグリスト内で発生してはなりません。タグ名が複数回出現する場合、タグリスト全体が無効です。"
    },
    {
      "indent": 3,
      "text": "Whitespace within a value MUST be retained unless explicitly excluded by the specific tag description.",
      "ja": "値内の空白は、特定のタグの説明によって明示的に除外されていない限り保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Tag=value pairs that represent the default value MAY be included to aid legibility.",
      "ja": "デフォルト値を表すTag = valueペアは、読みやすくするために含めることができます。"
    },
    {
      "indent": 3,
      "text": "Unrecognized tags MUST be ignored.",
      "ja": "認識されないタグは無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Tags that have an empty value are not the same as omitted tags. An omitted tag is treated as having the default value; a tag with an empty value explicitly designates the empty string as the value. For example, \"g=\" does not mean \"g=*\", even though \"g=*\" is the default for that tag.",
      "ja": "空の値を持つタグは、省略されたタグとは異なります。省略されたタグは、デフォルト値を持つものとして扱われます。空の値を持つタグは、空の文字列を値として明示的に指定します。たとえば、「g = *」はそのタグのデフォルトですが、「g = *」は意味しません。"
    },
    {
      "indent": 0,
      "text": "3.3. Signing and Verification Algorithms",
      "section_title": true,
      "ja": "3.3. 署名および検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "DKIM supports multiple digital signature algorithms. Two algorithms are defined by this specification at this time: rsa-sha1 and rsa-sha256. The rsa-sha256 algorithm is the default if no algorithm is specified. Verifiers MUST implement both rsa-sha1 and rsa-sha256. Signers MUST implement and SHOULD sign using rsa-sha256.",
      "ja": "DKIMは複数のデジタル署名アルゴリズムをサポートしています。現在、この仕様では、rsa-sha1とrsa-sha256の2つのアルゴリズムが定義されています。アルゴリズムが指定されていない場合、rsa-sha256アルゴリズムがデフォルトです。検証者は、rsa-sha1とrsa-sha256の両方を実装する必要があります。署名者はrsa-sha256を使用して実装し、署名する必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Although sha256 is strongly encouraged, some senders of low-security messages (such as routine newsletters) may prefer to use sha1 because of reduced CPU requirements to compute a sha1 hash. In general, sha256 should always be used whenever possible.",
      "ja": "有益な注意：sha256は強く推奨されますが、sha1ハッシュを計算するためのCPU要件が減少するため、低セキュリティメッセージの送信者（定期的なニュースレターなど）は、sha1の使用を好む場合があります。一般に、可能な限り常にsha256を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. The rsa-sha1 Signing Algorithm",
      "section_title": true,
      "ja": "3.3.1. rsa-sha1署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The rsa-sha1 Signing Algorithm computes a message hash as described in Section 3.7 below using SHA-1 [FIPS.180-2.2002] as the hash-alg. That hash is then signed by the signer using the RSA algorithm (defined in PKCS#1 version 1.5 [RFC3447]) as the crypt-alg and the signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed. The signing algorithm SHOULD use a public exponent of 65537.",
      "ja": "rsa-sha1署名アルゴリズムは、ハッシュアルゴリズムとしてSHA-1 [FIPS.180-2.2002]を使用して、以下のセクション3.7で説明するようにメッセージハッシュを計算します。次に、そのハッシュは、RSAアルゴリズム（PKCS＃1バージョン1.5 [RFC3447]で定義）をcrypt-algおよび署名者の秘密鍵として使用して、署名者によって署名されます。ハッシュは、署名される前に、切り詰められたり、ネイティブのバイナリ形式以外の形式に変換されてはなりません（MUST NOT）。署名アルゴリズムは65537の公開指数を使用する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "3.3.2. The rsa-sha256 Signing Algorithm",
      "section_title": true,
      "ja": "3.3.2. rsa-sha256署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The rsa-sha256 Signing Algorithm computes a message hash as described in Section 3.7 below using SHA-256 [FIPS.180-2.2002] as the hash-alg. That hash is then signed by the signer using the RSA algorithm (defined in PKCS#1 version 1.5 [RFC3447]) as the crypt-alg and the signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed.",
      "ja": "rsa-sha256署名アルゴリズムは、ハッシュアルゴリズムとしてSHA-256 [FIPS.180-2.2002]を使用して、以下のセクション3.7で説明するようにメッセージハッシュを計算します。次に、そのハッシュは、RSAアルゴリズム（PKCS＃1バージョン1.5 [RFC3447]で定義）をcrypt-algおよび署名者の秘密鍵として使用して、署名者によって署名されます。ハッシュは、署名される前に、切り詰められたり、ネイティブのバイナリ形式以外の形式に変換されてはなりません（MUST NOT）。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Key Sizes",
      "section_title": true,
      "ja": "3.3.3. キーサイズ"
    },
    {
      "indent": 3,
      "text": "Selecting appropriate key sizes is a trade-off between cost, performance, and risk. Since short RSA keys more easily succumb to off-line attacks, signers MUST use RSA keys of at least 1024 bits for long-lived keys. Verifiers MUST be able to validate signatures with keys ranging from 512 bits to 2048 bits, and they MAY be able to validate signatures with larger keys. Verifier policies may use the length of the signing key as one metric for determining whether a signature is acceptable.",
      "ja": "適切な鍵サイズを選択することは、コスト、パフォーマンス、およびリスクの間のトレードオフです。短いRSA鍵はオフライン攻撃に負けやすいので、署名者は長期間有効な鍵に対して少なくとも1024ビットのRSA鍵を使用する必要があります。検証者は、512ビットから2048ビットの範囲のキーで署名を検証できなければなりません。また、より大きなキーで署名を検証できます。検証者ポリシーは、署名が受け入れ可能かどうかを判断するための1つのメトリックとして、署名鍵の長さを使用できます。"
    },
    {
      "indent": 3,
      "text": "Factors that should influence the key size choice include the following:",
      "ja": "キーサイズの選択に影響を与える要素には、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o The practical constraint that large (e.g., 4096 bit) keys may not fit within a 512-byte DNS UDP response packet",
      "ja": "o 大きな（4096ビットなどの）キーが512バイトのDNS UDP応答パケットに収まらない可能性があるという実際的な制約"
    },
    {
      "indent": 3,
      "text": "o The security constraint that keys smaller than 1024 bits are subject to off-line attacks",
      "ja": "o 1024ビット未満のキーはオフライン攻撃の影響を受けるというセキュリティ上の制約"
    },
    {
      "indent": 0,
      "text": " o Larger keys impose higher CPU costs to verify and sign email o Keys can be replaced on a regular basis, thus their lifetime can be relatively short",
      "ja": "o鍵が大きいほど、メールの検証と署名にかかるCPUコストが高くなりますo鍵は定期的に交換できるため、寿命が比較的短くなる可能性があります"
    },
    {
      "indent": 3,
      "text": "o The security goals of this specification are modest compared to typical goals of other systems that employ digital signatures",
      "ja": "o この仕様のセキュリティ目標は、デジタル署名を採用する他のシステムの一般的な目標と比較して控えめです"
    },
    {
      "indent": 3,
      "text": "See [RFC3766] for further discussion on selecting key sizes.",
      "ja": "キーサイズの選択に関する詳細な説明については、[RFC3766]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Other Algorithms",
      "section_title": true,
      "ja": "3.3.4. その他のアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Other algorithms MAY be defined in the future. Verifiers MUST ignore any signatures using algorithms that they do not implement.",
      "ja": "他のアルゴリズムは将来定義されるかもしれません。検証者は、実装していないアルゴリズムを使用する署名を無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Canonicalization",
      "section_title": true,
      "ja": "3.4. 正規化"
    },
    {
      "indent": 3,
      "text": "Empirical evidence demonstrates that some mail servers and relay systems modify email in transit, potentially invalidating a signature. There are two competing perspectives on such modifications. For most signers, mild modification of email is immaterial to the authentication status of the email. For such signers, a canonicalization algorithm that survives modest in-transit modification is preferred.",
      "ja": "経験的証拠は、一部のメールサーバーと中継システムが送信中の電子メールを変更し、署名を無効にする可能性があることを示しています。このような変更には2つの競合する見方があります。ほとんどの署名者にとって、電子メールの軽微な変更は、電子メールの認証ステータスには重要ではありません。そのような署名者にとっては、控えめな移動中の変更に耐える正規化アルゴリズムが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Other signers demand that any modification of the email, however minor, result in a signature verification failure. These signers prefer a canonicalization algorithm that does not tolerate in-transit modification of the signed email.",
      "ja": "他の署名者は、電子メールを少しでも変更すると、署名検証が失敗することを要求します。これらの署名者は、署名された電子メールの転送中の変更を許容しない正規化アルゴリズムを好みます。"
    },
    {
      "indent": 3,
      "text": "Some signers may be willing to accept modifications to header fields that are within the bounds of email standards such as [RFC2822], but are unwilling to accept any modification to the body of messages.",
      "ja": "一部の署名者は、[RFC2822]などの電子メール標準の範囲内にあるヘッダーフィールドへの変更を受け入れても、メッセージの本文への変更を受け入れたくない場合があります。"
    },
    {
      "indent": 3,
      "text": "To satisfy all requirements, two canonicalization algorithms are defined for each of the header and the body: a \"simple\" algorithm that tolerates almost no modification and a \"relaxed\" algorithm that tolerates common modifications such as whitespace replacement and header field line rewrapping. A signer MAY specify either algorithm for header or body when signing an email. If no canonicalization algorithm is specified by the signer, the \"simple\" algorithm defaults for both header and body. Verifiers MUST implement both canonicalization algorithms. Note that the header and body may use different canonicalization algorithms. Further canonicalization algorithms MAY be defined in the future; verifiers MUST ignore any signatures that use unrecognized canonicalization algorithms.",
      "ja": "すべての要件を満たすために、ヘッダーと本文のそれぞれに2つの正規化アルゴリズムが定義されています。ほとんど変更を許容しない「単純な」アルゴリズムと、空白の置換やヘッダーフィールドの行の再ラップなどの一般的な修正を許容する「リラックスした」アルゴリズムです。署名者は、電子メールに署名するときに、ヘッダーまたは本文のいずれかのアルゴリズムを指定する場合があります。正規化アルゴリズムが署名者によって指定されていない場合、「単純な」アルゴリズムのデフォルトはヘッダーと本文の両方です。検証者は、両方の正規化アルゴリズムを実装する必要があります。ヘッダーと本文は異なる正規化アルゴリズムを使用する場合があることに注意してください。さらなる正規化アルゴリズムは将来定義されるかもしれません。検証者は、認識されていない正規化アルゴリズムを使用するすべての署名を無視する必要があります。"
    },
    {
      "indent": 0,
      "text": " Canonicalization simply prepares the email for presentation to the signing or verification algorithm. It MUST NOT change the transmitted data in any way. Canonicalization of header fields and body are described below.",
      "ja": "正規化は、署名または検証アルゴリズムに提示するために電子メールを準備するだけです。送信されたデータを変更してはなりません。ヘッダーフィールドと本文の正規化について以下に説明します。"
    },
    {
      "indent": 3,
      "text": "NOTE: This section assumes that the message is already in \"network normal\" format (text is ASCII encoded, lines are separated with CRLF characters, etc.). See also Section 5.3 for information about normalizing the message.",
      "ja": "注：このセクションでは、メッセージがすでに「ネットワーク通常」形式であることを前提としています（テキストはASCIIエンコードされ、行はCRLF文字で区切られています）。メッセージの正規化については、セクション5.3も参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.1. The \"simple\" Header Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.1. 「シンプルな」ヘッダー正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"simple\" header canonicalization algorithm does not change header fields in any way. Header fields MUST be presented to the signing or verification algorithm exactly as they are in the message being signed or verified. In particular, header field names MUST NOT be case folded and whitespace MUST NOT be changed.",
      "ja": "「単純な」ヘッダー正規化アルゴリズムは、ヘッダーフィールドをまったく変更しません。ヘッダーフィールドは、署名または検証されるメッセージとまったく同じように、署名または検証アルゴリズムに提示する必要があります。特に、ヘッダーフィールド名は大文字小文字を区別してはならず、空白は変更してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.2. The \"relaxed\" Header Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.2. 「リラックスした」ヘッダー正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"relaxed\" header canonicalization algorithm MUST apply the following steps in order:",
      "ja": "「リラックスした」ヘッダー正規化アルゴリズムでは、次の手順を順番に適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Convert all header field names (not the header field values) to lowercase. For example, convert \"SUBJect: AbC\" to \"subject: AbC\".",
      "ja": "o すべてのヘッダーフィールド名（ヘッダーフィールド値ではない）を小文字に変換します。たとえば、「SUBJect：AbC」を「subject：AbC」に変換します。"
    },
    {
      "indent": 3,
      "text": "o Unfold all header field continuation lines as described in [RFC2822]; in particular, lines with terminators embedded in continued header field values (that is, CRLF sequences followed by WSP) MUST be interpreted without the CRLF. Implementations MUST NOT remove the CRLF at the end of the header field value.",
      "ja": "o [RFC2822]で説明されているように、すべてのヘッダーフィールド継続行を展開します。特に、継続ヘッダーフィールドの値に埋め込まれたターミネーターを含む行（つまり、WLFが後に続くCRLFシーケンス）は、CRLFなしで解釈する必要があります。実装では、ヘッダーフィールド値の最後にあるCRLFを削除してはなりません（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o Convert all sequences of one or more WSP characters to a single SP character. WSP characters here include those before and after a line folding boundary.",
      "ja": "o 1つ以上のWSP文字のすべてのシーケンスを単一のSP文字に変換します。ここでのWSP文字には、行の折りたたみ境界の前後の文字が含まれます。"
    },
    {
      "indent": 3,
      "text": "o Delete all WSP characters at the end of each unfolded header field value.",
      "ja": "o 展開された各ヘッダーフィールド値の末尾にあるすべてのWSP文字を削除します。"
    },
    {
      "indent": 3,
      "text": "o Delete any WSP characters remaining before and after the colon separating the header field name from the header field value. The colon separator MUST be retained.",
      "ja": "o ヘッダーフィールド名とヘッダーフィールド値を区切るコロンの前後に残っているWSP文字を削除します。コロン区切り文字は保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.3. The \"simple\" Body Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.3. 「シンプルな」ボディ正規化アルゴリズム"
    },
    {
      "indent": 0,
      "text": " The \"simple\" body canonicalization algorithm ignores all empty lines at the end of the message body. An empty line is a line of zero length after removal of the line terminator. If there is no body or no trailing CRLF on the message body, a CRLF is added. It makes no other changes to the message body. In more formal terms, the \"simple\" body canonicalization algorithm converts \"0*CRLF\" at the end of the body to a single \"CRLF\".",
      "ja": "「シンプルな」本文の正規化アルゴリズムでは、メッセージ本文の末尾にある空の行はすべて無視されます。空行とは、行末記号を削除した後の長さがゼロの行です。メッセージ本文に本文がないか、末尾のCRLFがない場合は、CRLFが追加されます。メッセージ本文に他の変更は加えません。より正式には、「単純な」ボディ正規化アルゴリズムは、ボディの最後の「0 * CRLF」を単一の「CRLF」に変換します。"
    },
    {
      "indent": 3,
      "text": "Note that a completely empty or missing body is canonicalized as a single \"CRLF\"; that is, the canonicalized length will be 2 octets.",
      "ja": "完全に空または欠落しているボディは、単一の「CRLF」として正規化されることに注意してください。つまり、正規化された長さは2オクテットになります。"
    },
    {
      "indent": 0,
      "text": "3.4.4. The \"relaxed\" Body Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.4. 「リラックスした」ボディの正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"relaxed\" body canonicalization algorithm:",
      "ja": "「リラックスした」ボディの正規化アルゴリズム："
    },
    {
      "indent": 3,
      "text": "o Ignores all whitespace at the end of lines. Implementations MUST NOT remove the CRLF at the end of the line.",
      "ja": "o 行末のすべての空白を無視します。実装は行末のCRLFを削除してはならない（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "o Reduces all sequences of WSP within a line to a single SP character.",
      "ja": "o 行内のWSPのすべてのシーケンスを単一のSP文字に減らします。"
    },
    {
      "indent": 3,
      "text": "o Ignores all empty lines at the end of the message body. \"Empty line\" is defined in Section 3.4.3.",
      "ja": "o メッセージ本文の末尾にある空の行をすべて無視します。 「空ライン」はセクション3.4.3で定義されています。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: It should be noted that the relaxed body canonicalization algorithm may enable certain types of extremely crude \"ASCII Art\" attacks where a message may be conveyed by adjusting the spacing between words. If this is a concern, the \"simple\" body canonicalization algorithm should be used instead.",
      "ja": "有益な注意：リラックスしたボディの正規化アルゴリズムは、単語間の間隔を調整することによってメッセージが伝達される特定の種類の非常に粗雑な「ASCIIアート」攻撃を可能にする場合があることに注意してください。これが問題になる場合は、代わりに「単純な」ボディ正規化アルゴリズムを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.5. Body Length Limits",
      "section_title": true,
      "ja": "3.4.5. 体長制限"
    },
    {
      "indent": 3,
      "text": "A body length count MAY be specified to limit the signature calculation to an initial prefix of the body text, measured in octets. If the body length count is not specified, the entire message body is signed.",
      "ja": "本文の長さのカウントを指定して、署名の計算を、オクテットで測定された本文テキストの最初のプレフィックスに制限することができます。本文の長さのカウントが指定されていない場合、メッセージ本文全体が署名されます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: This capability is provided because it is very common for mailing lists to add trailers to messages (e.g., instructions how to get off the list). Until those messages are also signed, the body length count is a useful tool for the verifier since it may as a matter of policy accept messages having valid signatures with extraneous data.",
      "ja": "有益な根拠：この機能は、メーリングリストがメッセージにトレーラーを追加することが非常に一般的であるために提供されています（たとえば、リストから降りる方法の説明）。これらのメッセージも署名されるまで、本文の長さのカウントは、ポリシーの問題として、無関係なデータを含む有効な署名を持つメッセージを受け入れる可能性があるため、検証者にとって有用なツールです。"
    },
    {
      "indent": 0,
      "text": " INFORMATIVE IMPLEMENTATION NOTE: Using body length limits enables an attack in which an attacker modifies a message to include content that solely benefits the attacker. It is possible for the appended content to completely replace the original content in the end recipient's eyes and to defeat duplicate message detection algorithms. To avoid this attack, signers should be wary of using this tag, and verifiers might wish to ignore the tag or remove text that appears after the specified content length, perhaps based on other criteria.",
      "ja": "有益な実装注：ボディの長さの制限を使用すると、攻撃者がメッセージを変更して、攻撃者にのみ利益をもたらすコンテンツを含める攻撃が可能になります。追加されたコンテンツが、最終受信者の目で元のコンテンツを完全に置き換え、重複メッセージ検出アルゴリズムを無効にする可能性があります。この攻撃を回避するには、署名者はこのタグの使用に注意する必要があり、検証者はタグを無視するか、おそらく他の基準に基づいて、指定されたコンテンツの長さの後に表示されるテキストを削除することができます。"
    },
    {
      "indent": 3,
      "text": "The body length count allows the signer of a message to permit data to be appended to the end of the body of a signed message. The body length count MUST be calculated following the canonicalization algorithm; for example, any whitespace ignored by a canonicalization algorithm is not included as part of the body length count. Signers of MIME messages that include a body length count SHOULD be sure that the length extends to the closing MIME boundary string.",
      "ja": "本文の長さのカウントにより、メッセージの署名者は、署名されたメッセージの本文の末尾にデータを追加できます。本文の長さのカウントは、正規化アルゴリズムに従って計算する必要があります。たとえば、正規化アルゴリズムによって無視された空白は、ボディ長カウントの一部として含まれません。本文の長さのカウントを含むMIMEメッセージの署名者は、その長さがMIME境界の終了文字列にまで及ぶことを確認してください。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: A signer wishing to ensure that the only acceptable modifications are to add to the MIME postlude would use a body length count encompassing the entire final MIME boundary string, including the final \"--CRLF\". A signer wishing to allow additional MIME parts but not modification of existing parts would use a body length count extending through the final MIME boundary string, omitting the final \"--CRLF\". Note that this only works for some MIME types, e.g., multipart/mixed but not multipart/signed.",
      "ja": "有益な実装注：受け入れ可能な変更のみがMIMEポストリュードへの追加であることを確認したい署名者は、最後の「--CRLF」を含む最終的なMIME境界文字列全体を含むボディ長カウントを使用します。追加のMIMEパーツを許可し、既存のパーツの変更は許可しないことを希望する署名者は、最終的な「--CRLF」を省略して、最終的なMIME境界文字列を通るボディ長カウントを使用します。これは、たとえばmultipart / mixedなどの一部のMIMEタイプでのみ機能し、multipart / signedでは機能しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A body length count of zero means that the body is completely unsigned.",
      "ja": "ボディの長さのカウントが0の場合、ボディは完全に符号なしです。"
    },
    {
      "indent": 3,
      "text": "Signers wishing to ensure that no modification of any sort can occur should specify the \"simple\" canonicalization algorithm for both header and body and omit the body length count.",
      "ja": "あらゆる種類の変更が発生しないようにしたい署名者は、ヘッダーと本文の両方に「単純な」正規化アルゴリズムを指定し、本文の長さのカウントを省略します。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Canonicalization Examples (INFORMATIVE)",
      "section_title": true,
      "ja": "3.4.6. 正規化の例（参考情報）"
    },
    {
      "indent": 3,
      "text": "In the following examples, actual whitespace is used only for clarity. The actual input and output text is designated using bracketed descriptors: \"<SP>\" for a space character, \"<HTAB>\" for a tab character, and \"<CRLF>\" for a carriage-return/line-feed sequence. For example, \"X <SP> Y\" and \"X<SP>Y\" represent the same three characters.",
      "ja": "次の例では、実際の空白はわかりやすくするためにのみ使用されています。実際の入力および出力テキストは、括弧で囲まれた記述子を使用して指定されます。スペース文字の場合は「<SP>」、タブ文字の場合は「<HTAB>」、キャリッジリターン/ラインフィードシーケンスの場合は「<CRLF>」です。たとえば、「X <SP> Y」と「X <SP> Y」は同じ3つの文字を表します。"
    },
    {
      "indent": 3,
      "text": "Example 1: A message reading:",
      "ja": "例1：メッセージの読み取り："
    },
    {
      "indent": 7,
      "text": "A: <SP> X <CRLF>\nB <SP> : <SP> Y <HTAB><CRLF>\n<HTAB> Z <SP><SP><CRLF>\n<CRLF>\n<SP> C <SP><CRLF>\nD <SP><HTAB><SP> E <CRLF>\n<CRLF>\n<CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "when canonicalized using relaxed canonicalization for both header and body results in a header reading:",
      "ja": "ヘッダーと本文の両方に対して緩和された正規化を使用して正規化すると、ヘッダーは次のようになります。"
    },
    {
      "indent": 7,
      "text": "a:X <CRLF>\nb:Y <SP> Z <CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "と体の読書："
    },
    {
      "indent": 7,
      "text": "<SP> C <CRLF>\nD <SP> E <CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 2: The same message canonicalized using simple canonicalization for both header and body results in a header reading:",
      "ja": "例2：ヘッダーと本文の両方に単純な正規化を使用して同じメッセージを正規化すると、ヘッダーは次のようになります。"
    },
    {
      "indent": 7,
      "text": "A: <SP> X <CRLF>\nB <SP> : <SP> Y <HTAB><CRLF>\n<HTAB> Z <SP><SP><CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "と体の読書："
    },
    {
      "indent": 7,
      "text": "<SP> C <SP><CRLF>\nD <SP><HTAB><SP> E <CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Example 3: When processed using relaxed header canonicalization and simple body canonicalization, the canonicalized version has a header of:",
      "ja": "例3：緩和されたヘッダーの正規化と単純な本体の正規化を使用して処理すると、正規化されたバージョンのヘッダーは次のようになります。"
    },
    {
      "indent": 7,
      "text": "a:X <CRLF>\nb:Y <SP> Z <CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "と体の読書："
    },
    {
      "indent": 7,
      "text": "<SP> C <SP><CRLF>\nD <SP><HTAB><SP> E <CRLF>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5. The DKIM-Signature Header Field",
      "section_title": true,
      "ja": "3.5. DKIM-Signatureヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The signature of the email is stored in the DKIM-Signature header field. This header field contains all of the signature and key-fetching data. The DKIM-Signature value is a tag-list as described in Section 3.2.",
      "ja": "電子メールの署名は、DKIM-Signatureヘッダーフィールドに格納されます。このヘッダーフィールドには、すべての署名データとキーフェッチデータが含まれます。 DKIM-Signature値は、セクション3.2で説明されているタグリストです。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field SHOULD be treated as though it were a trace header field as defined in Section 3.6 of [RFC2822], and hence SHOULD NOT be reordered and SHOULD be prepended to the message.",
      "ja": "DKIM-Signatureヘッダーフィールドは、[RFC2822]のセクション3.6で定義されているように、トレースヘッダーフィールドであるかのように扱われる必要があるため（SHOULD）、順序を変更したり、メッセージの先頭に追加する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field being created or verified is always included in the signature calculation, after the rest of the header fields being signed; however, when calculating or verifying the signature, the value of the \"b=\" tag (signature value) of that DKIM-Signature header field MUST be treated as though it were an empty string. Unknown tags in the DKIM-Signature header field MUST be included in the signature calculation but MUST be otherwise ignored by verifiers. Other DKIM-Signature header fields that are included in the signature should be treated as normal header fields; in particular, the \"b=\" tag is not treated specially.",
      "ja": "作成または検証されるDKIM-Signatureヘッダーフィールドは、残りのヘッダーフィールドが署名された後、常に署名計算に含まれます。ただし、署名を計算または検証する場合、そのDKIM-Signatureヘッダーフィールドの「b =」タグ（署名値）の値は、空の文字列であるかのように処理する必要があります。 DKIM-Signatureヘッダーフィールドの不明なタグは、署名の計算に含める必要がありますが、検証者によって無視される必要があります。署名に含まれる他のDKIM-Signatureヘッダーフィールドは、通常のヘッダーフィールドとして扱う必要があります。特に、「b =」タグは特別に扱われません。"
    },
    {
      "indent": 3,
      "text": "The encodings for each field type are listed below. Tags described as qp-section are encoded as described in Section 6.7 of MIME Part One [RFC2045], with the additional conversion of semicolon characters to \"=3B\"; intuitively, this is one line of quoted-printable encoded text. The dkim-quoted-printable syntax is defined in Section 2.6.",
      "ja": "各フィールドタイプのエンコーディングを以下に示します。 qp-sectionとして記述されたタグは、MIMEパート1 [RFC2045]のセクション6.7に記述されているようにエンコードされ、セミコロン文字が「= 3B」に追加変換されます。直感的には、これはquoted-printableエンコードされたテキストの1行です。 dkim-quoted-printable構文はセクション2.6で定義されています。"
    },
    {
      "indent": 3,
      "text": "Tags on the DKIM-Signature header field along with their type and requirement status are shown below. Unrecognized tags MUST be ignored.",
      "ja": "DKIM-Signatureヘッダーフィールドのタグとそのタイプおよび要件ステータスを以下に示します。認識されないタグは無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "v= Version (MUST be included). This tag defines the version of this specification that applies to the signature record. It MUST have the value \"1\". Note that verifiers must do a string comparison on this value; for example, \"1\" is not the same as \"1.0\".",
      "ja": "v =バージョン（含める必要があります）。このタグは、署名レコードに適用されるこの仕様のバージョンを定義します。値は「1」でなければなりません。検証者はこの値に対して文字列比較を行う必要があることに注意してください。たとえば、「1」は「1.0」と同じではありません。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-v-tag   = %x76 [FWS] \"=\" [FWS] \"1\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "INFORMATIVE NOTE: DKIM-Signature version numbers are expected to increase arithmetically as new versions of this specification are released.",
      "ja": "有益な注意：この仕様の新しいバージョンがリリースされると、DKIM-Signatureのバージョン番号は算術的に増加すると予想されます。"
    },
    {
      "indent": 3,
      "text": "a=  The algorithm used to generate the signature (plain-text;\n    REQUIRED).  Verifiers MUST support \"rsa-sha1\" and \"rsa-sha256\";\n    signers SHOULD sign using \"rsa-sha256\".  See Section 3.3 for a\n    description of algorithms.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-a-tag       = %x61 [FWS] \"=\" [FWS] sig-a-tag-alg\nsig-a-tag-alg   = sig-a-tag-k \"-\" sig-a-tag-h\nsig-a-tag-k     = \"rsa\" / x-sig-a-tag-k\nsig-a-tag-h     = \"sha1\" / \"sha256\" / x-sig-a-tag-h\nx-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   ; for later extension\nx-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   ; for later extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "b= The signature data (base64; REQUIRED). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits. See Signer Actions (Section 5) for how the signature is computed.",
      "ja": "b =署名データ（base64;必須）。この値では空白は無視され、元の署名を再構築するときは無視する必要があります。特に、署名プロセスでは、FWSをこの値の任意の場所に安全に挿入して、行の長さの制限に適合させることができます。署名の計算方法については、署名者のアクション（セクション5）を参照してください。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-b-tag       = %x62 [FWS] \"=\" [FWS] sig-b-tag-data\nsig-b-tag-data  = base64string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "bh= The hash of the canonicalized body part of the message as limited by the \"l=\" tag (base64; REQUIRED). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits. See Section 3.7 for how the body hash is computed.",
      "ja": "bh =メッセージの正規化された本文部分のハッシュ。「l =」タグによって制限されます（base64;必須）。この値では空白は無視され、元の署名を再構築するときは無視する必要があります。特に、署名プロセスでは、FWSをこの値の任意の場所に安全に挿入して、行の長さの制限に適合させることができます。本文ハッシュの計算方法については、3.7節を参照してください。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-bh-tag      = %x62 %x68 [FWS] \"=\" [FWS] sig-bh-tag-data\nsig-bh-tag-data = base64string",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "c= Message canonicalization (plain-text; OPTIONAL, default is \"simple/simple\"). This tag informs the verifier of the type of canonicalization used to prepare the message for signing. It consists of two names separated by a \"slash\" (%d47) character, corresponding to the header and body canonicalization algorithms respectively. These algorithms are described in Section 3.4. If only one algorithm is named, that algorithm is used for the header and \"simple\" is used for the body. For example, \"c=relaxed\" is treated the same as \"c=relaxed/simple\".",
      "ja": "c =メッセージの正規化（プレーンテキスト;オプション、デフォルトは \"simple / simple\"）。このタグは、署名用のメッセージを準備するために使用される正規化のタイプを検証者に通知します。これは、「スラッシュ」（％d47）文字で区切られた2つの名前で構成され、ヘッダーと本文の正規化アルゴリズムにそれぞれ対応しています。これらのアルゴリズムについては、セクション3.4で説明します。 1つのアルゴリズムのみが指定されている場合、そのアルゴリズムはヘッダーに使用され、「シンプル」が本文に使用されます。たとえば、「c = relaxed」は「c = relaxed / simple」と同じように扱われます。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-c-tag       = %x63 [FWS] \"=\" [FWS] sig-c-tag-alg\n              [\"/\" sig-c-tag-alg]\nsig-c-tag-alg   = \"simple\" / \"relaxed\" / x-sig-c-tag-alg\nx-sig-c-tag-alg = hyphenated-word    ; for later extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "d= The domain of the signing entity (plain-text; REQUIRED). This is the domain that will be queried for the public key. This domain MUST be the same as or a parent domain of the \"i=\" tag (the signing identity, as described below), or it MUST meet the requirements for parent domain signing described in Section 3.8. When presented with a signature that does not meet these requirement, verifiers MUST consider the signature invalid.",
      "ja": "d =署名エンティティのドメイン（プレーンテキスト、必須）。これは、公開鍵を照会するドメインです。このドメインは、「i =」タグ（以下で説明するように、署名ID）と同じであるか、親ドメインである必要があります。または、セクション3.8で説明されている親ドメイン署名の要件を満たす必要があります。これらの要件を満たさない署名が提示された場合、検証者は署名を無効と見なさなければなりません（MUST）。"
    },
    {
      "indent": 3,
      "text": "Internationalized domain names MUST be encoded as described in [RFC3490].",
      "ja": "国際化ドメイン名は、[RFC3490]で説明されているようにエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-d-tag       = %x64 [FWS] \"=\" [FWS] domain-name\ndomain-name     = sub-domain 1*(\".\" sub-domain)\n         ; from RFC 2821 Domain, but excluding address-literal",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "h= Signed header fields (plain-text, but see description; REQUIRED). A colon-separated list of header field names that identify the header fields presented to the signing algorithm. The field MUST contain the complete list of header fields in the order presented to the signing algorithm. The field MAY contain names of header fields that do not exist when signed; nonexistent header fields do not contribute to the signature computation (that is, they are treated as the null input, including the header field name, the separating colon, the header field value, and any CRLF terminator). The field MUST NOT include the DKIM-Signature header field that is being created or verified, but may include others. Folding whitespace (FWS) MAY be included on either side of the colon separator. Header field names MUST be compared against actual header field names in a case-insensitive manner. This list MUST NOT be empty. See Section 5.4 for a discussion of choosing header fields to sign.",
      "ja": "h =署名済みヘッダーフィールド（プレーンテキストですが、説明を参照してください。必須）。署名アルゴリズムに提示されるヘッダーフィールドを識別するヘッダーフィールド名のコロンで区切られたリスト。フィールドには、署名アルゴリズムに提示された順序でヘッダーフィールドの完全なリストを含める必要があります。フィールドには、署名時に存在しないヘッダーフィールドの名前が含まれる場合があります。存在しないヘッダーフィールドは、署名の計算に寄与しません（つまり、ヘッダーフィールド名、分離コロン、ヘッダーフィールド値、およびCRLFターミネーターを含む、ヌル入力として扱われます）。このフィールドには、作成または検証中のDKIM-Signatureヘッダーフィールドを含めることはできませんが、他のフィールドを含めることはできます。折りたたみ空白（FWS）は、コロン区切り文字の両側に含めることができます（MAY）。ヘッダーフィールド名は、大文字と小文字を区別しない方法で実際のヘッダーフィールド名と比較する必要があります。このリストを空にすることはできません。署名するヘッダーフィールドの選択については、5.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-h-tag       = %x68 [FWS] \"=\" [FWS] hdr-name\n              0*( *FWS \":\" *FWS hdr-name )\nhdr-name        = field-name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "INFORMATIVE EXPLANATION: By \"signing\" header fields that do not actually exist, a signer can prevent insertion of those header fields before verification. However, since a signer cannot possibly know what header fields might be created in the future, and that some MUAs might present header fields that are embedded inside a message (e.g., as a message/rfc822 content type), the security of this solution is not total.",
      "ja": "有益な説明：実際には存在しないヘッダーフィールドに「署名」することにより、署名者は検証前にそれらのヘッダーフィールドの挿入を防ぐことができます。ただし、署名者は将来作成される可能性のあるヘッダーフィールドを知ることができず、一部のMUAがメッセージ内に埋め込まれたヘッダーフィールドを表示する可能性があるため（たとえば、メッセージ/ rfc822コンテンツタイプとして）、このソリューションのセキュリティは合計ではありません。"
    },
    {
      "indent": 7,
      "text": "INFORMATIVE EXPLANATION: The exclusion of the header field name and colon as well as the header field value for non-existent header fields prevents an attacker from inserting an actual header field with a null value.",
      "ja": "有益な説明：ヘッダーフィールド名とコロン、および存在しないヘッダーフィールドのヘッダーフィールド値を除外することで、攻撃者は実際のヘッダーフィールドにnull値を挿入できなくなります。"
    },
    {
      "indent": 3,
      "text": "i= Identity of the user or agent (e.g., a mailing list manager) on behalf of which this message is signed (dkim-quoted-printable; OPTIONAL, default is an empty Local-part followed by an \"@\" followed by the domain from the \"d=\" tag). The syntax is a standard email address where the Local-part MAY be omitted. The domain part of the address MUST be the same as or a subdomain of the value of the \"d=\" tag.",
      "ja": "i =このメッセージに署名するユーザーまたはエージェント（メーリングリストマネージャーなど）のID（dkim-quoted-printable;オプション、デフォルトは空のローカルパーツの後に「@」とドメインが続く「d =」タグから）。構文は、ローカル部分が省略される場合がある標準の電子メールアドレスです。アドレスのドメイン部分は、「d =」タグの値と同じか、そのサブドメインである必要があります。"
    },
    {
      "indent": 3,
      "text": "Internationalized domain names MUST be converted using the steps listed in Section 4 of [RFC3490] using the \"ToASCII\" function.",
      "ja": "国際化ドメイン名は、[ToASCII]関数を使用して、[RFC3490]のセクション4に記載されている手順に従って変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-i-tag =   %x69 [FWS] \"=\" [FWS] [ Local-part ] \"@\" domain-name",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "INFORMATIVE NOTE: The Local-part of the \"i=\" tag is optional because in some cases a signer may not be able to establish a verified individual identity. In such cases, the signer may wish to assert that although it is willing to go as far as signing for the domain, it is unable or unwilling to commit to an individual user name within their domain. It can do so by including the domain part but not the Local-part of the identity.",
      "ja": "有益な注意：「i =」タグのローカル部分はオプションです。これは、署名者が検証済みの個人のアイデンティティを確立できない場合があるためです。そのような場合、署名者は、ドメインへの署名までは進んでいますが、ドメイン内の個々のユーザー名にコミットすることはできない、または望まないことを主張したい場合があります。 IDのドメイン部分は含めるがローカル部分は含めないことで可能になります。"
    },
    {
      "indent": 7,
      "text": "INFORMATIVE DISCUSSION: This document does not require the value of the \"i=\" tag to match the identity in any message header fields. This is considered to be a verifier policy issue. Constraints between the value of the \"i=\" tag and other identities in other header fields seek to apply basic authentication into the semantics of trust associated with a role such as content author. Trust is a broad and complex topic and trust mechanisms are subject to highly creative attacks. The real-world efficacy of any but the most basic bindings between the \"i=\" value and other identities is not well established, nor is its vulnerability to subversion by an attacker. Hence reliance on the use of these options should be strictly limited. In particular, it is not at all clear to what extent a typical end-user recipient can rely on any assurances that might be made by successful use of the \"i=\" options.",
      "ja": "有益なディスカッション：このドキュメントでは、「i =」タグの値がメッセージヘッダーフィールドのIDと一致する必要はありません。これは検証者ポリシーの問題と見なされます。 「i =」タグの値と他のヘッダーフィールドの他のIDの間の制約は、コンテンツ作成者などのロールに関連付けられた信頼のセマンティクスに基本認証を適用しようとします。信頼は広く複雑なトピックであり、信頼メカニズムは非常に独創的な攻撃の影響を受けます。 「i =」値と他のIDの間の最も基本的なバインディング以外の実際の有効性は十分に確立されておらず、攻撃者による転覆に対する脆弱性もありません。したがって、これらのオプションの使用への依存は厳しく制限されるべきです。特に、典型的なエンドユーザーの受信者が「i =」オプションの使用が成功することによって行われる可能性がある保証にどの程度依存できるかは、まったく明確ではありません。"
    },
    {
      "indent": 3,
      "text": "l= Body length count (plain-text unsigned decimal integer; OPTIONAL, default is entire body). This tag informs the verifier of the number of octets in the body of the email after canonicalization included in the cryptographic hash, starting from 0 immediately following the CRLF preceding the body. This value MUST NOT be larger than the actual number of octets in the canonicalized message body.",
      "ja": "l =本文の長さのカウント（プレーンテキストの符号なし10進整数。オプション、デフォルトは本文全体）。このタグは、暗号化ハッシュに含まれる正規化後のメール本文のオクテット数を検証者に通知します。本文の前のCRLFの直後の0から始まります。この値は、正規化されたメッセージ本文の実際のオクテット数を超えてはなりません（MUST NOT）。"
    },
    {
      "indent": 7,
      "text": "INFORMATIVE IMPLEMENTATION WARNING: Use of the \"l=\" tag might allow display of fraudulent content without appropriate warning to end users. The \"l=\" tag is intended for increasing signature robustness when sending to mailing lists that both modify their content and do not sign their messages. However, using the \"l=\" tag enables attacks in which an intermediary with malicious intent modifies a message to include content that solely benefits the attacker. It is possible for the appended content to completely replace the original content in the end recipient's eyes and to defeat duplicate message detection algorithms. Examples are described in Security Considerations (Section 8). To avoid this attack, signers should be extremely wary of using this tag, and verifiers might wish to ignore the tag or remove text that appears after the specified content length.",
      "ja": "有益な実装に関する警告：「l =」タグを使用すると、エンドユーザーへの適切な警告なしに不正なコンテンツが表示される可能性があります。 「l =」タグは、コンテンツを変更し、メッセージに署名しないメーリングリストに送信するときに、署名の堅牢性を高めることを目的としています。ただし、「l =」タグを使用すると、悪意のある仲介者がメッセージを変更して、攻撃者にのみ利益をもたらすコンテンツを含める攻撃が可能になります。追加されたコンテンツが、最終受信者の目で元のコンテンツを完全に置き換え、重複メッセージ検出アルゴリズムを無効にする可能性があります。例については、セキュリティの考慮事項（セクション8）で説明しています。この攻撃を回避するには、署名者はこのタグの使用に非常に注意する必要があり、検証者はタグを無視するか、指定されたコンテンツの長さの後に表示されるテキストを削除する必要があります。"
    },
    {
      "indent": 7,
      "text": "INFORMATIVE NOTE: The value of the \"l=\" tag is constrained to 76 decimal digits. This constraint is not intended to predict the size of future messages or to require implementations to use an integer representation large enough to represent the maximum possible value, but is intended to remind the implementer to check the length of this and all other tags during verification and to test for integer overflow when decoding the value. Implementers may need to limit the actual value expressed to a value smaller than 10^76, e.g., to allow a message to fit within the available storage space.",
      "ja": "有益な注意：「l =」タグの値は、76桁の10進数に制限されています。この制約は、将来のメッセージのサイズを予測したり、可能な最大値を表すのに十分な大きさの整数表現を使用するように実装に要求したりすることを意図していませんが、検証中にこのタグと他のすべてのタグの長さをチェックするよう実装者に思い出させることを意図しています値をデコードするときに整数オーバーフローをテストします。実装者は、たとえば、メッセージが使用可能なストレージ領域内に収まるように、表現される実際の値を10 ^ 76未満の値に制限する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 3,
      "text": "sig-l-tag    = %x6c [FWS] \"=\" [FWS] 1*76DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "q= A colon-separated list of query methods used to retrieve the public key (plain-text; OPTIONAL, default is \"dns/txt\"). Each query method is of the form \"type[/options]\", where the syntax and semantics of the options depend on the type and specified options. If there are multiple query mechanisms listed, the choice of query mechanism MUST NOT change the interpretation of the signature. Implementations MUST use the recognized query mechanisms in the order presented.",
      "ja": "q =公開鍵の取得に使用されるクエリメソッドのコロンで区切られたリスト（プレーンテキスト、オプション、デフォルトは \"dns / txt\"）。各クエリメソッドの形式は \"type [/ options]\"で、オプションの構文とセマンティクスは、タイプと指定したオプションによって異なります。複数のクエリメカニズムがリストされている場合、クエリメカニズムの選択は、署名の解釈を変更してはなりません。実装は、提示された順序で認識されたクエリメカニズムを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Currently, the only valid value is \"dns/txt\", which defines the DNS TXT record lookup algorithm described elsewhere in this document. The only option defined for the \"dns\" query type is \"txt\", which MUST be included. Verifiers and signers MUST support \"dns/txt\".",
      "ja": "現在、有効な値は「dns / txt」だけです。これは、このドキュメントの他の場所で説明されているDNS TXTレコードルックアップアルゴリズムを定義します。 「dns」クエリタイプに定義されている唯一のオプションは「txt」であり、これを含める必要があります。検証者と署名者は「dns / txt」をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-q-tag        = %x71 [FWS] \"=\" [FWS] sig-q-tag-method\n               *([FWS] \":\" [FWS] sig-q-tag-method)\nsig-q-tag-method = \"dns/txt\" / x-sig-q-tag-type\n               [\"/\" x-sig-q-tag-args]\nx-sig-q-tag-type = hyphenated-word  ; for future extension\nx-sig-q-tag-args = qp-hdr-value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "s= The selector subdividing the namespace for the \"d=\" (domain) tag (plain-text; REQUIRED).",
      "ja": "s = \"d =\"（ドメイン）タグの名前空間を細分するセレクター（プレーンテキスト;必須）。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-s-tag    = %x73 [FWS] \"=\" [FWS] selector",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "t= Signature Timestamp (plain-text unsigned decimal integer; RECOMMENDED, default is an unknown creation time). The time that this signature was created. The format is the number of seconds since 00:00:00 on January 1, 1970 in the UTC time zone. The value is expressed as an unsigned integer in decimal ASCII. This value is not constrained to fit into a 31- or 32-bit integer. Implementations SHOULD be prepared to handle values up to at least 10^12 (until approximately AD 200,000; this fits into 40 bits). To avoid denial-of-service attacks, implementations MAY consider any value longer than 12 digits to be infinite. Leap seconds are not counted. Implementations MAY ignore signatures that have a timestamp in the future.",
      "ja": "t =署名のタイムスタンプ（プレーンテキストの符号なし10進整数。推奨、デフォルトは不明な作成時間）。この署名が作成された時刻。形式は、UTCタイムゾーンでの1970年1月1日00:00:00からの秒数です。値は、10進数のASCIIの符号なし整数として表されます。この値は、31ビットまたは32ビット整数に収まるように制限されていません。実装は、少なくとも10 ^ 12までの値を処理できるように準備する必要があります（およそAD 200,000まで。これは40ビットに適合します）。サービス拒否攻撃を回避するために、実装では、12桁を超える値は無限であると見なすことができます（MAY）。うるう秒はカウントされません。実装は、将来のタイムスタンプを持つ署名を無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-t-tag    = %x74 [FWS] \"=\" [FWS] 1*12DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "x= Signature Expiration (plain-text unsigned decimal integer; RECOMMENDED, default is no expiration). The format is the same as in the \"t=\" tag, represented as an absolute date, not as a time delta from the signing timestamp. The value is expressed as an unsigned integer in decimal ASCII, with the same constraints on the value in the \"t=\" tag. Signatures MAY be considered invalid if the verification time at the verifier is past the expiration date. The verification time should be the time that the message was first received at the administrative domain of the verifier if that time is reliably available; otherwise the current time should be used. The value of the \"x=\" tag MUST be greater than the value of the \"t=\" tag if both are present.",
      "ja": "x =署名の有効期限（プレーンテキストの符号なし10進整数。推奨、デフォルトは有効期限なし）。形式は「t =」タグと同じで、署名タイムスタンプからの時間デルタではなく、絶対日付として表されます。値は、10進数のASCIIの符号なし整数として表され、「t =」タグの値に同じ制約があります。検証者での検証時間が有効期限を過ぎている場合、署名は無効と見なされる場合があります。検証時刻は、その時刻が確実に利用できる場合、検証者の管理ドメインでメッセージが最初に受信された時刻でなければなりません。それ以外の場合は、現在の時刻を使用する必要があります。両方が存在する場合、「x =」タグの値は「t =」タグの値よりも大きい必要があります。"
    },
    {
      "indent": 7,
      "text": "INFORMATIVE NOTE: The \"x=\" tag is not intended as an anti-replay defense.",
      "ja": "有益な注意：「x =」タグは、アンチリプレイ防御を目的としたものではありません。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "sig-x-tag    = %x78 [FWS] \"=\" [FWS] 1*12DIGIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "z=  Copied header fields (dkim-quoted-printable, but see description;\n    OPTIONAL, default is null).  A vertical-bar-separated list of\n    selected header fields present when the message was signed,\n    including both the field name and value.  It is not required to\n    include all header fields present at the time of signing.  This\n    field need not contain the same header fields listed in the \"h=\"\n    tag.  The header field text itself must encode the vertical bar\n    (\"|\", %x7C) character (i.e., vertical bars in the \"z=\" text are\n    metacharacters, and any actual vertical bar characters in a\n    copied header field must be encoded).  Note that all whitespace\n    must be encoded, including whitespace between the colon and the\n    header field value.  After encoding, FWS MAY be added at\n    arbitrary locations in order to avoid excessively long lines;\n    such whitespace is NOT part of the value of the header field, and\n    MUST be removed before decoding.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The header fields referenced by the \"h=\" tag refer to the fields in the RFC 2822 header of the message, not to any copied fields in the \"z=\" tag. Copied header field values are for diagnostic use.",
      "ja": "「h =」タグによって参照されるヘッダーフィールドは、「z =」タグ内のコピーされたフィールドではなく、メッセージのRFC 2822ヘッダー内のフィールドを参照します。コピーされたヘッダーフィールド値は診断用です。"
    },
    {
      "indent": 3,
      "text": "Header fields with characters requiring conversion (perhaps from legacy MTAs that are not [RFC2822] compliant) SHOULD be converted as described in MIME Part Three [RFC2047].",
      "ja": "変換が必要な文字を含むヘッダーフィールド（おそらく[RFC2822]に準拠していないレガシーMTAからのもの）は、MIMEパート3 [RFC2047]で説明されているように変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:\n    sig-z-tag      = %x7A [FWS] \"=\" [FWS] sig-z-tag-copy\n                 *( [FWS] \"|\" sig-z-tag-copy )\nsig-z-tag-copy = hdr-name \":\" qp-hdr-value\nqp-hdr-value   = dkim-quoted-printable    ; with \"|\" encoded",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE of a signature header field spread across multiple continuation lines:",
      "ja": "複数の継続行にまたがる署名ヘッダーフィールドの有益な例："
    },
    {
      "indent": 3,
      "text": "DKIM-Signature: a=rsa-sha256; d=example.net; s=brisbane;\n   c=simple; q=dns/txt; i=@eng.example.net;\n   t=1117574938; x=1118006938;\n   h=from:to:subject:date;\n   z=From:foo@eng.example.net|To:joe@example.com|\n     Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;\n   bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;\n   b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ\n            VoG4ZHRNiYzR",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.6. Key Management and Representation",
      "section_title": true,
      "ja": "3.6. キーの管理と表現"
    },
    {
      "indent": 3,
      "text": "Signature applications require some level of assurance that the verification public key is associated with the claimed signer. Many applications achieve this by using public key certificates issued by a trusted third party. However, DKIM can achieve a sufficient level of security, with significantly enhanced scalability, by simply having the verifier query the purported signer's DNS entry (or some security-equivalent) in order to retrieve the public key.",
      "ja": "署名アプリケーションでは、検証公開鍵が要求された署名者に関連付けられていることをある程度保証する必要があります。多くのアプリケーションは、信頼できるサードパーティが発行した公開鍵証明書を使用してこれを実現しています。ただし、DKIMは、公開鍵を取得するために検証者に署名者のDNSエントリ（または同等のセキュリティ）にクエリを送信させるだけで、スケーラビリティが大幅に向上し、十分なレベルのセキュリティを実現できます。"
    },
    {
      "indent": 3,
      "text": "DKIM keys can potentially be stored in multiple types of key servers and in multiple formats. The storage and format of keys are irrelevant to the remainder of the DKIM algorithm.",
      "ja": "DKIM鍵は、複数のタイプの鍵サーバーおよび複数の形式で格納される可能性があります。キーの保存と形式は、DKIMアルゴリズムの残りの部分には関係ありません。"
    },
    {
      "indent": 3,
      "text": "Parameters to the key lookup algorithm are the type of the lookup (the \"q=\" tag), the domain of the signer (the \"d=\" tag of the DKIM-Signature header field), and the selector (the \"s=\" tag).",
      "ja": "キールックアップアルゴリズムのパラメーターは、ルックアップのタイプ（ \"q =\"タグ）、署名者のドメイン（DKIM-Signatureヘッダーフィールドの \"d =\"タグ）、およびセレクター（ \"s =\" \" 鬼ごっこ）。"
    },
    {
      "indent": 7,
      "text": "public_key = dkim_find_key(q_val, d_val, s_val)",
      "ja": "public_key = dkim_find_key（q_val、d_val、s_val）"
    },
    {
      "indent": 3,
      "text": "This document defines a single binding, using DNS TXT records to distribute the keys. Other bindings may be defined in the future.",
      "ja": "このドキュメントでは、DNS TXTレコードを使用してキーを配布する単一のバインディングを定義しています。他のバインディングは将来定義されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Textual Representation",
      "section_title": true,
      "ja": "3.6.1. テキスト表現"
    },
    {
      "indent": 3,
      "text": "It is expected that many key servers will choose to present the keys in an otherwise unstructured text format (for example, an XML form would not be considered to be unstructured text for this purpose). The following definition MUST be used for any DKIM key represented in an otherwise unstructured textual form.",
      "ja": "多くのキーサーバーは、キーを他の点では非構造化テキスト形式で提示することを選択することが予想されます（たとえば、XMLフォームは、この目的では非構造化テキストとは見なされません）。次の定義は、その他の構造化されていないテキスト形式で表されるDKIMキーに使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The overall syntax is a tag-list as described in Section 3.2. The current valid tags are described below. Other tags MAY be present and MUST be ignored by any implementation that does not understand them.",
      "ja": "全体的な構文は、セクション3.2で説明されているタグリストです。現在有効なタグは以下のとおりです。他のタグが存在してもよいし、それらを理解しない実装では無視されなければならない（MUST）。"
    },
    {
      "indent": 3,
      "text": "v= Version of the DKIM key record (plain-text; RECOMMENDED, default is \"DKIM1\"). If specified, this tag MUST be set to \"DKIM1\" (without the quotes). This tag MUST be the first tag in the record. Records beginning with a \"v=\" tag with any other value MUST be discarded. Note that verifiers must do a string comparison on this value; for example, \"DKIM1\" is not the same as \"DKIM1.0\".",
      "ja": "v = DKIM鍵レコードのバージョン（プレーンテキスト、推奨、デフォルトは「DKIM1」）。指定する場合、このタグは \"DKIM1\"（引用符なし）に設定する必要があります。このタグは、レコードの最初のタグでなければなりません。 「v =」タグで始まり、他の値を持つレコードは破棄する必要があります。検証者はこの値に対して文字列比較を行う必要があることに注意してください。たとえば、「DKIM1」は「DKIM1.0」と同じではありません。"
    },
    {
      "indent": 7,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-v-tag    = %x76 [FWS] \"=\" [FWS] \"DKIM1\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "g= Granularity of the key (plain-text; OPTIONAL, default is \"*\"). This value MUST match the Local-part of the \"i=\" tag of the DKIM-Signature header field (or its default value of the empty string if \"i=\" is not specified), with a single, optional \"*\" character matching a sequence of zero or more arbitrary characters (\"wildcarding\"). An email with a signing address that does not match the value of this tag constitutes a failed verification. The intent of this tag is to constrain which signing address can legitimately use this selector, for example, when delegating a key to a third party that should only be used for special purposes. Wildcarding allows matching for addresses such as \"user+*\" or \"*-offer\". An empty \"g=\" value never matches any addresses.",
      "ja": "g =キーの細分性（プレーンテキスト;オプション、デフォルトは \"*\"）。この値は、DKIM-Signatureヘッダーフィールドの「i =」タグのLocal-part（または「i =」が指定されていない場合は空の文字列のデフォルト値）と単一のオプションの「*」文字で一致する必要があります。 0個以上の任意の文字のシーケンスに一致します（「ワイルドカード」）。このタグの値と一致しない署名アドレスを含むメールは、検証に失敗したことになります。このタグの目的は、たとえば、特別な目的にのみ使用する必要がある第三者にキーを委任する場合に、どの署名アドレスがこのセレクタを正当に使用できるかを制限することです。ワイルドカードを使用すると、「user + *」や「* -offer」などのアドレスを照合できます。空の \"g =\"値は、どのアドレスとも一致しません。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-g-tag       = %x67 [FWS] \"=\" [FWS] key-g-tag-lpart\nkey-g-tag-lpart = [dot-atom-text] [\"*\" [dot-atom-text] ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "h= Acceptable hash algorithms (plain-text; OPTIONAL, defaults to allowing all algorithms). A colon-separated list of hash algorithms that might be used. Signers and Verifiers MUST support the \"sha256\" hash algorithm. Verifiers MUST also support the \"sha1\" hash algorithm.",
      "ja": "h =許容可能なハッシュアルゴリズム（プレーンテキスト、オプション、デフォルトですべてのアルゴリズムを許可）。コロンで区切られた、使用される可能性のあるハッシュアルゴリズムのリスト。署名者と検証者は、「sha256」ハッシュアルゴリズムをサポートする必要があります。検証者は、「sha1」ハッシュアルゴリズムもサポートする必要があります。"
    },
    {
      "indent": 7,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-h-tag       = %x68 [FWS] \"=\" [FWS] key-h-tag-alg\n              0*( [FWS] \":\" [FWS] key-h-tag-alg )\nkey-h-tag-alg   = \"sha1\" / \"sha256\" / x-key-h-tag-alg\nx-key-h-tag-alg = hyphenated-word   ; for future extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "k= Key type (plain-text; OPTIONAL, default is \"rsa\"). Signers and verifiers MUST support the \"rsa\" key type. The \"rsa\" key type indicates that an ASN.1 DER-encoded [ITU.X660.1997] RSAPublicKey [RFC3447] (see Sections 3.1 and A.1.1) is being used in the \"p=\" tag. (Note: the \"p=\" tag further encodes the value using the base64 algorithm.)",
      "ja": "k =鍵のタイプ（プレーンテキスト、オプション、デフォルトは \"rsa\"）。署名者と検証者は、「rsa」キータイプをサポートする必要があります。 「rsa」キータイプは、ASN.1 DERエンコード[ITU.X660.1997] RSAPublicKey [RFC3447]（セクション3.1およびA.1.1を参照）が「p =」タグで使用されていることを示します。 （注： \"p =\"タグは、base64アルゴリズムを使用して値をさらにエンコードします。）"
    },
    {
      "indent": 7,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-k-tag        = %x76 [FWS] \"=\" [FWS] key-k-tag-type\nkey-k-tag-type   = \"rsa\" / x-key-k-tag-type\nx-key-k-tag-type = hyphenated-word   ; for future extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "n= Notes that might be of interest to a human (qp-section; OPTIONAL, default is empty). No interpretation is made by any program. This tag should be used sparingly in any key server mechanism that has space limitations (notably DNS). This is intended for use by administrators, not end users.",
      "ja": "n =人間が関心を持つ可能性のあるメモ（qp-section;オプション、デフォルトは空）。どのプログラムでも解釈は行われません。このタグは、スペースが制限されているキーサーバーメカニズム（特にDNS）で控えめに使用する必要があります。これは、エンドユーザーではなく、管理者による使用を目的としています。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-n-tag    = %x6e [FWS] \"=\" [FWS] qp-section",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "p= Public-key data (base64; REQUIRED). An empty value means that this public key has been revoked. The syntax and semantics of this tag value before being encoded in base64 are defined by the \"k=\" tag.",
      "ja": "p =公開鍵データ（base64;必須）。空の値は、この公開鍵が取り消されたことを意味します。 base64でエンコードされる前のこのタグ値の構文とセマンティクスは、「k =」タグによって定義されます。"
    },
    {
      "indent": 11,
      "text": "INFORMATIVE RATIONALE: If a private key has been compromised or otherwise disabled (e.g., an outsourcing contract has been terminated), a signer might want to explicitly state that it knows about the selector, but all messages using that selector should fail verification. Verifiers should ignore any DKIM-Signature header fields with a selector referencing a revoked key.",
      "ja": "有益な根拠：秘密鍵が危険にさらされているか、無効になっている場合（たとえば、アウトソーシング契約が終了している場合）、署名者はセレクタについて知っていることを明示的に述べたいかもしれませんが、そのセレクタを使用するすべてのメッセージは検証に失敗するはずです。検証者は、取り消されたキーを参照するセレクターがあるDKIM-Signatureヘッダーフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-p-tag    = %x70 [FWS] \"=\" [ [FWS] base64string ]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "INFORMATIVE NOTE: A base64string is permitted to include white space (FWS) at arbitrary places; however, any CRLFs must be followed by at least one WSP character. Implementors and administrators are cautioned to ensure that selector TXT records conform to this specification.",
      "ja": "有益な注意：base64stringは、任意の場所に空白（FWS）を含めることが許可されています。ただし、CRLFの後には少なくとも1つのWSP文字が続く必要があります。実装者と管理者は、セレクターTXTレコードがこの仕様に確実に準拠するように警告されます。"
    },
    {
      "indent": 3,
      "text": "s= Service Type (plain-text; OPTIONAL; default is \"*\"). A colon-separated list of service types to which this record applies. Verifiers for a given service type MUST ignore this record if the appropriate type is not listed. Currently defined service types are as follows:",
      "ja": "s =サービスタイプ（プレーンテキスト、オプション、デフォルトは「*」）。このレコードが適用される、コロンで区切られたサービスタイプのリスト。適切なタイプがリストされていない場合、特定のサービスタイプのベリファイアはこのレコードを無視する必要があります。現在定義されているサービスタイプは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "* matches all service types",
      "ja": "* すべてのサービスタイプに一致"
    },
    {
      "indent": 7,
      "text": "email electronic mail (not necessarily limited to SMTP)",
      "ja": "電子メール電子メール（必ずしもSMTPに限定されない）"
    },
    {
      "indent": 7,
      "text": "This tag is intended to constrain the use of keys for other purposes, should use of DKIM be defined by other services in the future.",
      "ja": "このタグは、他の目的でのキーの使用を制限することを目的としています。将来、DKIMの使用が他のサービスによって定義される場合に備えてください。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-s-tag        = %x73 [FWS] \"=\" [FWS] key-s-tag-type\n                0*( [FWS] \":\" [FWS] key-s-tag-type )\nkey-s-tag-type   = \"email\" / \"*\" / x-key-s-tag-type\nx-key-s-tag-type = hyphenated-word   ; for future extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "t= Flags, represented as a colon-separated list of names (plain-text; OPTIONAL, default is no flags set). The defined flags are as follows:",
      "ja": "t =フラグ。コロンで区切られた名前のリストとして表されます（プレーンテキスト、オプション、デフォルトではフラグは設定されていません）。定義されているフラグは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "y This domain is testing DKIM. Verifiers MUST NOT treat messages from signers in testing mode differently from unsigned email, even should the signature fail to verify. Verifiers MAY wish to track testing mode results to assist the signer.",
      "ja": "yこのドメインはDKIMをテストしています。検証者は、署名の検証に失敗した場合でも、テストモードの署名者からのメッセージを未署名の電子メールと異なる方法で処理してはなりません（MUST NOT）。検証者は、署名者を支援するためにテストモードの結果を追跡したいと思うかもしれません。"
    },
    {
      "indent": 7,
      "text": "s Any DKIM-Signature header fields using the \"i=\" tag MUST have the same domain value on the right-hand side of the \"@\" in the \"i=\" tag and the value of the \"d=\" tag. That is, the \"i=\" domain MUST NOT be a subdomain of \"d=\". Use of this flag is RECOMMENDED unless subdomaining is required.",
      "ja": "■「i =」タグを使用するすべてのDKIM-Signatureヘッダーフィールドには、「i =」タグの「@」の右側のドメイン値と「d =」タグの値が同じである必要があります。つまり、「i =」ドメインは「d =」のサブドメインであってはなりません。このフラグの使用は、サブドメイン化が必要でない限り推奨されます。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 7,
      "text": "key-t-tag        = %x74 [FWS] \"=\" [FWS] key-t-tag-flag\n               0*( [FWS] \":\" [FWS] key-t-tag-flag )\nkey-t-tag-flag   = \"y\" / \"s\" / x-key-t-tag-flag\nx-key-t-tag-flag = hyphenated-word   ; for future extension",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Unrecognized flags MUST be ignored.",
      "ja": "認識されないフラグは無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.2. DNS Binding",
      "section_title": true,
      "ja": "3.6.2. DNSバインディング"
    },
    {
      "indent": 3,
      "text": "A binding using DNS TXT records as a key service is hereby defined. All implementations MUST support this binding.",
      "ja": "これにより、DNS TXTレコードをキーサービスとして使用するバインディングが定義されます。すべての実装はこのバインディングをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.2.1. Namespace",
      "section_title": true,
      "ja": "3.6.2.1. 名前空間"
    },
    {
      "indent": 3,
      "text": "All DKIM keys are stored in a subdomain named \"_domainkey\". Given a DKIM-Signature field with a \"d=\" tag of \"example.com\" and an \"s=\" tag of \"foo.bar\", the DNS query will be for \"foo.bar._domainkey.example.com\".",
      "ja": "すべてのDKIMキーは、「_ domainkey」という名前のサブドメインに保存されます。 「example = com」の「d =」タグと「foo.bar」の「s =」タグのあるDKIM-Signatureフィールドを指定すると、DNSクエリは「foo.bar._domainkey.example.com」に対するものになります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONAL NOTE: Wildcard DNS records (e.g., *.bar._domainkey.example.com) do not make sense in this context and should not be used. Note also that wildcards within domains (e.g., s._domainkey.*.example.com) are not supported by the DNS.",
      "ja": "有益な操作上の注意：ワイルドカードDNSレコード（* .bar._domainkey.example.comなど）は、このコンテキストでは意味がなく、使用しないでください。ドメイン内のワイルドカード（s._domainkey。*。example.comなど）はDNSでサポートされていないことにも注意してください。"
    },
    {
      "indent": 0,
      "text": "3.6.2.2. Resource Record Types for Key Storage",
      "section_title": true,
      "ja": "3.6.2.2. キーストレージのリソースレコードタイプ"
    },
    {
      "indent": 3,
      "text": "The DNS Resource Record type used is specified by an option to the query-type (\"q=\") tag. The only option defined in this base specification is \"txt\", indicating the use of a TXT Resource Record (RR). A later extension of this standard may define another RR type.",
      "ja": "使用されるDNSリソースレコードタイプは、query-type（ \"q =\"）タグへのオプションによって指定されます。この基本仕様で定義されている唯一のオプションは、TXTリソースレコード（RR）の使用を示す「txt」です。この標準の今後の拡張により、別のRRタイプが定義される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Strings in a TXT RR MUST be concatenated together before use with no intervening whitespace. TXT RRs MUST be unique for a particular selector name; that is, if there are multiple records in an RRset, the results are undefined.",
      "ja": "TXT RRの文字列は、間に空白を入れずに使用する前に連結する必要があります。 TXT RRは、特定のセレクター名に対して一意である必要があります。つまり、RRsetに複数のレコードがある場合、結果は未定義です。"
    },
    {
      "indent": 3,
      "text": "TXT RRs are encoded as described in Section 3.6.1.",
      "ja": "TXT RRはセクション3.6.1で説明されているようにエンコードされます。"
    },
    {
      "indent": 0,
      "text": "3.7. Computing the Message Hashes",
      "section_title": true,
      "ja": "3.7. メッセージハッシュの計算"
    },
    {
      "indent": 3,
      "text": "Both signing and verifying message signatures start with a step of computing two cryptographic hashes over the message. Signers will choose the parameters of the signature as described in Signer Actions (Section 5); verifiers will use the parameters specified in the DKIM-Signature header field being verified. In the following discussion, the names of the tags in the DKIM-Signature header field that either exists (when verifying) or will be created (when signing) are used. Note that canonicalization (Section 3.4) is only used to prepare the email for signing or verifying; it does not affect the transmitted email in any way.",
      "ja": "メッセージの署名と検証の両方が、メッセージに対する2つの暗号化ハッシュを計算するステップから始まります。署名者は、署名者のアクション（セクション5）で説明されているように、署名のパラメーターを選択します。検証者は、検証されるDKIM-Signatureヘッダーフィールドで指定されたパラメーターを使用します。以下の説明では、DKIM-Signatureヘッダーフィールドのタグの名前が存在します（検証時）または作成される（署名時）のいずれかです。正規化（セクション3.4）は、署名または検証のために電子メールを準備するためにのみ使用されることに注意してください。送信される電子メールには影響しません。"
    },
    {
      "indent": 3,
      "text": "The signer/verifier MUST compute two hashes, one over the body of the message and one over the selected header fields of the message.",
      "ja": "署名者/検証者は、メッセージの本文とメッセージの選択されたヘッダーフィールドの2つのハッシュを計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "Signers MUST compute them in the order shown. Verifiers MAY compute them in any order convenient to the verifier, provided that the result is semantically identical to the semantics that would be the case had they been computed in this order.",
      "ja": "署名者は、示されている順序でそれらを計算する必要があります。ベリファイアは、結果がこの順序で計算された場合の意味論と意味的に同じであれば、ベリファイアにとって都合のよい任意の順序でそれらを計算できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "In hash step 1, the signer/verifier MUST hash the message body, canonicalized using the body canonicalization algorithm specified in the \"c=\" tag and then truncated to the length specified in the \"l=\" tag. That hash value is then converted to base64 form and inserted into (signers) or compared to (verifiers) the \"bh=\" tag of the DKIM-Signature header field.",
      "ja": "ハッシュステップ1で、署名者/検証者はメッセージ本文をハッシュし、「c =」タグで指定された本文正規化アルゴリズムを使用して正規化し、「l =」タグで指定された長さに切り捨てる必要があります。次に、そのハッシュ値はbase64形式に変換され、DKIM-Signatureヘッダーフィールドの「bh =」タグに挿入（署名者）または比較（検証）されます。"
    },
    {
      "indent": 3,
      "text": "In hash step 2, the signer/verifier MUST pass the following to the hash algorithm in the indicated order.",
      "ja": "ハッシュステップ2では、署名者/検証者は、以下をハッシュアルゴリズムに指定された順序で渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "1. The header fields specified by the \"h=\" tag, in the order specified in that tag, and canonicalized using the header canonicalization algorithm specified in the \"c=\" tag. Each header field MUST be terminated with a single CRLF.",
      "ja": "1. 「h =」タグで指定されたヘッダーフィールドは、そのタグで指定された順序で、「c =」タグで指定されたヘッダー正規化アルゴリズムを使用して正規化されます。各ヘッダーフィールドは、単一のCRLFで終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The DKIM-Signature header field that exists (verifying) or will be inserted (signing) in the message, with the value of the \"b=\" tag deleted (i.e., treated as the empty string), canonicalized using the header canonicalization algorithm specified in the \"c=\" tag, and without a trailing CRLF.",
      "ja": "2. 指定されたヘッダー正規化アルゴリズムを使用して正規化された「b =」タグの値が削除された（つまり、空の文字列として扱われた）メッセージに存在する（検証）または挿入される（署名）DKIM-Signatureヘッダーフィールド「c =」タグ内、および末尾CRLFなし。"
    },
    {
      "indent": 3,
      "text": "All tags and their values in the DKIM-Signature header field are included in the cryptographic hash with the sole exception of the value portion of the \"b=\" (signature) tag, which MUST be treated as the null string. All tags MUST be included even if they might not be understood by the verifier. The header field MUST be presented to the hash algorithm after the body of the message rather than with the rest of the header fields and MUST be canonicalized as specified in the \"c=\" (canonicalization) tag. The DKIM-Signature header field MUST NOT be included in its own h= tag, although other DKIM-Signature header fields MAY be signed (see Section 4).",
      "ja": "DKIM-Signatureヘッダーフィールド内のすべてのタグとその値は、 \"b =\"（署名）タグの値の部分を除いて暗号化ハッシュに含まれます。これは、null文字列として扱われる必要があります。すべてのタグは、検証者が理解できない場合でも含める必要があります。ヘッダーフィールドは、残りのヘッダーフィールドではなく、メッセージの本文の後にハッシュアルゴリズムに提示する必要があり、 \"c =\"（正規化）タグで指定されているように正規化する必要があります。 DKIM-Signatureヘッダーフィールドは、それ自体のh =タグに含めることはできませんが、他のDKIM-Signatureヘッダーフィールドは署名される場合があります（セクション4を参照）。"
    },
    {
      "indent": 3,
      "text": "When calculating the hash on messages that will be transmitted using base64 or quoted-printable encoding, signers MUST compute the hash after the encoding. Likewise, the verifier MUST incorporate the values into the hash before decoding the base64 or quoted-printable text. However, the hash MUST be computed before transport level encodings such as SMTP \"dot-stuffing\" (the modification of lines beginning with a \".\" to avoid confusion with the SMTP end-of-message marker, as specified in [RFC2821]).",
      "ja": "base64またはquoted-printableエンコードを使用して送信されるメッセージのハッシュを計算する場合、署名者はエンコード後にハッシュを計算する必要があります。同様に、検証者は、base64またはquoted-printableテキストをデコードする前に、値をハッシュに組み込む必要があります。ただし、ハッシュは、SMTPの「ドット詰め」などのトランスポートレベルのエンコーディングの前に計算する必要があります（[RFC2821]で指定されているように、SMTPのメッセージ終了マーカーとの混同を避けるため、「。」で始まる行の変更）。 。"
    },
    {
      "indent": 3,
      "text": "With the exception of the canonicalization procedure described in Section 3.4, the DKIM signing process treats the body of messages as",
      "ja": "セクション3.4で説明されている正規化手順を除いて、DKIM署名プロセスはメッセージの本文を次のように扱います。"
    },
    {
      "indent": 3,
      "text": "simply a string of octets. DKIM messages MAY be either in plain-text or in MIME format; no special treatment is afforded to MIME content. Message attachments in MIME format MUST be included in the content that is signed.",
      "ja": "単にオクテットの文字列。 DKIMメッセージは、プレーンテキストまたはMIME形式のいずれかである場合があります。 MIMEコンテンツには特別な扱いはありません。署名されるコンテンツには、MIME形式のメッセージ添付ファイルを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "More formally, the algorithm for the signature is as follows:\n    body-hash = hash-alg(canon_body)\n    header-hash = hash-alg(canon_header || DKIM-SIG)\n    signature = sig-alg(header-hash, key)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where \"sig-alg\" is the signature algorithm specified by the \"a=\" tag, \"hash-alg\" is the hash algorithm specified by the \"a=\" tag, \"canon_header\" and \"canon_body\" are the canonicalized message header and body (respectively) as defined in Section 3.4 (excluding the DKIM-Signature header field), and \"DKIM-SIG\" is the canonicalized DKIM-Signature header field sans the signature value itself, but with \"body-hash\" included as the \"bh=\" tag.",
      "ja": "ここで、「sig-alg」は「a =」タグで指定された署名アルゴリズム、「hash-alg」は「a =」タグで指定されたハッシュアルゴリズム、「canon_header」と「canon_body」は正規化されたメッセージヘッダーと（それぞれ）セクション3.4で定義されているように（DKIM-Signatureヘッダーフィールドを除く）、「DKIM-SIG」は正規化されたDKIM-Signatureヘッダーフィールドであり、署名値自体はsansですが、「body-hash」が「 bh = \"タグ。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTERS' NOTE: Many digital signature APIs provide both hashing and application of the RSA private key using a single \"sign()\" primitive. When using such an API, the last two steps in the algorithm would probably be combined into a single call that would perform both the \"hash-alg\" and the \"sig-alg\".",
      "ja": "有益な実装者注：多くのデジタル署名APIは、単一の「sign()」プリミティブを使用して、RSA秘密鍵のハッシュとアプリケーションの両方を提供します。このようなAPIを使用する場合、アルゴリズムの最後の2つのステップはおそらく「ハッシュ-alg」と「sig-alg」の両方を実行する単一の呼び出しに結合されます。"
    },
    {
      "indent": 0,
      "text": "3.8. Signing by Parent Domains",
      "section_title": true,
      "ja": "3.8. 親ドメインによる署名"
    },
    {
      "indent": 3,
      "text": "In some circumstances, it is desirable for a domain to apply a signature on behalf of any of its subdomains without the need to maintain separate selectors (key records) in each subdomain. By default, private keys corresponding to key records can be used to sign messages for any subdomain of the domain in which they reside; e.g., a key record for the domain example.com can be used to verify messages where the signing identity (\"i=\" tag of the signature) is sub.example.com, or even sub1.sub2.example.com. In order to limit the capability of such keys when this is not intended, the \"s\" flag may be set in the \"t=\" tag of the key record to constrain the validity of the record to exactly the domain of the signing identity. If the referenced key record contains the \"s\" flag as part of the \"t=\" tag, the domain of the signing identity (\"i=\" flag) MUST be the same as that of the d= domain. If this flag is absent, the domain of the signing identity MUST be the same as, or a subdomain of, the d= domain. Key records that are not intended for use with subdomains SHOULD specify the \"s\" flag in the \"t=\" tag.",
      "ja": "状況によっては、ドメインがサブドメインごとに個別のセレクター（キーレコード）を維持する必要なしに、サブドメインの代わりに署名を適用することが望ましい場合があります。デフォルトでは、鍵レコードに対応する秘密鍵を使用して、それらが存在するドメインの任意のサブドメインのメッセージに署名できます。たとえば、ドメインexample.comのキーレコードを使用して、署名ID（署名の「i =」タグ）がsub.example.com、さらにはsub1.sub2.example.comであるメッセージを検証できます。これが意図されていない場合にこのようなキーの機能を制限するには、キーレコードの「t =」タグに「s」フラグを設定して、レコードの有効性を署名IDのドメインに限定します。参照されたキーレコードに \"t =\"タグの一部として \"s\"フラグが含まれている場合、署名IDのドメイン（ \"i =\"フラグ）はd =ドメインのドメインと同じである必要があります。このフラグが存在しない場合、署名IDのドメインは、d =ドメインと同じか、そのサブドメインでなければなりません（MUST）。サブドメインでの使用を目的としていないキーレコードは、「t =」タグに「s」フラグを指定する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "4. Semantics of Multiple Signatures",
      "section_title": true,
      "ja": "4. 複数の署名のセマンティクス"
    },
    {
      "indent": 0,
      "text": "4.1. Example Scenarios",
      "section_title": true,
      "ja": "4.1. シナリオの例"
    },
    {
      "indent": 3,
      "text": "There are many reasons why a message might have multiple signatures. For example, a given signer might sign multiple times, perhaps with different hashing or signing algorithms during a transition phase.",
      "ja": "メッセージに複数の署名が含まれる理由は多数あります。たとえば、特定の署名者が、おそらく移行フェーズ中に異なるハッシュまたは署名アルゴリズムで複数回署名する場合があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE: Suppose SHA-256 is in the future found to be insufficiently strong, and DKIM usage transitions to SHA-1024. A signer might immediately sign using the newer algorithm, but continue to sign using the older algorithm for interoperability with verifiers that had not yet upgraded. The signer would do this by adding two DKIM-Signature header fields, one using each algorithm. Older verifiers that did not recognize SHA-1024 as an acceptable algorithm would skip that signature and use the older algorithm; newer verifiers could use either signature at their option, and all other things being equal might not even attempt to verify the other signature.",
      "ja": "有益な例：SHA-256の強度が不十分であることが今後判明し、DKIMの使用がSHA-1024に移行するとします。署名者は、新しいアルゴリズムを使用してすぐに署名しますが、まだアップグレードされていない検証者との相互運用性のために、古いアルゴリズムを使用して引き続き署名します。署名者は、各アルゴリズムを使用する2つのDKIM-Signatureヘッダーフィールドを追加することでこれを行います。 SHA-1024を許容可能なアルゴリズムとして認識しなかった古い検証者は、その署名をスキップして古いアルゴリズムを使用します。新しい検証者はオプションでどちらかの署名を使用することができ、同等である他のすべてのものは他の署名を検証することさえ試みないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Similarly, a signer might sign a message including all headers and no \"l=\" tag (to satisfy strict verifiers) and a second time with a limited set of headers and an \"l=\" tag (in anticipation of possible message modifications in route to other verifiers). Verifiers could then choose which signature they preferred.",
      "ja": "同様に、署名者は、すべてのヘッダーを含み、「l =」タグを含まない（厳密な検証者を満足させるため）メッセージに署名し、ヘッダーのセットと「l =」タグを制限して（ルートでのメッセージ変更の可能性を見越して）他の検証者へ）。次に、検証者は、希望する署名を選択できます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE: A verifier might receive a message with two signatures, one covering more of the message than the other. If the signature covering more of the message verified, then the verifier could make one set of policy decisions; if that signature failed but the signature covering less of the message verified, the verifier might make a different set of policy decisions.",
      "ja": "有益な例：検証者は、2つの署名が含まれたメッセージを受信する場合があります。より多くのメッセージをカバーする署名が検証された場合、検証者は一連のポリシー決定を行うことができます。その署名は失敗したが、検証されたメッセージのカバー範囲が少ない場合、検証者は別の一連のポリシー決定を行う可能性があります。"
    },
    {
      "indent": 3,
      "text": "Of course, a message might also have multiple signatures because it passed through multiple signers. A common case is expected to be that of a signed message that passes through a mailing list that also signs all messages. Assuming both of those signatures verify, a recipient might choose to accept the message if either of those signatures were known to come from trusted sources.",
      "ja": "もちろん、メッセージは複数の署名者を通過するため、複数の署名が含まれる場合もあります。一般的なケースは、すべてのメッセージにも署名するメーリングリストを通過する署名付きメッセージの場合です。これらの署名の両方が検証されると仮定すると、受信者は、これらの署名のいずれかが信頼できるソースからのものであることがわかっている場合、メッセージを受け入れることを選択できます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE: Recipients might choose to whitelist mailing lists to which they have subscribed and that have acceptable anti-abuse policies so as to accept messages sent to that list even from unknown authors. They might also subscribe to less trusted mailing lists (e.g., those without anti-abuse protection) and be willing to accept all messages from specific authors, but insist on doing additional abuse scanning for other messages.",
      "ja": "有益な例：受信者は、知らない作者からでもそのリストに送信されたメッセージを受け入れるために、自分が登録していて許容可能な不正使用防止ポリシーを持つメーリングリストをホワイトリストに登録することを選択する場合があります。彼らはまた、信頼性の低いメーリングリスト（乱用防止対策のないものなど）を購読し、特定の作成者からのすべてのメッセージを受け入れることをいとわないが、他のメッセージの追加の乱用スキャンを行うよう主張する場合もあります。"
    },
    {
      "indent": 3,
      "text": "Another related example of multiple signers might be forwarding services, such as those commonly associated with academic alumni sites.",
      "ja": "複数の署名者のもう1つの関連する例は、学業同窓生サイトに一般的に関連付けられているサービスなどの転送サービスです。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE: A recipient might have an address at members.example.org, a site that has anti-abuse protection that is somewhat less effective than the recipient would prefer. Such a recipient might have specific authors whose messages would be trusted absolutely, but messages from unknown authors that had passed the forwarder's scrutiny would have only medium trust.",
      "ja": "有益な例：受信者は、受信者が希望するよりも効果が少し低い乱用防止保護を備えたサイトであるmembers.example.orgにアドレスを持っている可能性があります。そのような受信者は、メッセージが絶対的に信頼される特定の作成者を持っているかもしれませんが、フォワーダーの精査を通過した未知の作成者からのメッセージは、中程度の信頼しかありません。"
    },
    {
      "indent": 0,
      "text": "4.2. Interpretation",
      "section_title": true,
      "ja": "4.2. 解釈"
    },
    {
      "indent": 3,
      "text": "A signer that is adding a signature to a message merely creates a new DKIM-Signature header, using the usual semantics of the h= option. A signer MAY sign previously existing DKIM-Signature header fields using the method described in Section 5.4 to sign trace header fields.",
      "ja": "メッセージに署名を追加する署名者は、h =オプションの通常のセマンティクスを使用して、新しいDKIM-Signatureヘッダーを作成するだけです。署名者は、セクション5.4で説明されている方法を使用して、既存のDKIM-Signatureヘッダーフィールドに署名し、トレースヘッダーフィールドに署名できます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Signers should be cognizant that signing DKIM-Signature header fields may result in signature failures with intermediaries that do not recognize that DKIM-Signature header fields are trace header fields and unwittingly reorder them, thus breaking such signatures. For this reason, signing existing DKIM-Signature header fields is unadvised, albeit legal.",
      "ja": "有益な注意：署名者は、DKIM-Signatureヘッダーフィールドに署名すると、DKIM-Signatureヘッダーフィールドがトレースヘッダーフィールドであることを認識せず、意図せずにそれらを並べ替えて、そのような署名を壊す仲介者による署名の失敗につながる可能性があることを認識する必要があります。このため、合法ではあるものの、既存のDKIM-Signatureヘッダーフィールドへの署名はお勧めできません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: If a header field with multiple instances is signed, those header fields are always signed from the bottom up. Thus, it is not possible to sign only specific DKIM-Signature header fields. For example, if the message being signed already contains three DKIM-Signature header fields A, B, and C, it is possible to sign all of them, B and C only, or C only, but not A only, B only, A and B only, or A and C only.",
      "ja": "有益な注意：複数のインスタンスを持つヘッダーフィールドが署名されている場合、それらのヘッダーフィールドは常に下から上に署名されます。したがって、特定のDKIM-Signatureヘッダーフィールドのみに署名することはできません。たとえば、署名されるメッセージにすでに3つのDKIM-SignatureヘッダーフィールドA、B、Cが含まれている場合、それらすべてに署名することが可能です。BとCのみ、またはCのみで、Aのみ、Bのみ、Aは署名できません。およびBのみ、またはAとCのみ。"
    },
    {
      "indent": 3,
      "text": "A signer MAY add more than one DKIM-Signature header field using different parameters. For example, during a transition period a signer might want to produce signatures using two different hash algorithms.",
      "ja": "署名者は、異なるパラメーターを使用して、複数のDKIM-Signatureヘッダーフィールドを追加できます。たとえば、移行期間中、署名者は2つの異なるハッシュアルゴリズムを使用して署名を生成する場合があります。"
    },
    {
      "indent": 3,
      "text": "Signers SHOULD NOT remove any DKIM-Signature header fields from messages they are signing, even if they know that the signatures cannot be verified.",
      "ja": "署名者は、署名を検証できないことがわかっている場合でも、署名しているメッセージからDKIM-Signatureヘッダーフィールドを削除しないでください。"
    },
    {
      "indent": 0,
      "text": " When evaluating a message with multiple signatures, a verifier SHOULD evaluate signatures independently and on their own merits. For example, a verifier that by policy chooses not to accept signatures with deprecated cryptographic algorithms would consider such signatures invalid. Verifiers MAY process signatures in any order of their choice; for example, some verifiers might choose to process signatures corresponding to the From field in the message header before other signatures. See Section 6.1 for more information about signature choices.",
      "ja": "複数の署名を持つメッセージを評価するとき、検証者は署名を独立して独自のメリットで評価する必要があります（SHOULD）。たとえば、ポリシーによって非推奨の暗号化アルゴリズムを使用した署名を受け入れないことを選択する検証者は、そのような署名を無効と見なします。検証者は、任意の順序で署名を処理できます。たとえば、一部の検証者は、メッセージヘッダーのFromフィールドに対応する署名を他の署名の前に処理することを選択する場合があります。署名の選択の詳細については、セクション6.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Verifier attempts to correlate valid signatures with invalid signatures in an attempt to guess why a signature failed are ill-advised. In particular, there is no general way that a verifier can determine that an invalid signature was ever valid.",
      "ja": "有益な実装注：署名が失敗した理由を推測するために、検証者は有効な署名を無効な署名と相関させようとする試みは不適切です。特に、無効な署名が有効であったと検証者が判断できる一般的な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Verifiers SHOULD ignore failed signatures as though they were not present in the message. Verifiers SHOULD continue to check signatures until a signature successfully verifies to the satisfaction of the verifier. To limit potential denial-of-service attacks, verifiers MAY limit the total number of signatures they will attempt to verify.",
      "ja": "検証者は、失敗した署名をメッセージに存在しないかのように無視する必要があります（SHOULD）。検証者は、署名が検証者の満足に成功裏に検証されるまで、署名のチェックを継続する必要があります（SHOULD）。潜在的なサービス拒否攻撃を制限するために、検証者は検証しようとする署名の総数を制限してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "5. Signer Actions",
      "section_title": true,
      "ja": "5. サインアクション"
    },
    {
      "indent": 3,
      "text": "The following steps are performed in order by signers.",
      "ja": "以下のステップは、署名者によって順番に実行されます。"
    },
    {
      "indent": 0,
      "text": "5.1. Determine Whether the Email Should Be Signed and by Whom",
      "section_title": true,
      "ja": "5.1. メールに署名する必要があるかどうか、誰が署名するかを決定する"
    },
    {
      "indent": 3,
      "text": "A signer can obviously only sign email for domains for which it has a private key and the necessary knowledge of the corresponding public key and selector information. However, there are a number of other reasons beyond the lack of a private key why a signer could choose not to sign an email.",
      "ja": "署名者は、秘密鍵を持ち、対応する公開鍵とセレクター情報に必要な知識を持つドメインのメールにのみ署名できることは明らかです。ただし、秘密鍵が不足していること以外にも、署名者がメールに署名しないことを選択できる理由はいくつかあります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Signing modules may be incorporated into any portion of the mail system as deemed appropriate, including an MUA, a SUBMISSION server, or an MTA. Wherever implemented, signers should beware of signing (and thereby asserting responsibility for) messages that may be problematic. In particular, within a trusted enclave the signing address might be derived from the header according to local policy; SUBMISSION servers might only sign messages from users that are properly authenticated and authorized.",
      "ja": "有益なメモ：署名モジュールは、MUA、SUBMISSIONサーバー、またはMTAなど、適切と見なされるメールシステムの任意の部分に組み込むことができます。実装されている場合は常に、署名者は、問題のあるメッセージに署名する（それによって責任を主張する）ことに注意する必要があります。特に、信頼されたエンクレーブ内では、ローカルアドレスに従って署名アドレスがヘッダーから取得される場合があります。送信サーバーは、適切に認証および承認されたユーザーからのメッセージにのみ署名する場合があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER ADVICE: SUBMISSION servers should not sign Received header fields if the outgoing gateway MTA obfuscates Received header fields, for example, to hide the details of internal topology.",
      "ja": "有益なIMPLEMENTERアドバイス：送信ゲートウェイMTAが受信ヘッダーフィールドを難読化して、内部トポロジの詳細を非表示にする場合など、送信サーバーは受信ヘッダーフィールドに署名しないでください。"
    },
    {
      "indent": 3,
      "text": "If an email cannot be signed for some reason, it is a local policy decision as to what to do with that email.",
      "ja": "何らかの理由で電子メールに署名できない場合、その電子メールをどう処理するかはローカルポリシーの決定です。"
    },
    {
      "indent": 0,
      "text": "5.2. Select a Private Key and Corresponding Selector Information",
      "section_title": true,
      "ja": "5.2. 秘密鍵と対応するセレクター情報を選択します"
    },
    {
      "indent": 3,
      "text": "This specification does not define the basis by which a signer should choose which private key and selector information to use. Currently, all selectors are equal as far as this specification is concerned, so the decision should largely be a matter of administrative convenience. Distribution and management of private keys is also outside the scope of this document.",
      "ja": "この仕様では、署名者が使用する秘密鍵とセレクター情報を選択する際の基準は定義されていません。現在、この仕様に関する限り、すべてのセレクターは等しいので、決定は主に管理上の利便性の問題になるはずです。秘密鍵の配布と管理も、このドキュメントの範囲外です。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS ADVICE: A signer should not sign with a private key when the selector containing the corresponding public key is expected to be revoked or removed before the verifier has an opportunity to validate the signature. The signer should anticipate that verifiers may choose to defer validation, perhaps until the message is actually read by the final recipient. In particular, when rotating to a new key pair, signing should immediately commence with the new private key and the old public key should be retained for a reasonable validation interval before being removed from the key server.",
      "ja": "有益な運用アドバイス：検証者が署名を検証する機会を得る前に、対応する公開鍵を含むセレクターが取り消されるか削除されることが予想される場合、署名者は秘密鍵で署名しないでください。署名者は、おそらくメッセージが最終的な受信者によって実際に読み取られるまで、検証者が検証を延期することを選択できることを予期する必要があります。特に、新しいキーペアにローテーションする場合、署名はすぐに新しい秘密キーで開始され、古い公開キーはキーサーバーから削除される前に妥当な検証期間保持されます。"
    },
    {
      "indent": 0,
      "text": "5.3. Normalize the Message to Prevent Transport Conversions",
      "section_title": true,
      "ja": "5.3. トランスポート変換を防ぐためにメッセージを正規化する"
    },
    {
      "indent": 3,
      "text": "Some messages, particularly those using 8-bit characters, are subject to modification during transit, notably conversion to 7-bit form. Such conversions will break DKIM signatures. In order to minimize the chances of such breakage, signers SHOULD convert the message to a suitable MIME content transfer encoding such as quoted-printable or base64 as described in MIME Part One [RFC2045] before signing. Such conversion is outside the scope of DKIM; the actual message SHOULD be converted to 7-bit MIME by an MUA or MSA prior to presentation to the DKIM algorithm.",
      "ja": "一部のメッセージ、特に8ビット文字を使用するメッセージは、転送中に変更される可能性があり、特に7ビット形式に変換されます。このような変換は、DKIM署名を破壊します。このような破損の可能性を最小限に抑えるため、署名者は、署名する前に、MIMEパート1 [RFC2045]で説明されているように、メッセージをquoted-printableやbase64などの適切なMIMEコンテンツ転送エンコーディングに変換する必要があります。このような変換はDKIMの範囲外です。実際のメッセージは、DKIMアルゴリズムに提示する前に、MUAまたはMSAによって7ビットMIMEに変換する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If the message is submitted to the signer with any local encoding that will be modified before transmission, that modification to canonical [RFC2822] form MUST be done before signing. In particular, bare CR or LF characters (used by some systems as a local line separator convention) MUST be converted to the SMTP-standard CRLF sequence before the message is signed. Any conversion of this sort SHOULD be applied to the message actually sent to the recipient(s), not just to the version presented to the signing algorithm.",
      "ja": "送信前に変更されるローカルエンコーディングを使用してメッセージが署名者に送信される場合、正規の[RFC2822]形式へのその変更は、署名の前に行う必要があります。特に、裸のCRまたはLF文字（一部のシステムではローカル行区切り記号の規則として使用されます）は、メッセージに署名する前にSMTP標準のCRLFシーケンスに変換する必要があります。この種の変換は、署名アルゴリズムに提示されたバージョンだけでなく、実際に受信者に送信されたメッセージに適用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "More generally, the signer MUST sign the message as it is expected to be received by the verifier rather than in some local or internal form.",
      "ja": "より一般的には、署名者は、ローカルまたは内部の形式ではなく、検証者によって受信されることが予想されるため、メッセージに署名する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4. Determine the Header Fields to Sign",
      "section_title": true,
      "ja": "5.4. 署名するヘッダーフィールドを決定する"
    },
    {
      "indent": 3,
      "text": "The From header field MUST be signed (that is, included in the \"h=\" tag of the resulting DKIM-Signature header field). Signers SHOULD NOT sign an existing header field likely to be legitimately modified or removed in transit. In particular, [RFC2821] explicitly permits modification or removal of the Return-Path header field in transit. Signers MAY include any other header fields present at the time of signing at the discretion of the signer.",
      "ja": "Fromヘッダーフィールドは署名されている必要があります（つまり、結果のDKIM-Signatureヘッダーフィールドの \"h =\"タグに含まれています）。署名者は、転送中に正当に変更または削除される可能性がある既存のヘッダーフィールドに署名しないでください。特に、[RFC2821]は、転送中のReturn-Pathヘッダーフィールドの変更または削除を明示的に許可しています。署名者は、署名者の裁量で署名時に存在する他のヘッダーフィールドを含めることができます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS NOTE: The choice of which header fields to sign is non-obvious. One strategy is to sign all existing, non-repeatable header fields. An alternative strategy is to sign only header fields that are likely to be displayed to or otherwise be likely to affect the processing of the message at the receiver. A third strategy is to sign only \"well known\" headers. Note that verifiers may treat unsigned header fields with extreme skepticism, including refusing to display them to the end user or even ignoring the signature if it does not cover certain header fields. For this reason, signing fields present in the message such as Date, Subject, Reply-To, Sender, and all MIME header fields are highly advised.",
      "ja": "有益な操作注：署名するヘッダーフィールドの選択は明白ではありません。 1つの方法は、既存のすべての繰り返し不可のヘッダーフィールドに署名することです。別の方法は、表示される可能性が高い、または受信者でのメッセージの処理に影響を与える可能性が高いヘッダーフィールドのみに署名することです。 3番目の戦略は、「既知の」ヘッダーのみに署名することです。検証者は、署名されていないヘッダーフィールドを極端に懐疑的に扱う可能性があることに注意してください。このため、日付、件名、返信先、送信者、およびすべてのMIMEヘッダーフィールドなど、メッセージに存在する署名フィールドを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field is always implicitly signed and MUST NOT be included in the \"h=\" tag except to indicate that other preexisting signatures are also signed.",
      "ja": "DKIM-Signatureヘッダーフィールドは常に暗黙的に署名されており、他の既存の署名も署名されていることを示す場合を除いて、「h =」タグに含めないでください。"
    },
    {
      "indent": 3,
      "text": "Signers MAY claim to have signed header fields that do not exist (that is, signers MAY include the header field name in the \"h=\" tag even if that header field does not exist in the message). When computing the signature, the non-existing header field MUST be treated as the null string (including the header field name, header field value, all punctuation, and the trailing CRLF).",
      "ja": "署名者は、存在しない署名済みヘッダーフィールドがあると主張する場合があります（つまり、署名者は、ヘッダーフィールドがメッセージに存在しない場合でも、「h =」タグにヘッダーフィールド名を含めることができます（MAY）。署名を計算するとき、存在しないヘッダーフィールドはnullストリングとして処理する必要があります（ヘッダーフィールド名、ヘッダーフィールド値、すべての句読点、および末尾のCRLFを含む）。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: This allows signers to explicitly assert the absence of a header field; if that header field is added later the signature will fail.",
      "ja": "有益な根拠：これにより、署名者はヘッダーフィールドがないことを明示的に表明できます。そのヘッダーフィールドが後で追加されると、署名は失敗します。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: A header field name need only be listed once more than the actual number of that header field in a message at the time of signing in order to prevent any further additions. For example, if there is a single Comments header field at the time of signing, listing Comments twice in the \"h=\" tag is sufficient to prevent any number of Comments header fields from being appended; it is not necessary (but is legal) to list Comments three or more times in the \"h=\" tag.",
      "ja": "有益な注：ヘッダーフィールド名は、それ以上の追加を防ぐために、署名時にメッセージ内のそのヘッダーフィールドの実際の数よりも1回だけリストする必要があります。たとえば、署名時にコメントヘッダーフィールドが1つしかない場合、「h =」タグにコメントを2回リストするだけで、コメントヘッダーフィールドがいくつも追加されるのを防ぐことができます。 「h =」タグにコメントを3回以上リストする必要はありません（ただし合法です）。"
    },
    {
      "indent": 3,
      "text": "Signers choosing to sign an existing header field that occurs more than once in the message (such as Received) MUST sign the physically last instance of that header field in the header block. Signers wishing to sign multiple instances of such a header field MUST include the header field name multiple times in the h= tag of the DKIM-Signature header field, and MUST sign such header fields in order from the bottom of the header field block to the top. The signer MAY include more instances of a header field name in h= than there are actual corresponding header fields to indicate that additional header fields of that name SHOULD NOT be added.",
      "ja": "メッセージ内で複数回発生する既存のヘッダーフィールド（Receivedなど）に署名することを選択した署名者は、ヘッダーブロック内のそのヘッダーフィールドの物理的に最後のインスタンスに署名する必要があります。そのようなヘッダーフィールドの複数のインスタンスに署名する署名者は、DKIM-Signatureヘッダーフィールドのh =タグにヘッダーフィールド名を複数回含める必要があり、ヘッダーフィールドブロックの下部から順にヘッダーフィールドに署名する必要があります上。署名者は、対応する実際のヘッダーフィールドよりも多くのヘッダーフィールド名のインスタンスをh =に含めることができ（MAY）、その名前の追加のヘッダーフィールドを追加してはならない（SHOULD NOT）。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE:",
      "ja": "有益な例："
    },
    {
      "indent": 6,
      "text": "If the signer wishes to sign two existing Received header fields, and the existing header contains:",
      "ja": "署名者が2つの既存のReceivedヘッダーフィールドに署名することを希望し、既存のヘッダーに以下が含まれている場合："
    },
    {
      "indent": 7,
      "text": "Received: <A>\nReceived: <B>\nReceived: <C>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "then the resulting DKIM-Signature header field should read:",
      "ja": "結果のDKIM-Signatureヘッダーフィールドは次のようになります。"
    },
    {
      "indent": 7,
      "text": "DKIM-Signature: ... h=Received : Received : ...",
      "ja": "DKIM-Signature：... h = Received：Received：..."
    },
    {
      "indent": 6,
      "text": "and Received header fields <C> and <B> will be signed in that order.",
      "ja": "受信したヘッダーフィールド<C>と<B>はこの順序で署名されます。"
    },
    {
      "indent": 3,
      "text": "Signers should be careful of signing header fields that might have additional instances added later in the delivery process, since such header fields might be inserted after the signed instance or otherwise reordered. Trace header fields (such as Received) and Resent-* blocks are the only fields prohibited by [RFC2822] from being reordered. In particular, since DKIM-Signature header fields may be reordered by some intermediate MTAs, signing existing DKIM-Signature header fields is error-prone.",
      "ja": "署名者は、署名済みインスタンスの後に挿入されるか、別の方法で並べ替えられる可能性があるため、配信プロセスの後半で追加のインスタンスが追加される可能性があるヘッダーフィールドに署名する場合は注意が必要です。トレースヘッダーフィールド（Receivedなど）およびResent- *ブロックのみが、[RFC2822]によって並べ替えが禁止されているフィールドです。特に、DKIM-Signatureヘッダーフィールドは一部の中間MTAによって並べ替えられる可能性があるため、既存のDKIM-Signatureヘッダーフィールドに署名するとエラーが発生しやすくなります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE ADMONITION: Despite the fact that [RFC2822] permits header fields to be reordered (with the exception of Received header fields), reordering of signed header fields with multiple instances by intermediate MTAs will cause DKIM signatures to be broken; such anti-social behavior should be avoided.",
      "ja": "有益な警告：[RFC2822]はヘッダーフィールドの並べ替えを許可する（Receivedヘッダーフィールドを除く）という事実にもかかわらず、中間MTAによって複数のインスタンスを持つ署名済みヘッダーフィールドを並べ替えると、DKIM署名が破損します。そのような反社会的行動は避けるべきです。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER'S NOTE: Although not required by this specification, all end-user visible header fields should be signed to avoid possible \"indirect spamming\". For example, if the Subject header field is not signed, a spammer can resend a previously signed mail, replacing the legitimate subject with a one-line spam.",
      "ja": "有益な実装者の注：この仕様では必須ではありませんが、「間接的なスパム」の可能性を回避するために、エンドユーザーに表示されるすべてのヘッダーフィールドに署名する必要があります。たとえば、Subjectヘッダーフィールドが署名されていない場合、スパマーは以前に署名されたメールを再送信して、正当な件名を1行のスパムに置き換えます。"
    },
    {
      "indent": 0,
      "text": "5.5. Recommended Signature Content",
      "section_title": true,
      "ja": "5.5. 推奨される署名コンテンツ"
    },
    {
      "indent": 3,
      "text": "In order to maximize compatibility with a variety of verifiers, it is recommended that signers follow the practices outlined in this section when signing a message. However, these are generic recommendations applying to the general case; specific senders may wish to modify these guidelines as required by their unique situations. Verifiers MUST be capable of verifying signatures even if one or more of the recommended header fields is not signed (with the exception of From, which must always be signed) or if one or more of the disrecommended header fields is signed. Note that verifiers do have the option of ignoring signatures that do not cover a sufficient portion of the header or body, just as they may ignore signatures from an identity they do not trust.",
      "ja": "さまざまなベリファイアとの互換性を最大にするために、署名者は、メッセージに署名するときに、このセクションで概説されているプラ​​クティスに従うことをお勧めします。ただし、これらは一般的なケースに適用される一般的な推奨事項です。特定の送信者は、固有の状況に応じてこれらのガイドラインを変更したい場合があります。 1つ以上の推奨ヘッダーフィールドが署名されていない場合（常に署名される必要があるFromを除く）、または1つ以上の非推奨ヘッダーフィールドが署名されている場合でも、検証者は署名を検証できる必要があります。ベリファイアには、信頼できないIDからの署名を無視するのと同じように、ヘッダーまたは本文の十分な部分をカバーしない署名を無視するオプションがあることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The following header fields SHOULD be included in the signature, if they are present in the message being signed:",
      "ja": "以下のヘッダーフィールドは、署名されているメッセージに存在する場合、署名に含める必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o From (REQUIRED in all signatures)",
      "ja": "o から（すべての署名で必須）"
    },
    {
      "indent": 3,
      "text": "o Sender, Reply-To",
      "ja": "o 送信者、返信先"
    },
    {
      "indent": 3,
      "text": "o Subject",
      "ja": "o 件名"
    },
    {
      "indent": 3,
      "text": "o Date, Message-ID",
      "ja": "o 日付、メッセージID"
    },
    {
      "indent": 3,
      "text": "o To, Cc",
      "ja": "o 宛先、CC"
    },
    {
      "indent": 3,
      "text": "o MIME-Version",
      "ja": "o MIMEバージョン"
    },
    {
      "indent": 3,
      "text": "o Content-Type, Content-Transfer-Encoding, Content-ID, Content-Description",
      "ja": "o Content-Type、Content-Transfer-Encoding、Content-ID、Content-Description"
    },
    {
      "indent": 3,
      "text": "o Resent-Date, Resent-From, Resent-Sender, Resent-To, Resent-Cc, Resent-Message-ID",
      "ja": "o Resent-Date、Resent-From、Resent-Sender、Resent-To、Resent-Cc、Resent-Message-ID"
    },
    {
      "indent": 3,
      "text": "o In-Reply-To, References",
      "ja": "o 返信先、参照"
    },
    {
      "indent": 3,
      "text": "o List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post, List-Owner, List-Archive",
      "ja": "o List-Id、List-Help、List-Unsubscribe、List-Subscribe、List-Post、List-Owner、List-Archive"
    },
    {
      "indent": 3,
      "text": "The following header fields SHOULD NOT be included in the signature:",
      "ja": "次のヘッダーフィールドは、署名に含まれてはいけません（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "o Return-Path",
      "ja": "o 復路"
    },
    {
      "indent": 3,
      "text": "o Received",
      "ja": "o 受け取りました"
    },
    {
      "indent": 0,
      "text": " o Comments, Keywords o Bcc, Resent-Bcc",
      "ja": "oコメント、キーワードo Bcc、Resent-Bcc"
    },
    {
      "indent": 3,
      "text": "o DKIM-Signature",
      "ja": "o DKIM-Signature"
    },
    {
      "indent": 3,
      "text": "Optional header fields (those not mentioned above) normally SHOULD NOT be included in the signature, because of the potential for additional header fields of the same name to be legitimately added or reordered prior to verification. There are likely to be legitimate exceptions to this rule, because of the wide variety of application-specific header fields that may be applied to a message, some of which are unlikely to be duplicated, modified, or reordered.",
      "ja": "検証前に同じ名前の追加のヘッダーフィールドが正当に追加または並べ替えられる可能性があるため、オプションのヘッダーフィールド（上記に記載されていないもの）は通常、署名に含めないでください。メッセージに適用されるアプリケーション固有のヘッダーフィールドは多種多様であるため、このルールには正当な例外がある可能性が高く、その一部は複製、変更、または並べ替えられる可能性が低いです。"
    },
    {
      "indent": 3,
      "text": "Signers SHOULD choose canonicalization algorithms based on the types of messages they process and their aversion to risk. For example, e-commerce sites sending primarily purchase receipts, which are not expected to be processed by mailing lists or other software likely to modify messages, will generally prefer \"simple\" canonicalization. Sites sending primarily person-to-person email will likely prefer to be more resilient to modification during transport by using \"relaxed\" canonicalization.",
      "ja": "署名者は、処理するメッセージのタイプとリスクへの嫌悪感に基づいて正規化アルゴリズムを選択する必要があります（SHOULD）。たとえば、主に購入時の領収書を送信するeコマースサイトは、メーリングリストやメッセージを変更する可能性のある他のソフトウェアによって処理されることが想定されていないため、一般に「単純な」正規化を好みます。主に個人から個人へのメールを送信するサイトは、「リラックスした」正規化を使用することにより、転送中の変更に対してより回復力があることを好むでしょう。"
    },
    {
      "indent": 3,
      "text": "Signers SHOULD NOT use \"l=\" unless they intend to accommodate intermediate mail processors that append text to a message. For example, many mailing list processors append \"unsubscribe\" information to message bodies. If signers use \"l=\", they SHOULD include the entire message body existing at the time of signing in computing the count. In particular, signers SHOULD NOT specify a body length of 0 since this may be interpreted as a meaningless signature by some verifiers.",
      "ja": "署名者は、メッセージにテキストを追加する中間メールプロセッサに対応するつもりでない限り、「l =」を使用しないでください。たとえば、多くのメーリングリストプロセッサは、メッセージ本文に「登録解除」情報を追加します。署名者が「l =」を使用する場合、署名の計算時に存在するメッセージ本文全体を含める必要があります（SHOULD）。特に、署名者は本文の長さとして0を指定しないでください。これは、一部の検証者によって無意味な署名として解釈される可能性があるためです。"
    },
    {
      "indent": 0,
      "text": "5.6. Compute the Message Hash and Signature",
      "section_title": true,
      "ja": "5.6. メッセージのハッシュと署名を計算する"
    },
    {
      "indent": 3,
      "text": "The signer MUST compute the message hash as described in Section 3.7 and then sign it using the selected public-key algorithm. This will result in a DKIM-Signature header field that will include the body hash and a signature of the header hash, where that header includes the DKIM-Signature header field itself.",
      "ja": "署名者は、セクション3.7で説明されているようにメッセージハッシュを計算してから、選択した公開鍵アルゴリズムを使用して署名する必要があります。これにより、本文ハッシュとヘッダーハッシュの署名を含むDKIM-Signatureヘッダーフィールドが作成されます。そのヘッダーにはDKIM-Signatureヘッダーフィールド自体が含まれます。"
    },
    {
      "indent": 3,
      "text": "Entities such as mailing list managers that implement DKIM and that modify the message or a header field (for example, inserting unsubscribe information) before retransmitting the message SHOULD check any existing signature on input and MUST make such modifications before re-signing the message.",
      "ja": "DKIMを実装し、メッセージを再送信する前にメッセージまたはヘッダーフィールドを変更するメーリングリストマネージャーなどのエンティティ（たとえば、サブスクライブ解除情報の挿入）は、入力の既存の署名を確認する必要があり、メッセージに再署名する前にそのような変更を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "The signer MAY elect to limit the number of bytes of the body that will be included in the hash and hence signed. The length actually hashed should be inserted in the \"l=\" tag of the DKIM-Signature header field.",
      "ja": "署名者は、ハッシュに含まれ、したがって署名される本文のバイト数を制限することを選択できます。実際にハッシュされる長さは、DKIM-Signatureヘッダーフィールドの「l =」タグに挿入する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7. Insert the DKIM-Signature Header Field",
      "section_title": true,
      "ja": "5.7. DKIM-Signatureヘッダーフィールドを挿入する"
    },
    {
      "indent": 3,
      "text": "Finally, the signer MUST insert the DKIM-Signature header field created in the previous step prior to transmitting the email. The DKIM-Signature header field MUST be the same as used to compute the hash as described above, except that the value of the \"b=\" tag MUST be the appropriately signed hash computed in the previous step, signed using the algorithm specified in the \"a=\" tag of the DKIM-Signature header field and using the private key corresponding to the selector given in the \"s=\" tag of the DKIM-Signature header field, as chosen above in Section 5.2",
      "ja": "最後に、署名者は、電子メールを送信する前に、前の手順で作成したDKIM-Signatureヘッダーフィールドを挿入する必要があります。 DKIM-Signatureヘッダーフィールドは、「b =」タグの値が前の手順で計算された適切に署名されたハッシュである必要があることを除いて、上記のようにハッシュを計算するために使用されるものと同じでなければなりません。セクション5.2で選択したように、DKIM-Signatureヘッダーフィールドの「a =」タグ、およびDKIM-Signatureヘッダーフィールドの「s =」タグで指定されたセレクターに対応する秘密鍵を使用"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field MUST be inserted before any other DKIM-Signature fields in the header block.",
      "ja": "DKIM-Signatureヘッダーフィールドは、ヘッダーブロック内の他のDKIM-Signatureフィールドの前に挿入する必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: The easiest way to achieve this is to insert the DKIM-Signature header field at the beginning of the header block. In particular, it may be placed before any existing Received header fields. This is consistent with treating DKIM-Signature as a trace header field.",
      "ja": "有益な実装注：これを実現する最も簡単な方法は、DKIM-Signatureヘッダーフィールドをヘッダーブロックの先頭に挿入することです。特に、既存のReceivedヘッダーフィールドの前に配置できます。これは、DKIM-Signatureをトレースヘッダーフィールドとして扱うことと一致しています。"
    },
    {
      "indent": 0,
      "text": "6. Verifier Actions",
      "section_title": true,
      "ja": "6. 検証アクション"
    },
    {
      "indent": 3,
      "text": "Since a signer MAY remove or revoke a public key at any time, it is recommended that verification occur in a timely manner. In many configurations, the most timely place is during acceptance by the border MTA or shortly thereafter. In particular, deferring verification until the message is accessed by the end user is discouraged.",
      "ja": "署名者は公開鍵をいつでも削除または取り消す可能性があるため、検証をタイムリーに行うことをお勧めします。多くの構成で、最もタイムリーな場所は、境界MTAによる受け入れ中またはその直後です。特に、エンドユーザーがメッセージにアクセスするまで検証を延期することはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "A border or intermediate MTA MAY verify the message signature(s). An MTA who has performed verification MAY communicate the result of that verification by adding a verification header field to incoming messages. This considerably simplifies things for the user, who can now use an existing mail user agent. Most MUAs have the ability to filter messages based on message header fields or content; these filters would be used to implement whatever policy the user wishes with respect to unsigned mail.",
      "ja": "境界または中間MTAは、メッセージの署名を検証する場合があります。検証を実行したMTAは、受信メッセージに検証ヘッダーフィールドを追加することにより、その検証の結果を伝えることができます（MAY）。これにより、ユーザーは既存のメールユーザーエージェントを使用できるようになります。ほとんどのMUAには、メッセージヘッダーフィールドまたはコンテンツに基づいてメッセージをフィルターする機能があります。これらのフィルターは、署名されていないメールに関してユーザーが希望するポリシーを実装するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A verifying MTA MAY implement a policy with respect to unverifiable mail, regardless of whether or not it applies the verification header field to signed messages.",
      "ja": "検証MTAは、検証ヘッダーフィールドを署名付きメッセージに適用するかどうかに関係なく、検証不可能なメールに関するポリシーを実装できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST produce a result that is semantically equivalent to applying the following steps in the order listed. In practice, several of these steps can be performed in parallel in order to improve performance.",
      "ja": "検証者は、リストされている順序で以下の手順を適用することと意味的に同等の結果を生成する必要があります。実際には、パフォーマンスを向上させるために、これらのステップのいくつかを並行して実行できます。"
    },
    {
      "indent": 0,
      "text": "6.1. Extract Signatures from the Message",
      "section_title": true,
      "ja": "6.1. メッセージから署名を抽出する"
    },
    {
      "indent": 3,
      "text": "The order in which verifiers try DKIM-Signature header fields is not defined; verifiers MAY try signatures in any order they like. For example, one implementation might try the signatures in textual order, whereas another might try signatures by identities that match the contents of the From header field before trying other signatures. Verifiers MUST NOT attribute ultimate meaning to the order of multiple DKIM-Signature header fields. In particular, there is reason to believe that some relays will reorder the header fields in potentially arbitrary ways.",
      "ja": "検証者がDKIM-Signatureヘッダーフィールドを試行する順序は定義されていません。検証者は、好きな順序で署名を試すことができます。たとえば、ある実装では署名をテキスト順に試行する可能性がありますが、別の実装では、他の署名を試行する前にFromヘッダーフィールドの内容と一致するIDで署名を試行する場合があります。検証者は、最終的な意味を複数のDKIM-Signatureヘッダーフィールドの順序に起因させてはなりません（MUST NOT）。特に、一部のリレーが潜在的に任意の方法でヘッダーフィールドを並べ替えると信じる理由があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Verifiers might use the order as a clue to signing order in the absence of any other information. However, other clues as to the semantics of multiple signatures (such as correlating the signing host with Received header fields) may also be considered.",
      "ja": "有益な実装注：検証者は、他の情報がない場合、注文に署名する手がかりとして注文を使用する場合があります。ただし、複数の署名のセマンティクスに関する他の手がかり（署名ホストと受信ヘッダーフィールドの関連付けなど）も検討できます。"
    },
    {
      "indent": 3,
      "text": "A verifier SHOULD NOT treat a message that has one or more bad signatures and no good signatures differently from a message with no signature at all; such treatment is a matter of local policy and is beyond the scope of this document.",
      "ja": "検証者は、1つ以上の悪い署名と良い署名がないメッセージを、署名がないメッセージとは別に扱います（SHOULD NOT）。このような扱いは地域の方針の問題であり、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "When a signature successfully verifies, a verifier will either stop processing or attempt to verify any other signatures, at the discretion of the implementation. A verifier MAY limit the number of signatures it tries to avoid denial-of-service attacks.",
      "ja": "署名の検証に成功すると、検証者は実装の裁量で処理を停止するか、他の署名の検証を試みます。検証者は、サービス拒否攻撃を回避しようとする署名の数を制限してもよい（MAY）。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: An attacker could send messages with large numbers of faulty signatures, each of which would require a DNS lookup and corresponding CPU time to verify the message. This could be an attack on the domain that receives the message, by slowing down the verifier by requiring it to do a large number of DNS lookups and/or signature verifications. It could also be an attack against the domains listed in the signatures, essentially by enlisting innocent verifiers in launching an attack against the DNS servers of the actual victim.",
      "ja": "有益なメモ：攻撃者は、多数の誤った署名を含むメッセージを送信する可能性があります。それぞれの署名には、DNSルックアップと対応するCPU時間を必要とするメッセージが検証されます。これは、メッセージを受信するドメインへの攻撃である可能性があります。これは、多数のDNSルックアップや署名の検証を行うことを要求することにより、ベリファイアを遅くします。また、シグネチャにリストされているドメインに対する攻撃である可能性もあります。基本的には、実際の被害者のDNSサーバーに対する攻撃を開始する際に無害な検証者を参加させることによるものです。"
    },
    {
      "indent": 0,
      "text": " In the following description, text reading \"return status (explanation)\" (where \"status\" is one of \"PERMFAIL\" or \"TEMPFAIL\") means that the verifier MUST immediately cease processing that signature. The verifier SHOULD proceed to the next signature, if any is present, and completely ignore the bad signature. If the status is \"PERMFAIL\", the signature failed and should not be reconsidered. If the status is \"TEMPFAIL\", the signature could not be verified at this time but may be tried again later. A verifier MAY either defer the message for later processing, perhaps by queueing it locally or issuing a 451/4.7.5 SMTP reply, or try another signature; if no good signature is found and any of the signatures resulted in a TEMPFAIL status, the verifier MAY save the message for later processing. The \"(explanation)\" is not normative text; it is provided solely for clarification.",
      "ja": "次の説明では、「ステータスを返す（説明）」というテキスト（「ステータス」は「PERMFAIL」または「TEMPFAIL」のいずれか）は、検証者がその署名の処理をただちに中止しなければならないことを意味します。検証者は、もしあれば次の署名に進み、悪い署名を完全に無視すべきです（SHOULD）。ステータスが「PERMFAIL」の場合、署名は失敗したため、再検討しないでください。ステータスが「TEMPFAIL」の場合、現時点では署名を検証できませんでしたが、後で再試行される可能性があります。ベリファイアは、おそらくローカルでキューに入れるか、451 / 4.7.5 SMTP応答を発行することによって、後で処理するためにメッセージを延期するか、または別の署名を試行します。適切な署名が見つからず、いずれかの署名がTEMPFAILステータスになった場合、ベリファイアは後で処理するためにメッセージを保存できます（MAY）。 「（説明）」は規範的なテキストではありません。説明のためにのみ提供されています。"
    },
    {
      "indent": 3,
      "text": "Verifiers SHOULD ignore any DKIM-Signature header fields where the signature does not validate. Verifiers that are prepared to validate multiple signature header fields SHOULD proceed to the next signature header field, should it exist. However, verifiers MAY make note of the fact that an invalid signature was present for consideration at a later step.",
      "ja": "検証者は、署名が検証されないDKIM-Signatureヘッダーフィールドを無視する必要があります（SHOULD）。複数の署名ヘッダーフィールドを検証するために準備された検証者は、存在する場合、次の署名ヘッダーフィールドに進む必要があります。ただし、検証者は、後のステップでの検討のために無効な署名が存在したという事実を記録する場合があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: The rationale of this requirement is to permit messages that have invalid signatures but also a valid signature to work. For example, a mailing list exploder might opt to leave the original submitter signature in place even though the exploder knows that it is modifying the message in some way that will break that signature, and the exploder inserts its own signature. In this case, the message should succeed even in the presence of the known-broken signature.",
      "ja": "有益な注意：この要件の根拠は、無効な署名だけでなく有効な署名も持つメッセージを機能させることです。たとえば、メーリングリストのエクスプローダーは、元のサブミッターの署名をそのまま残しておくことを選択する場合があります。ただし、エクスプローダーはメッセージを変更してその署名を壊すことを知っていて、エクスプローダーは独自の署名を挿入します。この場合、既知の破損した署名があってもメッセージは成功するはずです。"
    },
    {
      "indent": 3,
      "text": "For each signature to be validated, the following steps should be performed in such a manner as to produce a result that is semantically equivalent to performing them in the indicated order.",
      "ja": "検証される各署名について、以下の手順は、指示された順序でそれらを実行することと意味的に同等の結果を生成するような方法で実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Validate the Signature Header Field",
      "section_title": true,
      "ja": "6.1.1. 署名ヘッダーフィールドの検証"
    },
    {
      "indent": 3,
      "text": "Implementers MUST meticulously validate the format and values in the DKIM-Signature header field; any inconsistency or unexpected values MUST cause the header field to be completely ignored and the verifier to return PERMFAIL (signature syntax error). Being \"liberal in what you accept\" is definitely a bad strategy in this security context. Note however that this does not include the existence of unknown tags in a DKIM-Signature header field, which are explicitly permitted.",
      "ja": "実装者は、DKIM-Signatureヘッダーフィールドの形式と値を慎重に検証する必要があります。不整合や予期しない値があると、ヘッダーフィールドが完全に無視され、検証者がPERMFAIL（署名構文エラー）を返す必要があります。 「受け入れるものに寛大」であることは、このセキュリティのコンテキストでは間違いなく悪い戦略です。ただし、これには、明示的に許可されているDKIM-Signatureヘッダーフィールドに不明なタグが含まれていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST ignore DKIM-Signature header fields with a \"v=\" tag that is inconsistent with this specification and return PERMFAIL (incompatible version).",
      "ja": "検証者は、この仕様と一致しない「v =」タグが付いたDKIM-Signatureヘッダーフィールドを無視し、PERMFAIL（互換性のないバージョン）を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: An implementation may, of course, choose to also verify signatures generated by older versions of this specification.",
      "ja": "有益な実装注：もちろん、実装は、この仕様の古いバージョンによって生成された署名も検証することを選択できます。"
    },
    {
      "indent": 3,
      "text": "If any tag listed as \"required\" in Section 3.5 is omitted from the DKIM-Signature header field, the verifier MUST ignore the DKIM-Signature header field and return PERMFAIL (signature missing required tag).",
      "ja": "セクション3.5で「必須」としてリストされているタグがDKIM-Signatureヘッダーフィールドから省略されている場合、検証者はDKIM-Signatureヘッダーフィールドを無視してPERMFAIL（シグニチャーに必要なタグがない）を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIONAL NOTE: The tags listed as required in Section 3.5 are \"v=\", \"a=\", \"b=\", \"bh=\", \"d=\", \"h=\", and \"s=\". Should there be a conflict between this note and Section 3.5, Section 3.5 is normative.",
      "ja": "情報注記：セクション3.5で必須としてリストされているタグは、 \"v =\"、 \"a =\"、 \"b =\"、 \"bh =\"、 \"d =\"、 \"h =\"、および \"s =\"です。この注記とセクション3.5の間に矛盾がある場合、セクション3.5が規範的です。"
    },
    {
      "indent": 3,
      "text": "If the DKIM-Signature header field does not contain the \"i=\" tag, the verifier MUST behave as though the value of that tag were \"@d\", where \"d\" is the value from the \"d=\" tag.",
      "ja": "DKIM-Signatureヘッダーフィールドに「i =」タグが含まれていない場合、検証者は、そのタグの値が「@d」であるかのように動作する必要があります。「d」は「d =」タグの値です。"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST confirm that the domain specified in the \"d=\" tag is the same as or a parent domain of the domain part of the \"i=\" tag. If not, the DKIM-Signature header field MUST be ignored and the verifier should return PERMFAIL (domain mismatch).",
      "ja": "検証者は、「d =」タグで指定されたドメインが「i =」タグのドメイン部分と同じか、その親ドメインであることを確認する必要があります。そうでない場合、DKIM-Signatureヘッダーフィールドは無視する必要があり、検証者はPERMFAIL（ドメインの不一致）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the \"h=\" tag does not include the From header field, the verifier MUST ignore the DKIM-Signature header field and return PERMFAIL (From field not signed).",
      "ja": "「h =」タグにFromヘッダーフィールドが含まれていない場合、検証者はDKIM-Signatureヘッダーフィールドを無視して、PERMFAIL（Fromフィールドが署名されていない）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field and return PERMFAIL (signature expired) if it contains an \"x=\" tag and the signature has expired.",
      "ja": "「x =」タグが含まれ、署名の有効期限が切れている場合、検証者はDKIM-Signatureヘッダーフィールドを無視してPERMFAIL（署名の期限切れ）を返す場合があります。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field if the domain used by the signer in the \"d=\" tag is not associated with a valid signing entity. For example, signatures with \"d=\" values such as \"com\" and \"co.uk\" may be ignored. The list of unacceptable domains SHOULD be configurable.",
      "ja": "「d =」タグの署名者が使用するドメインが有効な署名エンティティに関連付けられていない場合、検証者はDKIM-Signatureヘッダーフィールドを無視してもよい（MAY）。たとえば、「com」や「co.uk」などの「d =」値を含む署名は無視されます。許可されないドメインのリストは構成可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field and return PERMFAIL (unacceptable signature header) for any other reason, for example, if the signature does not sign header fields that the verifier views to be essential. As a case in point, if MIME header fields are not signed, certain attacks may be possible that the verifier would prefer to avoid.",
      "ja": "ベリファイアは、DKIM-Signatureヘッダーフィールドを無視して、他の理由で、たとえば、ベリファイアが必須であると見なすヘッダーフィールドに署名が署名しない場合、PERMFAIL（受け入れられない署名ヘッダー）を返す場合があります。代表的な例として、MIMEヘッダーフィールドが署名されていない場合、検証者が回避することを好む特定の攻撃が可能になる可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Get the Public Key",
      "section_title": true,
      "ja": "6.1.2. 公開鍵を取得する"
    },
    {
      "indent": 3,
      "text": "The public key for a signature is needed to complete the verification process. The process of retrieving the public key depends on the query type as defined by the \"q=\" tag in the DKIM-Signature header field. Obviously, a public key need only be retrieved if the process of extracting the signature information is completely successful. Details of key management and representation are described in Section 3.6. The verifier MUST validate the key record and MUST ignore any public key records that are malformed.",
      "ja": "検証プロセスを完了するには、署名の公開鍵が必要です。公開鍵を取得するプロセスは、DKIM-Signatureヘッダーフィールドの「q =」タグで定義されているクエリタイプによって異なります。明らかに、公開鍵は、署名情報の抽出プロセスが完全に成功した場合にのみ取得する必要があります。鍵の管理と表現の詳細については、3.6項を参照してください。検証者は鍵レコードを検証しなければならず、不正な形式の公開鍵レコードを無視しなければなりません（MUST）。"
    },
    {
      "indent": 0,
      "text": " When validating a message, a verifier MUST perform the following steps in a manner that is semantically the same as performing them in the order indicated (in some cases, the implementation may parallelize or reorder these steps, as long as the semantics remain unchanged):",
      "ja": "メッセージを検証するとき、ベリファイアは以下の手順を意味的に同じ順序で実行する必要があります（場合によっては、実装は、セマンティクスが変更されない限り、これらの手順を並列化または並べ替えることができます）。"
    },
    {
      "indent": 3,
      "text": "1. Retrieve the public key as described in Section 3.6 using the algorithm in the \"q=\" tag, the domain from the \"d=\" tag, and the selector from the \"s=\" tag.",
      "ja": "1. 「q =」タグのアルゴリズム、「d =」タグのドメイン、「s =」タグのセレクターを使用して、セクション3.6で説明されているように公開鍵を取得します。"
    },
    {
      "indent": 3,
      "text": "2. If the query for the public key fails to respond, the verifier MAY defer acceptance of this email and return TEMPFAIL (key unavailable). If verification is occurring during the incoming SMTP session, this MAY be achieved with a 451/4.7.5 SMTP reply code. Alternatively, the verifier MAY store the message in the local queue for later trial or ignore the signature. Note that storing a message in the local queue is subject to denial-of-service attacks.",
      "ja": "2. 公開キーのクエリが応答しない場合、検証者はこの電子メールの受け入れを延期し、TEMPFAIL（キーを使用不可）を返すことができます（MAY）。着信SMTPセッション中に検証が行われている場合、これは451 / 4.7.5 SMTP応答コードで達成される場合があります。または、ベリファイアは、後の試行のためにメッセージをローカルキューに格納するか、署名を無視する場合があります。メッセージをローカルキューに格納すると、サービス拒否攻撃の対象となることに注意してください。"
    },
    {
      "indent": 3,
      "text": "3. If the query for the public key fails because the corresponding key record does not exist, the verifier MUST immediately return PERMFAIL (no key for signature).",
      "ja": "3. 対応するキーレコードが存在しないために公開キーのクエリが失敗した場合、検証者は直ちにPERMFAIL（署名用のキーなし）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "4. If the query for the public key returns multiple key records, the verifier may choose one of the key records or may cycle through the key records performing the remainder of these steps on each record at the discretion of the implementer. The order of the key records is unspecified. If the verifier chooses to cycle through the key records, then the \"return ...\" wording in the remainder of this section means \"try the next key record, if any; if none, return to try another signature in the usual way\".",
      "ja": "4. 公開キーのクエリが複数のキーレコードを返す場合、検証者はキーレコードの1つを選択するか、実装者の裁量で各レコードに対してこれらの手順の残りを実行するキーレコードを循環できます。キーレコードの順序は指定されていません。検証者がキーレコードを循環することを選択した場合、このセクションの残りの部分にある「return ...」という表現は、「次のキーレコードがあればそれを試行し、ない場合は通常の方法で別の署名を試す」ことを意味します。 。"
    },
    {
      "indent": 3,
      "text": "5. If the result returned from the query does not adhere to the format defined in this specification, the verifier MUST ignore the key record and return PERMFAIL (key syntax error). Verifiers are urged to validate the syntax of key records carefully to avoid attempted attacks. In particular, the verifier MUST ignore keys with a version code (\"v=\" tag) that they do not implement.",
      "ja": "5. クエリから返された結果がこの仕様で定義されている形式に準拠していない場合、検証者はキーレコードを無視して、PERMFAIL（キー構文エラー）を返す必要があります。検証者は、攻撃の試みを回避するために、重要なレコードの構文を慎重に検証することが求められます。特に、検証者は、実装していないバージョンコード（ \"v =\"タグ）を持つキーを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": " 6. If the \"g=\" tag in the public key does not match the Local-part of the \"i=\" tag in the message signature header field, the verifier MUST ignore the key record and return PERMFAIL (inapplicable key). If the Local-part of the \"i=\" tag on the message signature is not present, the \"g=\" tag must be \"*\" (valid for all addresses in the domain) or the entire g= tag must be omitted (which defaults to \"g=*\"), otherwise the verifier MUST ignore the key record and return PERMFAIL (inapplicable key). Other than this test, verifiers SHOULD NOT treat a message signed with a key record having a \"g=\" tag any differently than one without; in particular, verifiers SHOULD NOT prefer messages that seem to have an individual signature by virtue of a \"g=\" tag versus a domain signature.",
      "ja": "6.公開キーの「g =」タグがメッセージ署名ヘッダーフィールドの「i =」タグのLocal-partと一致しない場合、検証者はキーレコードを無視し、PERMFAIL（適用外のキー）を返す必要があります。メッセージ署名の「i =」タグのローカル部分が存在しない場合、「g =」タグは「*」（ドメイン内のすべてのアドレスに対して有効）であるか、またはg =タグ全体を省略する必要があります（デフォルトは \"g = *\"）です。それ以外の場合、ベリファイアはキーレコードを無視し、PERMFAIL（適用外のキー）を返す必要があります。このテスト以外では、検証者は、「g =」タグを持つキーレコードで署名されたメッセージを、それがないものとは異なる方法で処理してはなりません（SHOULD NOT）。特に、検証者は、「g =」タグとドメイン署名のおかげで、個別の署名があるように見えるメッセージを優先すべきではありません。"
    },
    {
      "indent": 3,
      "text": "7. If the \"h=\" tag exists in the public key record and the hash algorithm implied by the a= tag in the DKIM-Signature header field is not included in the contents of the \"h=\" tag, the verifier MUST ignore the key record and return PERMFAIL (inappropriate hash algorithm).",
      "ja": "7. 「h =」タグが公開鍵レコードに存在し、DKIM-Signatureヘッダーフィールドのa =タグによって暗示されるハッシュアルゴリズムが「h =」タグの内容に含まれていない場合、検証者はキーを無視する必要があります。 PERMFAIL（不適切なハッシュアルゴリズム）を記録して返します。"
    },
    {
      "indent": 3,
      "text": "8. If the public key data (the \"p=\" tag) is empty, then this key has been revoked and the verifier MUST treat this as a failed signature check and return PERMFAIL (key revoked). There is no defined semantic difference between a key that has been revoked and a key record that has been removed.",
      "ja": "8. 公開鍵データ（ \"p =\"タグ）が空の場合、この鍵は取り消されており、検証者はこれを失敗した署名検査として扱い、PERMFAIL（鍵が取り消された）を返す必要があります。取り消されたキーと削除されたキーレコードとの間には、定義された意味上の違いはありません。"
    },
    {
      "indent": 3,
      "text": "9. If the public key data is not suitable for use with the algorithm and key types defined by the \"a=\" and \"k=\" tags in the DKIM-Signature header field, the verifier MUST immediately return PERMFAIL (inappropriate key algorithm).",
      "ja": "9. 公開鍵データが、DKIM-Signatureヘッダーフィールドの「a =」および「k =」タグで定義されたアルゴリズムと鍵タイプでの使用に適していない場合、検証者は直ちにPERMFAIL（不適切な鍵アルゴリズム）を返す必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Compute the Verification",
      "section_title": true,
      "ja": "6.1.3. 検証を計算する"
    },
    {
      "indent": 3,
      "text": "Given a signer and a public key, verifying a signature consists of actions semantically equivalent to the following steps.",
      "ja": "署名者と公開鍵が与えられた場合、署名の検証は、以下のステップと意味的に同等のアクションで構成されます。"
    },
    {
      "indent": 3,
      "text": "1. Based on the algorithm defined in the \"c=\" tag, the body length specified in the \"l=\" tag, and the header field names in the \"h=\" tag, prepare a canonicalized version of the message as is described in Section 3.7 (note that this version does not actually need to be instantiated). When matching header field names in the \"h=\" tag against the actual message header field, comparisons MUST be case-insensitive.",
      "ja": "1. 「c =」タグで定義されたアルゴリズム、「l =」タグで指定された本文の長さ、および「h =」タグのヘッダーフィールド名に基づいて、セクションの説明に従って、メッセージの正規化バージョンを準備します。 3.7（このバージョンは実際にインスタンス化する必要がないことに注意してください）。 「h =」タグのヘッダーフィールド名を実際のメッセージヘッダーフィールドと照合する場合、比較では大文字と小文字を区別する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Based on the algorithm indicated in the \"a=\" tag, compute the message hashes from the canonical copy as described in Section 3.7.",
      "ja": "2. 「a =」タグで示されたアルゴリズムに基づいて、セクション3.7で説明されているように、正規のコピーからメッセージハッシュを計算します。"
    },
    {
      "indent": 3,
      "text": "3. Verify that the hash of the canonicalized message body computed in the previous step matches the hash value conveyed in the \"bh=\" tag. If the hash does not match, the verifier SHOULD ignore the signature and return PERMFAIL (body hash did not verify).",
      "ja": "3. 前の手順で計算された正規化されたメッセージ本文のハッシュが、「bh =」タグで伝えられたハッシュ値と一致することを確認します。ハッシュが一致しない場合、検証者は署名を無視して、PERMFAIL（ボディハッシュは検証しなかった）を返す必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "4. Using the signature conveyed in the \"b=\" tag, verify the signature against the header hash using the mechanism appropriate for the public key algorithm described in the \"a=\" tag. If the signature does not validate, the verifier SHOULD ignore the signature and return PERMFAIL (signature did not verify).",
      "ja": "4. 「b =」タグで伝達される署名を使用し、「a =」タグで説明されている公開鍵アルゴリズムに適切なメカニズムを使用して、ヘッダーハッシュに対して署名を検証します。署名が検証されない場合、検証者は署名を無視して、PERMFAILを返す必要があります（署名は検証されませんでした）。"
    },
    {
      "indent": 3,
      "text": "5. Otherwise, the signature has correctly verified.",
      "ja": "5. それ以外の場合、署名は正しく検証されています。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER'S NOTE: Implementations might wish to initiate the public-key query in parallel with calculating the hash as the public key is not needed until the final decryption is calculated. Implementations may also verify the signature on the message header before validating that the message hash listed in the \"bh=\" tag in the DKIM-Signature header field matches that of the actual message body; however, if the body hash does not match, the entire signature must be considered to have failed.",
      "ja": "有益な実装者のメモ：公開鍵は最終的な復号化が計算されるまで必要とされないため、ハッシュの計算と並行して公開鍵クエリを開始したい場合があります。実装は、DKIM-Signatureヘッダーフィールドの「bh =」タグにリストされているメッセージハッシュが実際のメッセージ本文のハッシュと一致することを検証する前に、メッセージヘッダーの署名を検証する場合もあります。ただし、本文のハッシュが一致しない場合、署名全体が失敗したと見なす必要があります。"
    },
    {
      "indent": 3,
      "text": "A body length specified in the \"l=\" tag of the signature limits the number of bytes of the body passed to the verification algorithm. All data beyond that limit is not validated by DKIM. Hence, verifiers might treat a message that contains bytes beyond the indicated body length with suspicion, such as by truncating the message at the indicated body length, declaring the signature invalid (e.g., by returning PERMFAIL (unsigned content)), or conveying the partial verification to the policy module.",
      "ja": "署名の「l =」タグで指定された本文の長さは、検証アルゴリズムに渡される本文のバイト数を制限します。この制限を超えるすべてのデータは、DKIMによって検証されません。したがって、検証者は、指定された本文の長さを超えるバイトを含むメッセージを、指定された本文の長さでメッセージを切り捨てたり、署名を無効に宣言したり（たとえば、PERMFAIL（署名されていないコンテンツ）を返したり）、部分的なメッセージを伝えたりするなどの疑いで扱う可能性があります。ポリシーモジュールの検証。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Verifiers that truncate the body at the indicated body length might pass on a malformed MIME message if the signer used the \"N-4\" trick (omitting the final \"--CRLF\") described in the informative note in Section 3.4.5. Such verifiers may wish to check for this case and include a trailing \"--CRLF\" to avoid breaking the MIME structure. A simple way to achieve this might be to append \"--CRLF\" to any \"multipart\" message with a body length; if the MIME structure is already correctly formed, this will appear in the postlude and will not be displayed to the end user.",
      "ja": "有益な実装注：署名者がセクション3.4の説明に記載されている「N-4」トリック（最後の「--CRLF」を省略）を使用した場合、指定された本文の長さで本文を切り捨てる検証者は、不正なMIMEメッセージを渡す可能性があります。 .5。そのような検証者は、このケースをチェックし、MIME構造を壊さないように末尾に「--CRLF」を含めることを望む場合があります。これを実現する簡単な方法は、本文の長さのある「マルチパート」メッセージに「--CRLF」を追加することです。 MIME構造が既に正しく形成されている場合、これはポストリュードに表示され、エンドユーザーには表示されません。"
    },
    {
      "indent": 0,
      "text": "6.2. Communicate Verification Results",
      "section_title": true,
      "ja": "6.2. 検証結果の伝達"
    },
    {
      "indent": 3,
      "text": "Verifiers wishing to communicate the results of verification to other parts of the mail system may do so in whatever manner they see fit. For example, implementations might choose to add an email header field to the message before passing it on. Any such header field SHOULD be inserted before any existing DKIM-Signature or preexisting authentication status header fields in the header field block.",
      "ja": "検証の結果をメールシステムの他の部分に伝達したい検証者は、適切と思われる方法でこれを行うことができます。たとえば、実装では、メッセージを渡す前に、メールヘッダーフィールドをメッセージに追加することを選択できます。このようなヘッダーフィールドは、ヘッダーフィールドブロック内の既存のDKIM-Signatureまたは既存の認証ステータスヘッダーフィールドの前に挿入する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": " INFORMATIVE ADVICE to MUA filter writers: Patterns intended to search for results header fields to visibly mark authenticated mail for end users should verify that such header field was added by the appropriate verifying domain and that the verified identity matches the author identity that will be displayed by the MUA. In particular, MUA filters should not be influenced by bogus results header fields added by attackers. To circumvent this attack, verifiers may wish to delete existing results header fields after verification and before adding a new header field.",
      "ja": "有益なアドバイスからMUAフィルターへの書き込み：結果ヘッダーフィールドを検索してエンドユーザーの認証済みメールを視覚的にマークすることを目的としたパターンは、そのようなヘッダーフィールドが適切な検証ドメインによって追加され、検証されたIDが表示される著者IDと一致することを確認する必要がありますMUA。特に、MUAフィルターは、攻撃者によって追加された偽の結果ヘッダーフィールドの影響を受けないようにする必要があります。この攻撃を回避するために、検証者は、検証後、新しいヘッダーフィールドを追加する前に、既存の結果ヘッダーフィールドを削除したい場合があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Interpret Results/Apply Local Policy",
      "section_title": true,
      "ja": "6.3. 結果の解釈/ローカルポリシーの適用"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this specification to describe what actions a verifier system should make, but an authenticated email presents an opportunity to a receiving system that unauthenticated email cannot. Specifically, an authenticated email creates a predictable identifier by which other decisions can reliably be managed, such as trust and reputation. Conversely, unauthenticated email lacks a reliable identifier that can be used to assign trust and reputation. It is reasonable to treat unauthenticated email as lacking any trust and having no positive reputation.",
      "ja": "検証システムが行うべきアクションを説明することはこの仕様の範囲を超えていますが、認証された電子メールは、認証されていない電子メールではできない受信システムに機会を提供します。具体的には、認証された電子メールは予測可能な識別子を作成し、それによって信頼や評判などの他の決定を確実に管理できます。逆に、認証されていない電子メールには、信頼と評判を割り当てるために使用できる信頼できる識別子がありません。認証されていない電子メールは信頼がなく、肯定的な評判がないものとして扱うのが妥当です。"
    },
    {
      "indent": 3,
      "text": "In general, verifiers SHOULD NOT reject messages solely on the basis of a lack of signature or an unverifiable signature; such rejection would cause severe interoperability problems. However, if the verifier does opt to reject such messages (for example, when communicating with a peer who, by prior agreement, agrees to only send signed messages), and the verifier runs synchronously with the SMTP session and a signature is missing or does not verify, the MTA SHOULD use a 550/5.7.x reply code.",
      "ja": "一般に、検証者は、署名の欠如または検証不可能な署名のみに基づいてメッセージを拒否するべきではありません。このような拒否は、深刻な相互運用性の問題を引き起こします。ただし、検証者がそのようなメッセージを拒否することを選択した場合（たとえば、事前の合意により、署名されたメッセージのみを送信することに同意するピアと通信する場合）、検証者はSMTPセッションと同期して実行され、署名がないか、または検証しない場合、MTAは550 / 5.7.x応答コードを使用する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "If it is not possible to fetch the public key, perhaps because the key server is not available, a temporary failure message MAY be generated using a 451/4.7.5 reply code, such as:",
      "ja": "公開鍵を取得できない場合は、おそらく鍵サーバーが利用できないため、次のような451 / 4.7.5応答コードを使用して一時的なエラーメッセージが生成される場合があります。"
    },
    {
      "indent": 6,
      "text": "451 4.7.5 Unable to verify signature - key server unavailable",
      "ja": "451 4.7.5署名を検証できません-鍵サーバーを利用できません"
    },
    {
      "indent": 3,
      "text": "Temporary failures such as inability to access the key server or other external service are the only conditions that SHOULD use a 4xx SMTP reply code. In particular, cryptographic signature verification failures MUST NOT return 4xx SMTP replies.",
      "ja": "キーサーバーまたは他の外部サービスにアクセスできないなどの一時的な障害は、4xx SMTP応答コードを使用する必要がある唯一の条件です。特に、暗号署名検証の失敗は4xx SMTP応答を返してはならない（MUST NOT）。"
    },
    {
      "indent": 3,
      "text": "Once the signature has been verified, that information MUST be conveyed to higher-level systems (such as explicit allow/whitelists and reputation systems) and/or to the end user. If the message is signed on behalf of any address other than that in the From: header field, the mail system SHOULD take pains to ensure that the actual signing identity is clear to the reader.",
      "ja": "署名が検証されたら、その情報を上位レベルのシステム（明示的な許可/ホワイトリストやレピュテーションシステムなど）やエンドユーザーに伝達する必要があります。メッセージがFrom：ヘッダーフィールドのアドレス以外のアドレスに代わって署名されている場合、メールシステムは実際の署名IDが読者に明確であることを確認するために苦労する必要があります。"
    },
    {
      "indent": 3,
      "text": "The verifier MAY treat unsigned header fields with extreme skepticism, including marking them as untrusted or even deleting them before display to the end user.",
      "ja": "検証者は、署名されていないヘッダーフィールドを、信頼できないものとしてマークしたり、エンドユーザーに表示する前に削除したりするなど、非常に懐疑的に扱うことができます。"
    },
    {
      "indent": 3,
      "text": "While the symptoms of a failed verification are obvious -- the signature doesn't verify -- establishing the exact cause can be more difficult. If a selector cannot be found, is that because the selector has been removed, or was the value changed somehow in transit? If the signature line is missing, is that because it was never there, or was it removed by an overzealous filter? For diagnostic purposes, the exact reason why the verification fails SHOULD be made available to the policy module and possibly recorded in the system logs. If the email cannot be verified, then it SHOULD be rendered the same as all unverified email regardless of whether or not it looks like it was signed.",
      "ja": "検証が失敗した場合の症状は明らかですが（署名では検証されません）、正確な原因を特定することはより困難な場合があります。セレクターが見つからない場合、それはセレクターが削除されたか、値が転送中に何らかの方法で変更されたためですか？署名行が見つからない場合、それはそこになかったためか、過度のフィルターによって削除されたためですか？診断の目的で、検証が失敗した正確な理由は、ポリシーモジュールで利用できるようにし、システムログに記録する必要があります。電子メールを検証できない場合は、署名されているように見えるかどうかに関係なく、未検証のすべての電子メールと同じようにレンダリングする必要があります。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "DKIM introduces some new namespaces that have been registered with IANA. In all cases, new values are assigned only for values that have been documented in a published RFC that has IETF Consensus [RFC2434].",
      "ja": "DKIMでは、IANAに登録されているいくつかの新しい名前空間が導入されています。すべての場合において、新しい値は、IETFコンセンサス[RFC2434]を持つ公開されたRFCで文書化されている値に対してのみ割り当てられます。"
    },
    {
      "indent": 0,
      "text": "7.1. DKIM-Signature Tag Specifications",
      "section_title": true,
      "ja": "7.1. DKIM-Signatureタグの仕様"
    },
    {
      "indent": 3,
      "text": "A DKIM-Signature provides for a list of tag specifications. IANA has established the DKIM-Signature Tag Specification Registry for tag specifications that can be used in DKIM-Signature fields.",
      "ja": "DKIM-Signatureは、タグ仕様のリストを提供します。 IANAは、DKIM-Signatureフィールドで使用できるタグ仕様用のDKIM-Signatureタグ仕様レジストリを確立しました。"
    },
    {
      "indent": 15,
      "text": "The initial entries in the registry comprise:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 24,
      "text": "+------+-----------------+\n| TYPE | REFERENCE       |\n+------+-----------------+\n| v    | (this document) |\n| a    | (this document) |\n| b    | (this document) |\n| bh   | (this document) |\n| c    | (this document) |\n| d    | (this document) |\n| h    | (this document) |\n| i    | (this document) |\n| l    | (this document) |\n| q    | (this document) |\n| s    | (this document) |\n| t    | (this document) |\n| x    | (this document) |\n| z    | (this document) |\n+------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "DKIM-Signature Tag Specification Registry Initial Values",
      "ja": "DKIM-Signatureタグ仕様レジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.2. DKIM-Signature Query Method Registry",
      "section_title": true,
      "ja": "7.2. DKIM-Signatureクエリメソッドレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"q=\" tag-spec (specified in Section 3.5) provides for a list of query methods.",
      "ja": "\"q =\" tag-spec（セクション3.5で指定）は、クエリメソッドのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM-Signature Query Method Registry for mechanisms that can be used to retrieve the key that will permit validation processing of a message signed using DKIM.",
      "ja": "IANAは、DKIMを使用して署名されたメッセージの検証処理を許可するキーを取得するために使用できるメカニズム用のDKIM-Signature Query Method Registryを確立しました。"
    },
    {
      "indent": 15,
      "text": "The initial entry in the registry comprises:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 20,
      "text": "+------+--------+-----------------+\n| TYPE | OPTION | REFERENCE       |\n+------+--------+-----------------+\n| dns  | txt    | (this document) |\n+------+--------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "DKIM-Signature Query Method Registry Initial Values",
      "ja": "DKIM-Signatureクエリメソッドレジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.3. DKIM-Signature Canonicalization Registry",
      "section_title": true,
      "ja": "7.3. DKIM-Signature Canonicalization Registry"
    },
    {
      "indent": 3,
      "text": "The \"c=\" tag-spec (specified in Section 3.5) provides for a specifier for canonicalization algorithms for the header and body of the message.",
      "ja": "\"c =\" tag-spec（セクション3.5で指定）は、メッセージのヘッダーと本文の正規化アルゴリズムの指定子を提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM-Signature Canonicalization Algorithm Registry for algorithms for converting a message into a canonical form before signing or verifying using DKIM.",
      "ja": "IANAは、DKIMを使用して署名または検証する前に、メッセージを正規形式に変換するアルゴリズム用のDKIM-Signature Canonicalization Algorithm Registryを確立しました。"
    },
    {
      "indent": 11,
      "text": "The initial entries in the header registry comprise:",
      "ja": "ヘッダーレジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 23,
      "text": "+---------+-----------------+\n| TYPE    | REFERENCE       |\n+---------+-----------------+\n| simple  | (this document) |\n| relaxed | (this document) |\n+---------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "DKIM-Signature Header Canonicalization Algorithm Registry Initial Values",
      "ja": "DKIM-Signatureヘッダー正規化アルゴリズムレジストリ初期値"
    },
    {
      "indent": 12,
      "text": "The initial entries in the body registry comprise:",
      "ja": "本文レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 23,
      "text": "+---------+-----------------+\n| TYPE    | REFERENCE       |\n+---------+-----------------+\n| simple  | (this document) |\n| relaxed | (this document) |\n+---------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "DKIM-Signature Body Canonicalization Algorithm Registry Initial Values",
      "ja": "DKIM-Signature Body Canonicalization Algorithmレジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.4. _domainkey DNS TXT Record Tag Specifications",
      "section_title": true,
      "ja": "7.4. _domainkey DNS TXTレコードタグの仕様"
    },
    {
      "indent": 3,
      "text": "A _domainkey DNS TXT record provides for a list of tag specifications. IANA has established the DKIM _domainkey DNS TXT Tag Specification Registry for tag specifications that can be used in DNS TXT Records.",
      "ja": "_domainkey DNS TXTレコードは、タグ仕様のリストを提供します。 IANAは、DNS TXTレコードで使用できるタグ仕様用のDKIM _domainkey DNS TXTタグ仕様レジストリを確立しました。"
    },
    {
      "indent": 15,
      "text": "The initial entries in the registry comprise:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 24,
      "text": "+------+-----------------+\n| TYPE | REFERENCE       |\n+------+-----------------+\n| v    | (this document) |\n| g    | (this document) |\n| h    | (this document) |\n| k    | (this document) |\n| n    | (this document) |\n| p    | (this document) |\n| s    | (this document) |\n| t    | (this document) |\n+------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "DKIM _domainkey DNS TXT Record Tag Specification Registry Initial Values",
      "ja": "DKIM _domainkey DNS TXTレコードタグの仕様レジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.5. DKIM Key Type Registry",
      "section_title": true,
      "ja": "7.5. DKIMキータイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"k=\" <key-k-tag> (specified in Section 3.6.1) and the \"a=\" <sig-a-tag-k> (specified in Section 3.5) tags provide for a list of mechanisms that can be used to decode a DKIM signature.",
      "ja": "\"k =\" <key-k-tag>（セクション3.6.1で指定）および \"a =\" <sig-a-tag-k>（セクション3.5で指定）タグは、次のことができるメカニズムのリストを提供しますDKIM署名のデコードに使用できます。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM Key Type Registry for such mechanisms.",
      "ja": "IANAは、そのようなメカニズムのためのDKIMキータイプレジストリを確立しています。"
    },
    {
      "indent": 15,
      "text": "The initial entry in the registry comprises:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 27,
      "text": "+------+-----------+\n| TYPE | REFERENCE |\n+------+-----------+\n| rsa  | [RFC3447] |\n+------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "DKIM Key Type Initial Values",
      "ja": "DKIMキータイプの初期値"
    },
    {
      "indent": 0,
      "text": "7.6. DKIM Hash Algorithms Registry",
      "section_title": true,
      "ja": "7.6. DKIMハッシュアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"h=\" <key-h-tag> (specified in Section 3.6.1) and the \"a=\" <sig-a-tag-h> (specified in Section 3.5) tags provide for a list of mechanisms that can be used to produce a digest of message data.",
      "ja": "\"h =\" <key-h-tag>（セクション3.6.1で指定）および \"a =\" <sig-a-tag-h>（セクション3.5で指定）タグは、次のことができるメカニズムのリストを提供しますメッセージデータのダイジェストを作成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM Hash Algorithms Registry for such mechanisms.",
      "ja": "IANAは、そのようなメカニズムのためにDKIMハッシュアルゴリズムレジストリを確立しています。"
    },
    {
      "indent": 15,
      "text": "The initial entries in the registry comprise:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+--------+-------------------+\n| TYPE   | REFERENCE         |\n+--------+-------------------+\n| sha1   | [FIPS.180-2.2002] |\n| sha256 | [FIPS.180-2.2002] |\n+--------+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "DKIM Hash Algorithms Initial Values",
      "ja": "DKIMハッシュアルゴリズムの初期値"
    },
    {
      "indent": 0,
      "text": "7.7. DKIM Service Types Registry",
      "section_title": true,
      "ja": "7.7. DKIMサービスタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"s=\" <key-s-tag> tag (specified in Section 3.6.1) provides for a list of service types to which this selector may apply.",
      "ja": "\"s =\" <key-s-tag>タグ（3.6.1で指定）は、このセレクターが適用されるサービスタイプのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM Service Types Registry for service types.",
      "ja": "IANAは、サービスタイプ用のDKIMサービスタイプレジストリを確立しています。"
    },
    {
      "indent": 15,
      "text": "The initial entries in the registry comprise:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 24,
      "text": "+-------+-----------------+\n| TYPE  | REFERENCE       |\n+-------+-----------------+\n| email | (this document) |\n| *     | (this document) |\n+-------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "DKIM Service Types Registry Initial Values",
      "ja": "DKIMサービスタイプレジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.8. DKIM Selector Flags Registry",
      "section_title": true,
      "ja": "7.8. DKIMセレクタフラグレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"t=\" <key-t-tag> tag (specified in Section 3.6.1) provides for a list of flags to modify interpretation of the selector.",
      "ja": "\"t =\" <key-t-tag>タグ（3.6.1で指定）は、セレクターの解釈を変更するためのフラグのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the DKIM Selector Flags Registry for additional flags.",
      "ja": "IANAは、追加のフラグ用にDKIMセレクタフラグレジストリを確立しました。"
    },
    {
      "indent": 15,
      "text": "The initial entries in the registry comprise:",
      "ja": "レジストリの最初のエントリは次のとおりです。"
    },
    {
      "indent": 24,
      "text": "+------+-----------------+\n| TYPE | REFERENCE       |\n+------+-----------------+\n| y    | (this document) |\n| s    | (this document) |\n+------+-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "DKIM Selector Flags Registry Initial Values",
      "ja": "DKIMセレクターフラグレジストリの初期値"
    },
    {
      "indent": 0,
      "text": "7.9. DKIM-Signature Header Field",
      "section_title": true,
      "ja": "7.9. DKIM-Signatureヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "IANA has added DKIM-Signature to the \"Permanent Message Header Fields\" registry (see [RFC3864]) for the \"mail\" protocol, using this document as the reference.",
      "ja": "IANAは、このドキュメントを参照として使用して、「メール」プロトコル用の「Permanent Message Header Fields」レジストリ（[RFC3864]を参照）にDKIM-Signatureを追加しました。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "It has been observed that any mechanism that is introduced that attempts to stem the flow of spam is subject to intensive attack. DKIM needs to be carefully scrutinized to identify potential attack vectors and the vulnerability to each. See also [RFC4686].",
      "ja": "スパムの流れを食い止めようとするメカニズムが導入されると、集中的な攻撃の対象となることが確認されています。 DKIMは、潜在的な攻撃ベクトルとそれぞれに対する脆弱性を特定するために慎重に精査される必要があります。 [RFC4686]も参照してください。"
    },
    {
      "indent": 0,
      "text": "8.1. Misuse of Body Length Limits (\"l=\" Tag)",
      "section_title": true,
      "ja": "8.1. 本文の長さ制限の誤用（ \"l =\"タグ）"
    },
    {
      "indent": 3,
      "text": "Body length limits (in the form of the \"l=\" tag) are subject to several potential attacks.",
      "ja": "ボディの長さの制限（ \"l =\"タグの形式）は、いくつかの潜在的な攻撃の影響を受けます。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Addition of New MIME Parts to Multipart/*",
      "section_title": true,
      "ja": "8.1.1. Multipart / *への新しいMIMEパーツの追加"
    },
    {
      "indent": 3,
      "text": "If the body length limit does not cover a closing MIME multipart section (including the trailing \"--CRLF\" portion), then it is possible for an attacker to intercept a properly signed multipart message and add a new body part. Depending on the details of the MIME type and the implementation of the verifying MTA and the receiving MUA, this could allow an attacker to change the information displayed to an end user from an apparently trusted source.",
      "ja": "本文の長さの制限が終了MIMEマルチパートセクション（末尾の「--CRLF」部分を含む）をカバーしていない場合、攻撃者が適切に署名されたマルチパートメッセージを傍受し、新しい本文部分を追加する可能性があります。 MIMEタイプの詳細、および検証MTAと受信MUAの実装に応じて、これにより、攻撃者はエンドユーザーに表示される情報を、明らかに信頼できるソースから変更する可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, if attackers can append information to a \"text/html\" body part, they may be able to exploit a bug in some MUAs that continue to read after a \"</html>\" marker, and thus display HTML text on top of already displayed text. If a message has a \"multipart/alternative\" body part, they might be able to add a new body part that is preferred by the displaying MUA.",
      "ja": "たとえば、攻撃者が「text / html」ボディパーツに情報を追加できる場合、「</ html>」マーカーの後に読み取りを続ける一部のMUAのバグを悪用して、HTMLテキストを上部に表示できる可能性があります。すでに表示されているテキストの。メッセージに「マルチパート/代替」の本文部分がある場合、表示するMUAが優先する新しい本文部分を追加できる場合があります。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Addition of new HTML content to existing content",
      "section_title": true,
      "ja": "8.1.2. 既存のコンテンツへの新しいHTMLコンテンツの追加"
    },
    {
      "indent": 3,
      "text": "Several receiving MUA implementations do not cease display after a \"\"</html>\"\" tag. In particular, this allows attacks involving overlaying images on top of existing text.",
      "ja": "いくつかの受信MUA実装は、 \"\" </ html> \"\"タグの後に表示を停止しません。特に、これにより、既存のテキストの上に画像をオーバーレイする攻撃が可能になります。"
    },
    {
      "indent": 3,
      "text": "   INFORMATIVE EXAMPLE: Appending the following text to an existing,\n   properly closed message will in many MUAs result in inappropriate\n   data being rendered on top of existing, correct data:\n<div style=\"position: relative; bottom: 350px; z-index: 2;\">\n<img src=\"http://www.ietf.org/images/ietflogo2e.gif\"\n  width=578 height=370>\n</div>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Misappropriated Private Key",
      "section_title": true,
      "ja": "8.2. 横領した秘密鍵"
    },
    {
      "indent": 3,
      "text": "If the private key for a user is resident on their computer and is not protected by an appropriately secure mechanism, it is possible for malware to send mail as that user and any other user sharing the same private key. The malware would not, however, be able to generate signed spoofs of other signers' addresses, which would aid in identification of the infected user and would limit the possibilities for certain types of attacks involving socially engineered messages. This threat applies mainly to MUA-based implementations; protection of private keys on servers can be easily achieved through the use of specialized cryptographic hardware.",
      "ja": "ユーザーの秘密キーがコンピューター上にあり、適切に安全なメカニズムによって保護されていない場合、マルウェアはそのユーザーと同じ秘密キーを共有する他のユーザーとしてメールを送信することができます。ただし、マルウェアは他の署名者のアドレスの署名されたなりすましを生成できず、感染したユーザーの特定に役立ち、ソーシャルエンジニアリングされたメッセージを含む特定の種類の攻撃の可能性を制限します。この脅威は主にMUAベースの実装に適用されます。サーバー上の秘密鍵の保護は、専用の暗号化ハードウェアを使用して簡単に実現できます。"
    },
    {
      "indent": 3,
      "text": "A larger problem occurs if malware on many users' computers obtains the private keys for those users and transmits them via a covert channel to a site where they can be shared. The compromised users would likely not know of the misappropriation until they receive \"bounce\" messages from messages they are purported to have sent. Many users might not understand the significance of these bounce messages and would not take action.",
      "ja": "多くのユーザーのコンピューター上のマルウェアがそれらのユーザーの秘密キーを取得し、それらを秘密チャネルを介して共有できるサイトに送信すると、より大きな問題が発生します。侵害されたユーザーは、自分が送信したとされるメッセージから「バウンス」メッセージを受信するまで、その横領を知らない可能性があります。多くのユーザーは、これらのバウンスメッセージの重要性を理解していない可能性があり、アクションを実行しません。"
    },
    {
      "indent": 0,
      "text": " One countermeasure is to use a user-entered passphrase to encrypt the private key, although users tend to choose weak passphrases and often reuse them for different purposes, possibly allowing an attack against DKIM to be extended into other domains. Nevertheless, the decoded private key might be briefly available to compromise by malware when it is entered, or might be discovered via keystroke logging. The added complexity of entering a passphrase each time one sends a message would also tend to discourage the use of a secure passphrase.",
      "ja": "対策の1つは、ユーザーが入力したパスフレーズを使用して秘密鍵を暗号化することです。ただし、ユーザーは弱いパスフレーズを選択し、さまざまな目的で再利用する傾向があるため、DKIMに対する攻撃が他のドメインに拡大される可能性があります。それにもかかわらず、復号化された秘密鍵は、入力されるとマルウェアによって簡単に侵害されたり、キーストロークロギングによって発見されたりする可能性があります。メッセージを送信するたびにパスフレーズを入力するという複雑さが加わると、安全なパスフレーズの使用が妨げられる傾向があります。"
    },
    {
      "indent": 3,
      "text": "A somewhat more effective countermeasure is to send messages through an outgoing MTA that can authenticate the submitter using existing techniques (e.g., SMTP Authentication), possibly validate the message itself (e.g., verify that the header is legitimate and that the content passes a spam content check), and sign the message using a key appropriate for the submitter address. Such an MTA can also apply controls on the volume of outgoing mail each user is permitted to originate in order to further limit the ability of malware to generate bulk email.",
      "ja": "もう少し効果的な対策は、既存の手法（SMTP認証など）を使用して送信者を認証できる発信MTAを介してメッセージを送信し、メッセージ自体を検証する（ヘッダーが正当であり、コンテンツがスパムコンテンツを通過することを確認する）ことです。チェック）、送信者のアドレスに適したキーを使用してメッセージに署名します。このようなMTAは、マルウェアがバルクメールを生成する機能をさらに制限するために、各ユーザーが発信を許可されている送信メールの量に制御を適用することもできます。"
    },
    {
      "indent": 0,
      "text": "8.3. Key Server Denial-of-Service Attacks",
      "section_title": true,
      "ja": "8.3. 鍵サーバーのサービス拒否攻撃"
    },
    {
      "indent": 3,
      "text": "Since the key servers are distributed (potentially separate for each domain), the number of servers that would need to be attacked to defeat this mechanism on an Internet-wide basis is very large. Nevertheless, key servers for individual domains could be attacked, impeding the verification of messages from that domain. This is not significantly different from the ability of an attacker to deny service to the mail exchangers for a given domain, although it affects outgoing, not incoming, mail.",
      "ja": "キーサーバーは分散されている（ドメインごとに分離している可能性がある）ため、インターネット全体でこのメカニズムを無効にするために攻撃する必要があるサーバーの数は非常に多くなります。それでも、個々のドメインのキーサーバーが攻撃され、そのドメインからのメッセージの検証が妨害される可能性があります。これは、攻撃者が特定のドメインのメールエクスチェンジャーへのサービスを拒否する能力と大きな違いはありませんが、受信メールではなく送信メールに影響します。"
    },
    {
      "indent": 3,
      "text": "A variation on this attack is that if a very large amount of mail were to be sent using spoofed addresses from a given domain, the key servers for that domain could be overwhelmed with requests. However, given the low overhead of verification compared with handling of the email message itself, such an attack would be difficult to mount.",
      "ja": "この攻撃のバリエーションは、特定のドメインからスプーフィングされたアドレスを使用して大量のメールが送信される場合、そのドメインのキーサーバーが要求で圧倒される可能性があることです。ただし、電子メールメッセージ自体の処理に比べて検証のオーバーヘッドが低いため、このような攻撃を仕掛けるのは困難です。"
    },
    {
      "indent": 0,
      "text": "8.4. Attacks Against the DNS",
      "section_title": true,
      "ja": "8.4. DNSに対する攻撃"
    },
    {
      "indent": 3,
      "text": "Since the DNS is a required binding for key services, specific attacks against the DNS must be considered.",
      "ja": "DNSは主要なサービスに必要なバインディングであるため、DNSに対する特定の攻撃を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "While the DNS is currently insecure [RFC3833], these security problems are the motivation behind DNS Security (DNSSEC) [RFC4033], and all users of the DNS will reap the benefit of that work.",
      "ja": "DNSは現在安全ではありませんが[RFC3833]、これらのセキュリティ問題はDNSセキュリティ（DNSSEC）[RFC4033]の背後にある動機であり、DNSのすべてのユーザーはその作業の利益を享受します。"
    },
    {
      "indent": 3,
      "text": "DKIM is only intended as a \"sufficient\" method of proving authenticity. It is not intended to provide strong cryptographic proof about authorship or contents. Other technologies such as OpenPGP [RFC2440] and S/MIME [RFC3851] address those requirements.",
      "ja": "DKIMは、信頼性を証明する「十分な」方法としてのみ意図されています。著者やコンテンツに関する強力な暗号証明を提供することを意図したものではありません。 OpenPGP [RFC2440]やS / MIME [RFC3851]などの他のテクノロジーは、これらの要件に対応しています。"
    },
    {
      "indent": 0,
      "text": " A second security issue related to the DNS revolves around the increased DNS traffic as a consequence of fetching selector-based data as well as fetching signing domain policy. Widespread deployment of DKIM will result in a significant increase in DNS queries to the claimed signing domain. In the case of forgeries on a large scale, DNS servers could see a substantial increase in queries.",
      "ja": "DNSに関連する2番目のセキュリティ問題は、セレクターベースのデータのフェッチと署名ドメインポリシーのフェッチの結果として増加したDNSトラフィックに関係しています。 DKIMの広範な展開により、要求された署名ドメインへのDNSクエリが大幅に増加します。大規模な偽造の場合、DNSサーバーではクエリが大幅に増加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A specific DNS security issue that should be considered by DKIM verifiers is the name chaining attack described in Section 2.3 of the DNS Threat Analysis [RFC3833]. A DKIM verifier, while verifying a DKIM-Signature header field, could be prompted to retrieve a key record of an attacker's choosing. This threat can be minimized by ensuring that name servers, including recursive name servers, used by the verifier enforce strict checking of \"glue\" and other additional information in DNS responses and are therefore not vulnerable to this attack.",
      "ja": "DKIM検証者が考慮すべき特定のDNSセキュリティ問題は、DNS脅威分析[RFC3833]のセクション2.3で説明されている名前連鎖攻撃です。 DKIM検証者は、DKIM-Signatureヘッダーフィールドの検証中に、攻撃者が選択した主要なレコードを取得するように要求される可能性があります。ベリファイアが使用するネームサーバー（再帰的なネームサーバーを含む）がDNS応答の「接着剤」およびその他の追加情報の厳密なチェックを実施し、したがってこの攻撃に対して脆弱ではないことを確実にすることで、この脅威を最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": "8.5. Replay Attacks",
      "section_title": true,
      "ja": "8.5. リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "In this attack, a spammer sends a message to be spammed to an accomplice, which results in the message being signed by the originating MTA. The accomplice resends the message, including the original signature, to a large number of recipients, possibly by sending the message to many compromised machines that act as MTAs. The messages, not having been modified by the accomplice, have valid signatures.",
      "ja": "この攻撃では、スパマーがスパムの対象となるメッセージを共犯者に送信します。これにより、メッセージは元のMTAによって署名されます。共犯者は、MTAとして機能する多くの侵害されたマシンにメッセージを送信することにより、元の署名を含むメッセージを多数の受信者に再送信します。共犯者によって変更されていないメッセージには、有効な署名があります。"
    },
    {
      "indent": 3,
      "text": "Partial solutions to this problem involve the use of reputation services to convey the fact that the specific email address is being used for spam and that messages from that signer are likely to be spam. This requires a real-time detection mechanism in order to react quickly enough. However, such measures might be prone to abuse, if for example an attacker resent a large number of messages received from a victim in order to make them appear to be a spammer.",
      "ja": "この問題の部分的な解決策には、特定の電子メールアドレスがスパムに使用されており、その署名者からのメッセージがスパムである可能性が高いという事実を伝えるレピュテーションサービスの使用が含まれます。これには、十分に迅速に反応するために、リアルタイムの検出メカニズムが必要です。ただし、たとえば攻撃者が被害者から受け取った大量のメッセージを再送してスパマーのように見せかけた場合、このような対策は悪用される傾向があります。"
    },
    {
      "indent": 3,
      "text": "Large verifiers might be able to detect unusually large volumes of mails with the same signature in a short time period. Smaller verifiers can get substantially the same volume of information via existing collaborative systems.",
      "ja": "大規模な検証者は、同じ署名を持つ非常に大量のメールを短時間で検出できる可能性があります。小規模な検証者は、既存のコラボレーションシステムを介して、ほぼ同じ量の情報を取得できます。"
    },
    {
      "indent": 0,
      "text": "8.6. Limits on Revoking Keys",
      "section_title": true,
      "ja": "8.6. キーの取り消しの制限"
    },
    {
      "indent": 3,
      "text": "When a large domain detects undesirable behavior on the part of one of its users, it might wish to revoke the key used to sign that user's messages in order to disavow responsibility for messages that have not yet been verified or that are the subject of a replay attack. However, the ability of the domain to do so can be limited if the same key, for scalability reasons, is used to sign messages for many other users. Mechanisms for explicitly revoking keys on a per-address basis have been proposed but require further study as to their utility and the DNS load they represent.",
      "ja": "大規模なドメインがユーザーのいずれかの側で望ましくない動作を検出した場合、そのユーザーのメッセージに署名するために使用されたキーを取り消して、まだ確認されていないメッセージまたは再生の対象であるメッセージの責任を否認することができます。攻撃。ただし、スケーラビリティの理由から、同じキーを使用して他の多くのユーザーのメッセージに署名する場合、ドメインの機能が制限される可能性があります。アドレスごとにキーを明示的に取り消すメカニズムが提案されていますが、それらのユーティリティとそれらが表すDNS負荷については、さらに調査が必要です。"
    },
    {
      "indent": 0,
      "text": "8.7. Intentionally Malformed Key Records",
      "section_title": true,
      "ja": "8.7. 意図的に不正な形式のキーレコード"
    },
    {
      "indent": 3,
      "text": "It is possible for an attacker to publish key records in DNS that are intentionally malformed, with the intent of causing a denial-of-service attack on a non-robust verifier implementation. The attacker could then cause a verifier to read the malformed key record by sending a message to one of its users referencing the malformed record in a (not necessarily valid) signature. Verifiers MUST thoroughly verify all key records retrieved from the DNS and be robust against intentionally as well as unintentionally malformed key records.",
      "ja": "攻撃者は、非ロバストな検証機能の実装にサービス拒否攻撃を仕掛けることを目的として、意図的に不正な形式のキーレコードをDNSに公開する可能性があります。次に、攻撃者は検証者に、（必ずしも有効ではない）署名の不正な形式のレコードを参照しているユーザーの1人にメッセージを送信することにより、不正な形式のキーレコードを読み取らせることができます。検証者は、DNSから取得したすべてのキーレコードを徹底的に検証し、意図的または意図的でない不正なキーレコードに対して堅牢でなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.8. Intentionally Malformed DKIM-Signature Header Fields",
      "section_title": true,
      "ja": "8.8. 意図的に不正な形式のDKIM-Signatureヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST be prepared to receive messages with malformed DKIM-Signature header fields, and thoroughly verify the header field before depending on any of its contents.",
      "ja": "検証者は、不正な形式のDKIM-Signatureヘッダーフィールドを含むメッセージを受信し、その内容に依存する前にヘッダーフィールドを完全に検証できるように準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.9. Information Leakage",
      "section_title": true,
      "ja": "8.9. 情報漏えい"
    },
    {
      "indent": 3,
      "text": "An attacker could determine when a particular signature was verified by using a per-message selector and then monitoring their DNS traffic for the key lookup. This would act as the equivalent of a \"web bug\" for verification time rather than when the message was read.",
      "ja": "攻撃者は、メッセージごとのセレクターを使用して特定の署名がいつ検証されたかを判断し、DNSトラフィックを監視してキーを検索する可能性があります。これは、メッセージが読み取られたときではなく、検証時に「Webバグ」に相当するものとして機能します。"
    },
    {
      "indent": 0,
      "text": "8.10. Remote Timing Attacks",
      "section_title": true,
      "ja": "8.10. リモートタイミング攻撃"
    },
    {
      "indent": 3,
      "text": "In some cases, it may be possible to extract private keys using a remote timing attack [BONEH03]. Implementations should consider obfuscating the timing to prevent such attacks.",
      "ja": "場合によっては、リモートタイミング攻撃[BONEH03]を使用して秘密鍵を抽出できる可能性があります。実装では、このような攻撃を防ぐためにタイミングを難読化することを検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.11. Reordered Header Fields",
      "section_title": true,
      "ja": "8.11. 並べ替えられたヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "Existing standards allow intermediate MTAs to reorder header fields. If a signer signs two or more header fields of the same name, this can cause spurious verification errors on otherwise legitimate messages. In particular, signers that sign any existing DKIM-Signature fields run the risk of having messages incorrectly fail to verify.",
      "ja": "既存の標準では、中間MTAがヘッダーフィールドを並べ替えることができます。署名者が同じ名前の2つ以上のヘッダーフィールドに署名すると、正当なメッセージで偽の検証エラーが発生する可能性があります。特に、既存のDKIM-Signatureフィールドに署名する署名者は、メッセージの検証が誤って失敗するリスクを負います。"
    },
    {
      "indent": 0,
      "text": "8.12. RSA Attacks",
      "section_title": true,
      "ja": "8.12. RSA攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker could create a large RSA signing key with a small exponent, thus requiring that the verification key have a large exponent. This will force verifiers to use considerable computing resources to verify the signature. Verifiers might avoid this attack by refusing to verify signatures that reference selectors with public keys having unreasonable exponents.",
      "ja": "攻撃者は小さな指数で大きなRSA署名鍵を作成する可能性があるため、検証鍵には大きな指数が必要です。これにより、検証者はかなりのコンピューティングリソースを使用して署名を検証する必要があります。検証者は、不当な指数を持つ公開鍵でセレクターを参照する署名の検証を拒否することにより、この攻撃を回避する可能性があります。"
    },
    {
      "indent": 3,
      "text": "In general, an attacker might try to overwhelm a verifier by flooding it with messages requiring verification. This is similar to other MTA denial-of-service attacks and should be dealt with in a similar fashion.",
      "ja": "一般に、攻撃者は検証を必要とするメッセージで検証をあふれさせて、検証を圧倒しようとする可能性があります。これは他のMTAサービス拒否攻撃に似ており、同様の方法で対処する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.13. Inappropriate Signing by Parent Domains",
      "section_title": true,
      "ja": "8.13. 親ドメインによる不適切な署名"
    },
    {
      "indent": 3,
      "text": "The trust relationship described in Section 3.8 could conceivably be used by a parent domain to sign messages with identities in a subdomain not administratively related to the parent. For example, the \".com\" registry could create messages with signatures using an \"i=\" value in the example.com domain. There is no general solution to this problem, since the administrative cut could occur anywhere in the domain name. For example, in the domain \"example.podunk.ca.us\" there are three administrative cuts (podunk.ca.us, ca.us, and us), any of which could create messages with an identity in the full domain.",
      "ja": "セクション3.8で説明されている信頼関係は、親ドメインに管理上関連していないサブドメイン内のIDでメッセージに署名するために親ドメインで使用される可能性があります。たとえば、「。com」レジストリは、example.comドメインの「i =」値を使用して署名付きのメッセージを作成できます。管理上のカットはドメイン名の任意の場所で発生する可能性があるため、この問題に対する一般的な解決策はありません。たとえば、ドメイン「example.podunk.ca.us」には、3つの管理カット（podunk.ca.us、ca.us、およびus）があり、いずれも完全なドメインでIDを持つメッセージを作成する可能性があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: This is considered an acceptable risk for the same reason that it is acceptable for domain delegation. For example, in the example above any of the domains could potentially simply delegate \"example.podunk.ca.us\" to a server of their choice and completely replace all DNS-served information. Note that a verifier MAY ignore signatures that come from an unlikely domain such as \".com\", as discussed in Section 6.1.1.",
      "ja": "有益なメモ：これは、ドメインの委任で許容されるのと同じ理由で許容可能なリスクと見なされます。たとえば、上記の例では、任意のドメインが「example.podunk.ca.us」を選択したサーバーに単に委任し、DNSが提供するすべての情報を完全に置き換える可能性があります。ベリファイアは、セクション6.1.1で説明されているように、「。com」などのありそうもないドメインからの署名を無視してもよいことに注意してください。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[FIPS.180-2.2002] U.S. Department of Commerce, \"Secure Hash Standard\", FIPS PUB 180-2, August 2002.",
      "ja": "[FIPS.180-2.2002]米国商務省、「Secure Hash Standard」、FIPS PUB 180-2、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[ITU.X660.1997] \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.660, 1997.",
      "ja": "[ITU.X660.1997]「情報技術-ASN.1エンコーディングルール：Basic Encoding Rules（BER）、Canonical Encoding Rules（CER）and Distinguished Encoding Rules（DER）」、ITU-T勧告X.660、1997 。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[RFC2045] Freed、N。およびN. Borenstein、「Multipurpose Internet Mail Extensions（MIME）Part One：Format of Internet Message Bodies」、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2047] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part Three: Message header field Extensions for Non-ASCII Text\", RFC 2047, November 1996.",
      "ja": "[RFC2047] Moore、K。、「MIME（Multipurpose Internet Mail Extensions）Part Three：Message header field Extensions for Non-ASCII Text」、RFC 2047、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2821] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 2821, April 2001.",
      "ja": "[RFC2821] Klensin、J。、「Simple Mail Transfer Protocol」、RFC 2821、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2822] Resnick, P., \"Internet Message Format\", RFC 2822, April 2001.",
      "ja": "[RFC2822] Resnick、P。、「インターネットメッセージ形式」、RFC 2822、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447] Jonsson、J。およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[RFC3490] Faltstrom、P.、Hoffman、P。、およびA. Costello、「Internationalizing Domain Names in Applications（IDNA）」、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 4234, October 2005.",
      "ja": "[RFC4234]クロッカー、D。、エド。およびP. Overell、「構文仕様の拡張BNF：ABNF」、RFC 4234、2005年10月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BONEH03] Proc. 12th USENIX Security Symposium, \"Remote Timing Attacks are Practical\", 2003.",
      "ja": "[BONEH03] Proc。第12回USENIXセキュリティシンポジウム、「リモートタイミング攻撃は実用的」、2003年。"
    },
    {
      "indent": 3,
      "text": "[RFC1847] Galvin, J., Murphy, S., Crocker, S., and N. Freed, \"Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\", RFC 1847, October 1995.",
      "ja": "[RFC1847] Galvin、J.、Murphy、S.、Crocker、S。、およびN. Freed、「MIMEのセキュリティマルチパート：Multipart / SignedおよびMultipart / Encrypted」、RFC 1847、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2440] Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, \"OpenPGP Message Format\", RFC 2440, November 1998.",
      "ja": "[RFC2440] Callas、J.、Donnerhacke、L.、Finney、H。、およびR. Thayer、「OpenPGP Message Format」、RFC 2440、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3766] Orman, H. and P. Hoffman, \"Determining Strengths for Public Keys Used For Exchanging Symmetric Keys\", RFC 3766, April 2004.",
      "ja": "[RFC3766] Orman、H。およびP. Hoffman、「Determining Strengths for Public Keys Exchangeing Symmetric Keys」、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3833] Atkins, D. and R. Austein, \"Threat Analysis of the Domain Name System (DNS)\", RFC 3833, August 2004.",
      "ja": "[RFC3833] Atkins、D。およびR. Austein、「ドメインネームシステム（DNS）の脅威分析」、RFC 3833、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3851] Ramsdell, B., \"S/MIME Version 3 Message Specification\", RFC 3851, June 1999.",
      "ja": "[RFC3851] Ramsdell、B。、「S / MIME Version 3 Message Specification」、RFC 3851、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3864] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, September 2004.",
      "ja": "[RFC3864] Klyne、G.、Nottingham、M。、およびJ. Mogul、「メッセージヘッダーフィールドの登録手順」、BCP 90、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033] Arends、R.、Austein、R.、Larson、M.、Massey、D。、およびS. Rose、「DNSセキュリティの概要と要件」、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4686] Fenton, J., \"Analysis of Threats Motivating DomainKeys Identified Mail (DKIM)\", RFC 4686, September 2006.",
      "ja": "[RFC4686] Fenton、J。、「Analysis of Motivating DomainKeys Identified Mail（DKIM）」、RFC 4686、2006年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4870] Delany, M., \"Domain-Based Email Authentication Using Public Keys Advertised in the DNS (DomainKeys)\", RFC 4870, May 2007.",
      "ja": "[RFC4870] Delany、M。、「DNSでアドバタイズされた公開鍵を使用したドメインベースの電子メール認証（DomainKeys）」、RFC 4870、2007年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example of Use (INFORMATIVE)",
      "ja": "付録A.使用例（参考）"
    },
    {
      "indent": 3,
      "text": "This section shows the complete flow of an email from submission to final delivery, demonstrating how the various components fit together. The key used in this example is shown in Appendix C.",
      "ja": "このセクションでは、送信から最終配信までの電子メールの完全なフローを示し、さまざまなコンポーネントがどのように組み合わされるかを示します。この例で使用されているキーは、付録Cに示されています。"
    },
    {
      "indent": 0,
      "text": "A.1. The User Composes an Email",
      "section_title": true,
      "ja": "A.1. ユーザーがメールを作成する"
    },
    {
      "indent": 3,
      "text": "From: Joe SixPack <joe@football.example.com>\nTo: Suzie Q <suzie@shopping.example.net>\nSubject: Is dinner ready?\nDate: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)\nMessage-ID: <20030712040037.46341.5F8J@football.example.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "ゲームに負けました。あなたはもうお腹が空いていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 0,
      "text": "A.2. The Email Is Signed",
      "section_title": true,
      "ja": "A.2. メールは署名されています"
    },
    {
      "indent": 3,
      "text": "This email is signed by the example.com outbound email server and now looks like this:",
      "ja": "この電子メールはexample.com送信電子メールサーバーによって署名され、次のようになります。"
    },
    {
      "indent": 3,
      "text": "DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;\n      c=simple/simple; q=dns/txt; i=joe@football.example.com;\n      h=Received : From : To : Subject : Date : Message-ID;\n      bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;\n      b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB\n        4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut\n        KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV\n        4bmp/YzhwvcubU4=;\nReceived: from client1.football.example.com  [192.0.2.1]\n      by submitserver.example.com with SUBMISSION;\n      Fri, 11 Jul 2003 21:01:54 -0700 (PDT)\nFrom: Joe SixPack <joe@football.example.com>\nTo: Suzie Q <suzie@shopping.example.net>\nSubject: Is dinner ready?\nDate: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)\nMessage-ID: <20030712040037.46341.5F8J@football.example.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "ゲームに負けました。あなたはもうお腹が空いていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 3,
      "text": "The signing email server requires access to the private key associated with the \"brisbane\" selector to generate this signature.",
      "ja": "署名電子メールサーバーは、この署名を生成するために、「ブリスベン」セレクターに関連付けられた秘密鍵にアクセスする必要があります。"
    },
    {
      "indent": 0,
      "text": "A.3. The Email Signature Is Verified",
      "section_title": true,
      "ja": "A.3. メールの署名が確認されました"
    },
    {
      "indent": 3,
      "text": "The signature is normally verified by an inbound SMTP server or possibly the final delivery agent. However, intervening MTAs can also perform this verification if they choose to do so. The verification process uses the domain \"example.com\" extracted from the \"d=\" tag and the selector \"brisbane\" from the \"s=\" tag in the DKIM-Signature header field to form the DNS DKIM query for:",
      "ja": "署名は通常、受信SMTPサーバーまたは場合によっては最終的な配信エージェントによって検証されます。ただし、介入するMTAも、必要に応じてこの検証を実行できます。検証プロセスでは、「d =」タグから抽出されたドメイン「example.com」と、DKIM-Signatureヘッダーフィールドの「s =」タグからセレクタ「brisbane」を使用して、次のDNS DKIMクエリを作成します。"
    },
    {
      "indent": 3,
      "text": "brisbane._domainkey.example.com",
      "ja": "ｂりｓばね。＿どまいんけｙ。えぁｍｐぇ。こｍ"
    },
    {
      "indent": 0,
      "text": " Signature verification starts with the physically last Received header field, the From header field, and so forth, in the order listed in the \"h=\" tag. Verification follows with a single CRLF followed by the body (starting with \"Hi.\"). The email is canonically prepared for verifying with the \"simple\" method. The result of the query and subsequent verification of the signature is stored (in this example) in the X-Authentication-Results header field line. After successful verification, the email looks like this:",
      "ja": "署名検証は、物理的に最後のReceivedヘッダーフィールド、Fromヘッダーフィールドなどから始まり、「h =」タグにリストされている順序で行われます。検証は、単一のCRLFに続いて本文が続きます（「Hi。」で始まります）。電子メールは、「単純な」方法で検証するために標準的に準備されています。クエリの結果とその後の署名の検証は（この例では）X-Authentication-Resultsヘッダーフィールド行に格納されます。確認が完了すると、メールは次のようになります。"
    },
    {
      "indent": 3,
      "text": "X-Authentication-Results: shopping.example.net\n      header.from=joe@football.example.com; dkim=pass\nReceived: from mout23.football.example.com (192.168.1.1)\n      by shopping.example.net with SMTP;\n      Fri, 11 Jul 2003 21:01:59 -0700 (PDT)\nDKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;\n      c=simple/simple; q=dns/txt; i=joe@football.example.com;\n      h=Received : From : To : Subject : Date : Message-ID;\n      bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;\n      b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB\n        4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut\n        KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV\n        4bmp/YzhwvcubU4=;\nReceived: from client1.football.example.com  [192.0.2.1]\n      by submitserver.example.com with SUBMISSION;\n      Fri, 11 Jul 2003 21:01:54 -0700 (PDT)\nFrom: Joe SixPack <joe@football.example.com>\nTo: Suzie Q <suzie@shopping.example.net>\nSubject: Is dinner ready?\nDate: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)\nMessage-ID: <20030712040037.46341.5F8J@football.example.com>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "ゲームに負けました。あなたはもうお腹が空いていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Usage Examples (INFORMATIVE)",
      "ja": "付録B.使用例（参考）"
    },
    {
      "indent": 3,
      "text": "DKIM signing and validating can be used in different ways, for different operational scenarios. This Appendix discusses some common examples.",
      "ja": "DKIMの署名と検証は、さまざまな運用シナリオでさまざまな方法で使用できます。この付録では、いくつかの一般的な例について説明します。"
    },
    {
      "indent": 6,
      "text": "NOTE: Descriptions in this Appendix are for informational purposes only. They describe various ways that DKIM can be used, given particular constraints and needs. In no case are these examples intended to be taken as providing explanation or guidance concerning DKIM specification details, when creating an implementation.",
      "ja": "注：この付録の説明は、情報提供のみを目的としています。特定の制約とニーズを前提として、DKIMを使用できるさまざまな方法について説明します。これらの例は、実装を作成するときに、DKIM仕様の詳細に関する説明またはガイダンスを提供することを意図したものではありません。"
    },
    {
      "indent": 0,
      "text": "B.1. Alternate Submission Scenarios",
      "section_title": true,
      "ja": "B.1. 代替提出シナリオ"
    },
    {
      "indent": 3,
      "text": "In the most simple scenario, a user's MUA, MSA, and Internet (boundary) MTA are all within the same administrative environment, using the same domain name. Therefore, all of the components involved in submission and initial transfer are related. However, it is common for two or more of the components to be under independent administrative control. This creates challenges for choosing and administering the domain name to use for signing, and for its relationship to common email identity header fields.",
      "ja": "最も単純なシナリオでは、ユーザーのMUA、MSA、およびインターネット（境界）MTAはすべて、同じドメイン名を使用して同じ管理環境内にあります。したがって、提出と初期転送に関係するすべてのコンポーネントが関連しています。ただし、2つ以上のコンポーネントが独立した管理下にあることが一般的です。これにより、署名に使用するドメイン名の選択と管理、および一般的な電子メールIDヘッダーフィールドとの関係に課題が生じます。"
    },
    {
      "indent": 0,
      "text": "B.1.1. Delegated Business Functions",
      "section_title": true,
      "ja": "B.1.1. 委任されたビジネス機能"
    },
    {
      "indent": 3,
      "text": "Some organizations assign specific business functions to discrete groups, inside or outside the organization. The goal, then, is to authorize that group to sign some mail, but to constrain what signatures they can generate. DKIM selectors (the \"s=\" signature tag) and granularity (the \"g=\" key tag) facilitate this kind of restricted authorization. Examples of these outsourced business functions are legitimate email marketing providers and corporate benefits providers.",
      "ja": "一部の組織では、組織の内部または外部の個別のグループに特定のビジネス機能を割り当てています。目標は、そのグループに一部のメールへの署名を許可することですが、生成できる署名を制限することです。 DKIMセレクター（ \"s =\"署名タグ）と細分性（ \"g =\"キータグ）は、この種の制限付き認証を容易にします。これらの外部委託されたビジネス機能の例は、合法的な電子メールマーケティングプロバイダーや企業の福利厚生プロバイダーです。"
    },
    {
      "indent": 3,
      "text": "Here, the delegated group needs to be able to send messages that are signed, using the email domain of the client company. At the same time, the client often is reluctant to register a key for the provider that grants the ability to send messages for arbitrary addresses in the domain.",
      "ja": "ここで、委任されたグループは、クライアント企業の電子メールドメインを使用して、署名されたメッセージを送信できる必要があります。同時に、クライアントは多くの場合、ドメイン内の任意のアドレスにメッセージを送信する機能を付与するプロバイダーのキーを登録することに消極的です。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways to administer these usage scenarios. In one case, the client organization provides all of the public query service (for example, DNS) administration, and in another it uses DNS delegation to enable all ongoing administration of the DKIM key record by the delegated group.",
      "ja": "これらの使用シナリオを管理する方法は複数あります。 1つのケースでは、クライアント組織はすべてのパブリッククエリサービス（DNSなど）の管理を提供し、別のケースではDNS委任を使用して、委任されたグループによるDKIMキーレコードのすべての継続的な管理を有効にします。"
    },
    {
      "indent": 3,
      "text": "If the client organization retains responsibility for all of the DNS administration, the outsourcing company can generate a key pair, supplying the public key to the client company, which then registers it in the query service, using a unique selector that authorizes a specific From header field Local-part. For example, a client with the domain \"example.com\" could have the selector record specify \"g=winter-promotions\" so that this signature is only valid for mail with a From address of \"winter-promotions@example.com\". This would enable the provider to send messages using that specific address and have them verify properly. The client company retains control over the email address because it retains the ability to revoke the key at any time.",
      "ja": "クライアント組織がすべてのDNS管理の責任を負っている場合、アウトソーシング企業はキーペアを生成し、公開キーをクライアント企業に提供し、特定のFromヘッダーを承認する一意のセレクターを使用してクエリサービスに登録します。フィールドローカル部分。たとえば、ドメインが「example.com」のクライアントでは、セレクタレコードに「g = winter-promotions」を指定して、この署名がFromアドレスが「winter-promotions@example.com」のメールに対してのみ有効になるようにすることができます。これにより、プロバイダーはその特定のアドレスを使用してメッセージを送信し、適切に検証することができます。クライアント企業は、いつでもキーを取り消すことができるため、電子メールアドレスを制御できます。"
    },
    {
      "indent": 3,
      "text": "If the client wants the delegated group to do the DNS administration, it can have the domain name that is specified with the selector point to the provider's DNS server. The provider then creates and maintains all of the DKIM signature information for that selector. Hence, the client cannot provide constraints on the Local-part of addresses that get signed, but it can revoke the provider's signing rights by removing the DNS delegation record.",
      "ja": "クライアントが委任されたグループにDNS管理を実行することを望んでいる場合、プロバイダーのDNSサーバーへのセレクターポイントで指定されたドメイン名を持つことができます。次に、プロバイダーは、そのセレクターのすべてのDKIM署名情報を作成および保守します。したがって、クライアントは、署名されるアドレスのローカル部分に制約を提供できませんが、DNS委任レコードを削除することにより、プロバイダーの署名権限を取り消すことができます。"
    },
    {
      "indent": 0,
      "text": "B.1.2. PDAs and Similar Devices",
      "section_title": true,
      "ja": "B.1.2. PDAおよび類似のデバイス"
    },
    {
      "indent": 3,
      "text": "PDAs demonstrate the need for using multiple keys per domain. Suppose that John Doe wanted to be able to send messages using his corporate email address, jdoe@example.com, and his email device did not have the ability to make a Virtual Private Network (VPN) connection to the corporate network, either because the device is limited or because there are restrictions enforced by his Internet access provider. If the device was equipped with a private key registered for jdoe@example.com by the administrator of the example.com domain, and appropriate software to sign messages, John could sign the message on the device itself before transmission through the outgoing network of the access service provider.",
      "ja": "PDAは、ドメインごとに複数のキーを使用する必要性を示しています。 John Doeが会社のメールアドレスjdoe@example.comを使用してメッセージを送信できることを望んでおり、メールデバイスが会社のネットワークへの仮想プライベートネットワーク（VPN）接続を確立できなかったとします。デバイスが制限されている、または彼のインターネットアクセスプロバイダーによって実施される制限があるため。デバイスに、example.comドメインの管理者がjdoe@example.comに登録した秘密鍵と、メッセージに署名するための適切なソフトウェアが装備されている場合、Johnは、デバイスの発信ネットワークを介して送信する前に、デバイス自体でメッセージに署名できます。アクセスサービスプロバイダー。"
    },
    {
      "indent": 0,
      "text": "B.1.3. Roaming Users",
      "section_title": true,
      "ja": "B.1.3. ローミングユーザー"
    },
    {
      "indent": 3,
      "text": "Roaming users often find themselves in circumstances where it is convenient or necessary to use an SMTP server other than their home server; examples are conferences and many hotels. In such circumstances, a signature that is added by the submission service will use an identity that is different from the user's home system.",
      "ja": "ローミングユーザーは、ホームサーバー以外のSMTPサーバーを使用することが便利または必要な状況にいることがよくあります。例としては、会議や多くのホテルがあります。このような状況では、送信サービスによって追加された署名は、ユーザーのホームシステムとは異なるIDを使用します。"
    },
    {
      "indent": 3,
      "text": "Ideally, roaming users would connect back to their home server using either a VPN or a SUBMISSION server running with SMTP AUTHentication on port 587. If the signing can be performed on the roaming user's laptop, then they can sign before submission, although the risk of further modification is high. If neither of these are possible, these roaming users will not be able to send mail signed using their own domain key.",
      "ja": "理想的には、ローミングユーザーは、ポート587でSMTP AUTHenticationを使用して実行しているVPNまたはSUBMISSIONサーバーを使用してホームサーバーに接続します。ローミングユーザーのラップトップで署名を実行できる場合、提出前に署名できますが、さらなる変更は高いです。これらのいずれも可能でない場合、これらのローミングユーザーは、独自のドメインキーを使用して署名されたメールを送信できません。"
    },
    {
      "indent": 0,
      "text": "B.1.4. Independent (Kiosk) Message Submission",
      "section_title": true,
      "ja": "B.1.4. 独立した（キオスク）メッセージ送信"
    },
    {
      "indent": 0,
      "text": " Stand-alone services, such as walk-up kiosks and web-based information services, have no enduring email service relationship with the user, but users occasionally request that mail be sent on their behalf. For example, a website providing news often allows the reader to forward a copy of the article to a friend. This is typically done using the reader's own email address, to indicate who the author is. This is sometimes referred to as the \"Evite problem\", named after the website of the same name that allows a user to send invitations to friends.",
      "ja": "ウォークアップキオスクやWebベースの情報サービスなどのスタンドアロンサービスでは、ユーザーとの永続的な電子メールサービスの関係はありませんが、ユーザーがメールを送信するように要求することがあります。たとえば、ニュースを提供するWebサイトでは、読者が記事のコピーを友達に転送できることがよくあります。これは通常、作者が誰であるかを示すために、読者自身のメールアドレスを使用して行われます。これは、 \"Evite problem\"と呼ばれることもあります。これは、ユーザーが友達に招待状を送信できる同じ名前のWebサイトにちなんで名付けられました。"
    },
    {
      "indent": 3,
      "text": "A common way this is handled is to continue to put the reader's email address in the From header field of the message, but put an address owned by the email posting site into the Sender header field. The posting site can then sign the message, using the domain that is in the Sender field. This provides useful information to the receiving email site, which is able to correlate the signing domain with the initial submission email role.",
      "ja": "これが処理される一般的な方法は、引き続きメッセージのFromヘッダーフィールドにリーダーの電子メールアドレスを入力し、電子メール投稿サイトが所有するアドレスをSenderヘッダーフィールドに入力することです。投稿サイトは、送信者フィールドにあるドメインを使用してメッセージに署名できます。これにより、署名ドメインを最初の送信メールロールと関連付けることができる受信メールサイトに役立つ情報が提供されます。"
    },
    {
      "indent": 3,
      "text": "Receiving sites often wish to provide their end users with information about mail that is mediated in this fashion. Although the real efficacy of different approaches is a subject for human factors usability research, one technique that is used is for the verifying system to rewrite the From header field, to indicate the address that was verified. For example: From: John Doe via news@news-site.com <jdoe@example.com>. (Note that such rewriting will break a signature, unless it is done after the verification pass is complete.)",
      "ja": "受信サイトは、この方法で仲介されるメールに関する情報をエンドユーザーに提供することを望みます。さまざまなアプローチの実際の有効性はヒューマンファクターのユーザビリティ調査の対象ですが、使用される1つの手法は、検証システムがFromヘッダーフィールドを書き換えて、検証されたアドレスを示すことです。例：From：John Doe via news@news-site.com <jdoe@example.com>。 （このような書き換えは、検証パスの完了後に行われない限り、署名を壊すことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "B.2. Alternate Delivery Scenarios",
      "section_title": true,
      "ja": "B.2. 代替配信シナリオ"
    },
    {
      "indent": 3,
      "text": "Email is often received at a mailbox that has an address different from the one used during initial submission. In these cases, an intermediary mechanism operates at the address originally used and it then passes the message on to the final destination. This mediation process presents some challenges for DKIM signatures.",
      "ja": "多くの場合、電子メールは、最初の送信時に使用されたアドレスとは異なるアドレスを持つメールボックスで受信されます。これらの場合、中間メカニズムは最初に使用されたアドレスで動作し、メッセージを最終的な宛先に渡します。この調停プロセスは、DKIM署名にいくつかの課題を提示します。"
    },
    {
      "indent": 0,
      "text": "B.2.1. Affinity Addresses",
      "section_title": true,
      "ja": "B.2.1. アフィニティアドレス"
    },
    {
      "indent": 3,
      "text": "\"Affinity addresses\" allow a user to have an email address that remains stable, even as the user moves among different email providers. They are typically associated with college alumni associations, professional organizations, and recreational organizations with which they expect to have a long-term relationship. These domains usually provide forwarding of incoming email, and they often have an associated Web application that authenticates the user and allows the forwarding address to be changed. However, these services usually depend on users sending outgoing messages through their own service providers' MTAs. Hence, mail that is signed with the domain of the affinity address is not signed by an entity that is administered by the organization owning that domain.",
      "ja": "「アフィニティアドレス」を使用すると、ユーザーは異なる電子メールプロバイダー間を移動しても、安定した電子メールアドレスを保持できます。彼らは通常、彼らが長期的な関係を持つことを期待している大学同窓会、専門組織、およびレクリエーション組織に関連付けられています。これらのドメインは通常、受信メールの転送を提供し、ユーザーを認証して転送アドレスを変更できるようにするWebアプリケーションが関連付けられていることがよくあります。ただし、これらのサービスは通常、ユーザーが独自のサービスプロバイダーのMTAを介して送信メッセージを送信することに依存しています。したがって、アフィニティアドレスのドメインで署名されたメールは、そのドメインを所有する組織によって管理されるエンティティによって署名されません。"
    },
    {
      "indent": 0,
      "text": " With DKIM, affinity domains could use the Web application to allow users to register per-user keys to be used to sign messages on behalf of their affinity address. The user would take away the secret half of the key pair for signing, and the affinity domain would publish the public half in DNS for access by verifiers.",
      "ja": "DKIMを使用すると、アフィニティドメインはWebアプリケーションを使用して、ユーザーがアフィニティアドレスの代わりにメッセージに署名するために使用するユーザーごとのキーを登録できるようになります。ユーザーは署名用の鍵ペアの秘密の半分を取り除き、アフィニティドメインは検証者がアクセスできるようにパブリックハーフをDNSに公開します。"
    },
    {
      "indent": 3,
      "text": "This is another application that takes advantage of user-level keying, and domains used for affinity addresses would typically have a very large number of user-level keys. Alternatively, the affinity domain could handle outgoing mail, operating a mail submission agent that authenticates users before accepting and signing messages for them. This is of course dependent on the user's service provider not blocking the relevant TCP ports used for mail submission.",
      "ja": "これは、ユーザーレベルのキーイングを利用する別のアプリケーションであり、アフィニティアドレスに使用されるドメインには、通常、非常に多数のユーザーレベルのキーがあります。または、アフィニティドメインが送信メールを処理し、ユーザーのメッセージを受け入れて署名する前にユーザーを認証するメール送信エージェントを操作することもできます。もちろん、これはユーザーのサービスプロバイダーがメール送信に使用される関連TCPポートをブロックしていないことに依存しています。"
    },
    {
      "indent": 0,
      "text": "B.2.2. Simple Address Aliasing (.forward)",
      "section_title": true,
      "ja": "B.2.2. シンプルアドレスエイリアス（.forward）"
    },
    {
      "indent": 3,
      "text": "In some cases, a recipient is allowed to configure an email address to cause automatic redirection of email messages from the original address to another, such as through the use of a Unix .forward file. In this case, messages are typically redirected by the mail handling service of the recipient's domain, without modification, except for the addition of a Received header field to the message and a change in the envelope recipient address. In this case, the recipient at the final address' mailbox is likely to be able to verify the original signature since the signed content has not changed, and DKIM is able to validate the message signature.",
      "ja": "場合によっては、受信者は、Unix .forwardファイルを使用するなどして、元のアドレスから別のアドレスに電子メールメッセージを自動的にリダイレクトするように電子メールアドレスを構成できます。この場合、メッセージは通常、受信者のドメインのメール処理サービスによってリダイレクトされますが、メッセージへの受信ヘッダーフィールドの追加とエンベロープ受信者アドレスの変更は除きます。この場合、最終アドレスのメールボックスの受信者は、署名されたコンテンツが変更されていないため、元の署名を検証でき、DKIMはメッセージの署名を検証できます。"
    },
    {
      "indent": 0,
      "text": "B.2.3. Mailing Lists and Re-Posters",
      "section_title": true,
      "ja": "B.2.3. メーリングリストと再投稿者"
    },
    {
      "indent": 3,
      "text": "There is a wide range of behaviors in services that take delivery of a message and then resubmit it. A primary example is with mailing lists (collectively called \"forwarders\" below), ranging from those that make no modification to the message itself, other than to add a Received header field and change the envelope information, to those that add header fields, change the Subject header field, add content to the body (typically at the end), or reformat the body in some manner. The simple ones produce messages that are quite similar to the automated alias services. More elaborate systems essentially create a new message.",
      "ja": "メッセージの配信を受け取ってから再送信するサービスには、さまざまな動作があります。主な例は、受信ヘッダーフィールドを追加してエンベロープ情報を変更する以外に、メッセージ自体に変更を加えないものから、ヘッダーフィールドを追加するものまで、さまざまなメーリングリスト（以下、総称して「フォワーダー」と呼びます）です。件名ヘッダーフィールド、本文にコンテンツを追加する（通常は最後に）、または何らかの方法で本文を再フォーマットします。単純なものは、自動エイリアスサービスと非常によく似たメッセージを生成します。より複雑なシステムは、本質的に新しいメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "A Forwarder that does not modify the body or signed header fields of a message is likely to maintain the validity of the existing signature. It also could choose to add its own signature to the message.",
      "ja": "メッセージの本文または署名済みヘッダーフィールドを変更しないフォワーダーは、既存の署名の有効性を維持する可能性があります。また、独自の署名をメッセージに追加することもできます。"
    },
    {
      "indent": 0,
      "text": " Forwarders which modify a message in a way that could make an existing signature invalid are particularly good candidates for adding their own signatures (e.g., mailing-list-name@example.net). Since (re-)signing is taking responsibility for the content of the message, these signing forwarders are likely to be selective, and forward or re-sign a message only if it is received with a valid signature or if they have some other basis for knowing that the message is not spoofed.",
      "ja": "既存の署名を無効にする可能性のある方法でメッセージを変更するフォワーダーは、独自の署名を追加するのに特に適しています（例：mailing-list-name@example.net）。 （再）署名はメッセージの内容に責任を負うため、これらの署名フォワーダーは選択的である可能性が高く、メッセージが有効な署名で受信された場合、または他の何らかの根拠がある場合にのみ、メッセージを転送または再署名しますメッセージが偽装されていないことを知っている。"
    },
    {
      "indent": 3,
      "text": "A common practice among systems that are primarily redistributors of mail is to add a Sender header field to the message, to identify the address being used to sign the message. This practice will remove any preexisting Sender header field as required by [RFC2822]. The forwarder applies a new DKIM-Signature header field with the signature, public key, and related information of the forwarder.",
      "ja": "主にメールの再配布者であるシステム間での一般的な方法は、メッセージにSenderヘッダーフィールドを追加して、メッセージの署名に使用されているアドレスを識別することです。これにより、[RFC2822]で要求されている既存のSenderヘッダーフィールドが削除されます。フォワーダーは、署名、公開キー、およびフォワーダーの関連情報を含む新しいDKIM-Signatureヘッダーフィールドを適用します。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Creating a Public Key (INFORMATIVE)",
      "ja": "付録C.公開鍵の作成（参考）"
    },
    {
      "indent": 3,
      "text": "The default signature is an RSA signed SHA256 digest of the complete email. For ease of explanation, the openssl command is used to describe the mechanism by which keys and signatures are managed. One way to generate a 1024-bit, unencrypted private key suitable for DKIM is to use openssl like this:",
      "ja": "デフォルトの署名は、完全な電子メールのRSA署名付きSHA256ダイジェストです。説明を簡単にするために、opensslコマンドを使用して、鍵と署名を管理するメカニズムを説明します。 DKIMに適した1024ビットの暗号化されていない秘密鍵を生成する1つの方法は、opensslを次のように使用することです。"
    },
    {
      "indent": 3,
      "text": "$ openssl genrsa -out rsa.private 1024",
      "ja": "$ openssl genrsa -out rsa.private 1024"
    },
    {
      "indent": 3,
      "text": "For increased security, the \"-passin\" parameter can also be added to encrypt the private key. Use of this parameter will require entering a password for several of the following steps. Servers may prefer to use hardware cryptographic support.",
      "ja": "セキュリティを強化するために、「-passin」パラメータを追加して秘密鍵を暗号化することもできます。このパラメーターを使用するには、以下のいくつかのステップでパスワードを入力する必要があります。サーバーは、ハードウェア暗号化サポートの使用を好む場合があります。"
    },
    {
      "indent": 3,
      "text": "The \"genrsa\" step results in the file rsa.private containing the key information similar to this:",
      "ja": "「genrsa」ステップの結果、rsa.privateファイルに次のようなキー情報が含まれます。"
    },
    {
      "indent": 4,
      "text": "-----BEGIN RSA PRIVATE KEY-----\nMIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC\njxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb\nto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB\nAoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX\n/1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ\ngAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO\nn1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m\n3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/\neVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj\n7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA\nqZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf\neAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX\nGMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=\n-----END RSA PRIVATE KEY-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To extract the public-key component from the private key, use openssl like this:",
      "ja": "秘密鍵から公開鍵コンポーネントを抽出するには、opensslを次のように使用します。"
    },
    {
      "indent": 0,
      "text": " $ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM This results in the file rsa.public containing the key information similar to this:",
      "ja": "$ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEMこれにより、次のようなキー情報を含むファイルrsa.publicが生成されます。"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM\noGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R\ntdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI\nMmPSPDdQPNUYckcQ2QIDAQAB\n-----END PUBLIC KEY-----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This public-key data (without the BEGIN and END tags) is placed in the DNS:",
      "ja": "この公開鍵データ（BEGINタグとENDタグなし）はDNSに配置されます。"
    },
    {
      "indent": 3,
      "text": "brisbane IN  TXT  (\"v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ\"\n                   \"KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt\"\n                   \"IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v\"\n                   \"/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi\"\n                   \"tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB\")",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix D. MUA Considerations",
      "section_title": true,
      "ja": "付録D. MUAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "When a DKIM signature is verified, the processing system sometimes makes the result available to the recipient user's MUA. How to present this information to the user in a way that helps them is a matter of continuing human factors usability research. The tendency is to have the MUA highlight the address associated with this signing identity in some way, in an attempt to show the user the address from which the mail was sent. An MUA might do this with visual cues such as graphics, or it might include the address in an alternate view, or it might even rewrite the original From address using the verified information. Some MUAs might indicate which header fields were protected by the validated DKIM signature. This could be done with a positive indication on the signed header fields, with a negative indication on the unsigned header fields, by visually hiding the unsigned header fields, or some combination of these. If an MUA uses visual indications for signed header fields, the MUA probably needs to be careful not to display unsigned header fields in a way that might be construed by the end user as having been signed. If the message has an l= tag whose value does not extend to the end of the message, the MUA might also hide or mark the portion of the message body that was not signed.",
      "ja": "DKIM署名が検証されると、処理システムは結果を受信者ユーザーのMUAで利用できるようにする場合があります。この情報をユーザーに役立つ方法でユーザーに提示する方法は、継続的なヒューマンファクターのユーザビリティ調査の問題です。メールの送信元のアドレスをユーザーに表示するために、MUAがこの署名IDに関連付けられたアドレスを何らかの方法で強調表示する傾向があります。 MUAは、グラフィックスなどの視覚的な手がかりを使用してこれを実行したり、代替ビューにアドレスを含めたり、検証済みの情報を使用して元の差出人アドレスを書き換えたりする場合があります。一部のMUAは、検証されたDKIM署名によって保護されたヘッダーフィールドを示す場合があります。これは、署名されたヘッダーフィールドを肯定的に示し、署名されていないヘッダーフィールドを否定的に示したり、署名されていないヘッダーフィールドを視覚的に非表示にしたり、これらを組み合わせたりすることで実現できます。 MUAが署名済みヘッダーフィールドに視覚的な表示を使用する場合、MUAはおそらく、署名されていないヘッダーフィールドを、エンドユーザーが署名済みであると解釈する方法で表示しないように注意する必要があります。メッセージにl =タグがあり、その値がメッセージの末尾まで拡張されていない場合、MUAは署名されていないメッセージ本文の部分を非表示またはマークすることもあります。"
    },
    {
      "indent": 3,
      "text": "The aforementioned information is not intended to be exhaustive. The MUA may choose to highlight, accentuate, hide, or otherwise display any other information that may, in the opinion of the MUA author, be deemed important to the end user.",
      "ja": "前述の情報は、すべてを網羅することを意図したものではありません。 MUAは、MUA作成者の意見では、エンドユーザーにとって重要と見なされる可能性のあるその他の情報を強調表示、強調、非表示、またはその他の方法で表示することを選択できます。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Acknowledgements",
      "section_title": true,
      "ja": "付録E.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Russ Allbery, Edwin Aoki, Claus Assmann, Steve Atkins, Rob Austein, Fred Baker, Mark Baugher, Steve Bellovin, Nathaniel Borenstein, Dave Crocker, Michael Cudahy, Dennis Dayman, Jutta Degener, Frank Ellermann, Patrik Faeltstroem, Mark Fanto, Stephen Farrell, Duncan Findlay, Elliot Gillum, Olafur Gu[eth]mundsson, Phillip Hallam-Baker, Tony Hansen, Sam Hartman, Arvel Hathcock, Amir Herzberg, Paul Hoffman, Russ Housley, Craig Hughes, Cullen Jennings, Don Johnsen, Harry Katz, Murray S. Kucherawy, Barry Leiba, John Levine, Charles Lindsey, Simon Longsdale, David Margrave, Justin Mason, David Mayne, Thierry Moreau, Steve Murphy, Russell Nelson, Dave Oran, Doug Otis, Shamim Pirzada, Juan Altmayer Pizzorno, Sanjay Pol, Blake Ramsdell, Christian Renaud, Scott Renfro, Neil Rerup, Eric Rescorla, Dave Rossetti, Hector Santos, Jim Schaad, the Spamhaus.org team, Malte S. Stretz, Robert Sanders, Rand Wacker, Sam Weiler, and Dan Wing for their valuable suggestions and constructive criticism.",
      "ja": "著者は、Russ Allbery、Edwin Aoki、Claus Assmann、Steve Atkins、Rob Austein、Fred Baker、Mark Ba​​ugher、Steve Bellovin、Nathaniel Borenstein、Dave Crocker、Michael Cudahy、Dennis Dayman、Jutta Degener、Frank Ellermann、Patrik Faeltstroem、マークファント、スティーブンファレル、ダンカンフィンドレー、エリオットギルム、オラファーグース、マンソン、フィリップハラムベイカー、トニーハンセン、サムハートマン、アーベルハスコック、アミールヘルツバーグ、ポールホフマン、ラスハウズリー、クレイグヒューズ、カレンジェニングス、ドンジョンセン、ハリー・カッツ、マレー・S・クチェラウィ、バリー・レイバ、ジョン・レバイン、チャールズ・リンジー、サイモン・ロングスデール、デビッド・マーグレイブ、ジャスティン・メイソン、デビッド・メイン、ティエリー・モロー、スティーブ・マーフィー、ラッセル・ネルソン、デイブ・オラン、ダグ・オティス、シャミム・ピルザダ、ファン・アルトマイヤーピッツァルノ、サンジャイポール、ブレイクラムスデル、クリスチャンルノー、スコットレンフロ、ニールルラップ、エリックレスコーラ、デイブロセッティ、ヘクターサントス、ジムシャード、Spamhaus.orgチーム、マルトS.ストレッツ、ロバートサンダース、ランドワッカー、サムワイラー、そしてDan Wingの貴重な提案と構造積極的な批判。"
    },
    {
      "indent": 3,
      "text": "The DomainKeys specification was a primary source from which this specification has been derived. Further information about DomainKeys is at [RFC4870].",
      "ja": "DomainKeys仕様は、この仕様の元となった主要なソースでした。 DomainKeysの詳細については、[RFC4870]を参照してください。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Allman Sendmail, Inc. 6425 Christie Ave, Suite 400 Emeryville, CA 94608 USA",
      "ja": "Eric Allman Sendmail、Inc. 6425 Christie Ave、Suite 400 Emeryville、CA 94608 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 510 594 5501 EMail: eric+dkim@sendmail.org URI:",
      "ja": "電話：+1 510 594 5501メール：eric+dkim@sendmail.org URI："
    },
    {
      "indent": 3,
      "text": "Jon Callas PGP Corporation 3460 West Bayshore Palo Alto, CA 94303 USA",
      "ja": "John Kells PGP Corporation 3460 West Palo Alto、K94303 Us"
    },
    {
      "indent": 0,
      "text": " Phone: +1 650 319 9016 EMail: jon@pgp.com Mark Delany Yahoo! Inc 701 First Avenue Sunnyvale, CA 95087 USA",
      "ja": "電話：+1 650 319 9016メール：jon@pgp.com Mark Delany Yahoo! Inc 701 First Avenue Sunnyvale、CA 95087 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 349 6831 EMail: markd+dkim@yahoo-inc.com URI:",
      "ja": "電話：+1408349 6831メール：markd+dkim@yahoo-inc.com URI："
    },
    {
      "indent": 3,
      "text": "Miles Libbey Yahoo! Inc 701 First Avenue Sunnyvale, CA 95087 USA",
      "ja": "Miles Libbey Yahoo! Inc 701 First Avenue Sunnyvale、CA 95087 USA"
    },
    {
      "indent": 3,
      "text": "EMail: mlibbeymail-mailsig@yahoo.com\nURI:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jim Fenton Cisco Systems, Inc. MS SJ-9/2 170 W. Tasman Drive San Jose, CA 95134-1706 USA",
      "ja": "Jim Fenton Cisco Systems、Inc. MS SJ-9 / 2 170 W. Tasman Drive San Jose、CA 95134-1706 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 526 5914 EMail: fenton@cisco.com URI:",
      "ja": "電話：+1 408 526 5914メール：fenton@cisco.com URI："
    },
    {
      "indent": 3,
      "text": "Michael Thomas Cisco Systems, Inc. MS SJ-9/2 170 W. Tasman Drive San Jose, CA 95134-1706",
      "ja": "Michael Thomas Cisco Systems、Inc. MS SJ-9 / 2 170 W. Tasman Drive San Jose、CA 95134-1706"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 525 5386\nEMail: mat@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "Copyright（C）IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します。明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および使用可能にされるライセンスの保証、または一般ライセンスを取得する試みの結果、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得できるhttp://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、利害関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能への資金提供は、現在Internet Societyから提供されています。"
    }
  ]
}