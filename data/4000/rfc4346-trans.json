{
  "title": {
    "text": "RFC 4346 - The Transport Layer Security (TLS) Protocol Version 1.1",
    "ja": "RFC 4346 - トランスポート層セキュリティ（TLS）プロトコルバージョン1.1"
  },
  "number": 4346,
  "created_at": "2020-08-15 13:19:09.001762+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          T. Dierks\nRequest for Comments: 4346                                   Independent\nObsoletes: 2246                                              E. Rescorla\nCategory: Standards Track                                     RTFM, Inc.\n                                                              April 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "The Transport Layer Security (TLS) Protocol Version 1.1",
      "ja": "トランスポート層セキュリティ（TLS）プロトコルバージョン1.1"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies Version 1.1 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.",
      "ja": "このドキュメントは、Transport Layer Security（TLS）プロトコルのバージョン1.1を規定しています。 TLSプロトコルは、インターネット上の通信セキュリティを提供します。このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防ぐように設計された方法で通信できます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Differences from TLS 1.0 ...................................5\n   1.2. Requirements Terminology ...................................5\n2. Goals ...........................................................5\n3. Goals of This Document ..........................................6\n4. Presentation Language ...........................................6\n   4.1. Basic Block Size ...........................................7\n   4.2. Miscellaneous ..............................................7\n   4.3. Vectors ....................................................7\n   4.4. Numbers ....................................................8\n   4.5. Enumerateds ................................................8\n   4.6. Constructed Types ..........................................9\n        4.6.1. Variants ...........................................10\n   4.7. Cryptographic Attributes ..................................11\n   4.8. Constants .................................................12\n5. HMAC and the Pseudorandom Function .............................12\n6. The TLS Record Protocol ........................................14\n   6.1. Connection States .........................................15\n   6.2. Record layer ..............................................17\n        6.2.1. Fragmentation ......................................17\n        6.2.2. Record Compression and Decompression ...............19\n        6.2.3. Record Payload Protection ..........................19\n               6.2.3.1. Null or Standard Stream Cipher ............20\n               6.2.3.2. CBC Block Cipher ..........................21\n   6.3. Key Calculation ...........................................24\n7. The TLS Handshaking Protocols ..................................24\n   7.1. Change Cipher Spec Protocol ...............................25\n   7.2. Alert Protocol ............................................26\n        7.2.1. Closure Alerts .....................................27\n        7.2.2. Error Alerts .......................................28\n   7.3. Handshake Protocol Overview ...............................31\n   7.4. Handshake Protocol ........................................34\n        7.4.1. Hello Messages .....................................35\n               7.4.1.1. Hello request .............................35\n               7.4.1.2. Client Hello ..............................36\n               7.4.1.3. Server Hello ..............................39\n        7.4.2. Server Certificate .................................40\n        7.4.3. Server Key Exchange Message ........................42\n        7.4.4. Certificate request ................................44\n        7.4.5. Server Hello Done ..................................46\n        7.4.6. Client certificate .................................46\n        7.4.7. Client Key Exchange Message ........................47\n               7.4.7.1. RSA Encrypted Premaster Secret Message ....47\n               7.4.7.2. Client Diffie-Hellman Public Value ........50\n        7.4.8. Certificate verify .................................50\n        7.4.9. Finished ...........................................51",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "8. Cryptographic Computations .....................................52\n   8.1. Computing the Master Secret ...............................52\n        8.1.1. RSA ................................................53\n        8.1.2. Diffie-Hellman .....................................53\n9. Mandatory Cipher Suites ........................................53\n10. Application Data Protocol .....................................53\n11. Security Considerations .......................................53\n12. IANA Considerations ...........................................54\nA. Appendix - Protocol constant values ............................55\n        A.1. Record layer .........................................55\n        A.2. Change cipher specs message ..........................56\n        A.3. Alert messages .......................................56\n        A.4. Handshake protocol ...................................57\n        A.4.1. Hello messages .....................................57\n        A.4.2. Server authentication and key exchange messages ....58\n        A.4.3. Client authentication and key exchange messages ....59\n        A.4.4.Handshake finalization message ......................60\n        A.5. The CipherSuite ......................................60\n        A.6. The Security Parameters ..............................63\nB. Appendix - Glossary ............................................64\nC. Appendix - CipherSuite definitions .............................68\nD. Appendix - Implementation Notes ................................69\n        D.1 Random Number Generation and Seeding ..................70\n        D.2 Certificates and authentication .......................70\n        D.3 CipherSuites ..........................................70\nE. Appendix - Backward Compatibility With SSL .....................71\n        E.1. Version 2 client hello ...............................72\n        E.2. Avoiding man-in-the-middle version rollback ..........74\nF. Appendix - Security analysis ...................................74\n        F.1. Handshake protocol ...................................74\n        F.1.1. Authentication and key exchange ....................74\n        F.1.1.1. Anonymous key exchange ...........................75\n        F.1.1.2. RSA key exchange and authentication ..............75\n        F.1.1.3. Diffie-Hellman key exchange with authentication ..76\n        F.1.2. Version rollback attacks ...........................77\n        F.1.3. Detecting attacks against the handshake protocol ...77\n        F.1.4. Resuming sessions ..................................78\n        F.1.5. MD5 and SHA ........................................78\n        F.2. Protecting application data ..........................78\n        F.3. Explicit IVs .........................................79\n        F.4  Security of Composite Cipher Modes ...................79\n        F.5  Denial of Service ....................................80\n        F.6. Final notes ..........................................80\nNormative References ..............................................81\nInformative References ............................................82",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The primary goal of the TLS Protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:",
      "ja": "TLSプロトコルの主な目的は、2つの通信アプリケーション間でプライバシーとデータの整合性を提供することです。このプロトコルは、TLSレコードプロトコルとTLSハンドシェイクプロトコルの2つの層で構成されています。 TLS Record Protocolは、最も信頼できるトランスポートプロトコル（TCP [TCP]など）の上に階層化された最下位レベルです。 TLSレコードプロトコルは、2つの基本的なプロパティを持つ接続セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "- The connection is private. Symmetric cryptography is used for data encryption (e.g., DES [DES], RC4 [SCH] etc.). The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.",
      "ja": "- 接続はプライベートです。対称暗号化は、データ暗号化に使用されます（たとえば、DES [DES]、RC4 [SCH]など）。この対称暗号化のキーは、接続ごとに一意に生成され、別のプロトコル（TLSハンドシェイクプロトコルなど）によってネゴシエートされた秘密に基づいています。レコードプロトコルは暗号化せずに使用することもできます。"
    },
    {
      "indent": 3,
      "text": "- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA, MD5, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.",
      "ja": "- 接続は信頼できます。メッセージ転送には、キー付きMACを使用したメッセージ整合性チェックが含まれます。安全なハッシュ関数（SHA、MD5など）がMAC計算に使用されます。 Record ProtocolはMACなしで動作できますが、通常はこのモードでのみ使用されますが、別のプロトコルがセキュリティパラメータをネゴシエートするためのトランスポートとしてRecord Protocolを使用しています。"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is used for encapsulation of various higher-level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:",
      "ja": "TLS Record Protocolは、さまざまな上位プロトコルのカプセル化に使用されます。このようなカプセル化されたプロトコルの1つであるTLSハンドシェイクプロトコルを使用すると、サーバーとクライアントは相互に認証し、アプリケーションプロトコルがデータの最初のバイトを送信または受信する前に、暗号化アルゴリズムと暗号化キーをネゴシエートできます。 TLSハンドシェイクプロトコルは、3つの基本的なプロパティを持つ接続セキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "- The peer's identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.",
      "ja": "- ピアのIDは、非対称または公開鍵暗号化（RSA [RSA]、DSS [DSS]など）を使用して認証できます。この認証はオプションにすることができますが、通常、少なくとも1つのピアに必要です。"
    },
    {
      "indent": 3,
      "text": "- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.",
      "ja": "- 共有シークレットのネゴシエーションは安全です。ネゴシエートされたシークレットは盗聴者が利用できません。認証された接続では、接続の真ん中に攻撃者が侵入してもシークレットを取得できません。"
    },
    {
      "indent": 3,
      "text": "- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.",
      "ja": "- ネゴシエーションは信頼できます。通信の当事者によって検出されることなく、攻撃者がネゴシエーション通信を変更することはできません。"
    },
    {
      "indent": 3,
      "text": "One advantage of TLS is that it is application protocol independent. Higher level protocols can layer on top of the TLS Protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.",
      "ja": "TLSの1つの利点は、TLSがアプリケーションプロトコルに依存しないことです。より高いレベルのプロトコルは、TLSプロトコルの上に透過的に階層化できます。ただし、TLS標準では、プロトコルがTLSでセキュリティを追加する方法は指定されていません。 TLSハンドシェイクの開始方法と交換される認証証明書の解釈方法の決定は、TLSの上で実行されるプロトコルの設計者と実装者の判断に委ねられます。"
    },
    {
      "indent": 0,
      "text": "1.1. Differences from TLS 1.0",
      "section_title": true,
      "ja": "1.1. TLS 1.0との違い"
    },
    {
      "indent": 3,
      "text": "This document is a revision of the TLS 1.0 [TLS1.0] protocol, and contains some small security improvements, clarifications, and editorial improvements. The major changes are:",
      "ja": "このドキュメントはTLS 1.0 [TLS1.0]プロトコルの改訂版であり、セキュリティに関する小さな改善、説明、および編集上の改善が含まれています。主な変更点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- The implicit Initialization Vector (IV) is replaced with an explicit IV to protect against CBC attacks [CBCATT].",
      "ja": "- 暗黙的な初期化ベクトル（IV）は、CBC攻撃から保護するために明示的なIVに置き換えられています[CBCATT]。"
    },
    {
      "indent": 3,
      "text": "- Handling of padding errors is changed to use the bad_record_mac alert rather than the decryption_failed alert to protect against CBC attacks.",
      "ja": "- CBC攻撃から保護するために、decryption_failedアラートではなくbad_record_macアラートを使用するようにパディングエラーの処理が変更されました。"
    },
    {
      "indent": 3,
      "text": "- IANA registries are defined for protocol parameters.",
      "ja": "- IANAレジストリは、プロトコルパラメータに対して定義されています。"
    },
    {
      "indent": 3,
      "text": "- Premature closes no longer cause a session to be nonresumable.",
      "ja": "- 途中で終了しても、セッションが再開できなくなりました。"
    },
    {
      "indent": 3,
      "text": "- Additional informational notes were added for various new attacks on TLS.",
      "ja": "- TLSに対するさまざまな新しい攻撃について、追加の情報メモが追加されました。"
    },
    {
      "indent": 3,
      "text": "In addition, a number of minor clarifications and editorial improvements were made.",
      "ja": "さらに、いくつかのマイナーな説明と編集上の改善が行われました。"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Terminology",
      "section_title": true,
      "ja": "1.2. 要件の用語"
    },
    {
      "indent": 3,
      "text": "In this document, the keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\" and \"MAY\" are to be interpreted as described in RFC 2119 [REQ].",
      "ja": "このドキュメントでは、キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHOULD」、「SHOULD NOT」、および「MAY」は、RFC 2119 [REQ]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Goals",
      "section_title": true,
      "ja": "2. ゴール"
    },
    {
      "indent": 3,
      "text": "The goals of TLS Protocol, in order of their priority, are as follows:",
      "ja": "TLSプロトコルの目標は、優先度の順に、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Cryptographic security: TLS should be used to establish a secure connection between two parties.",
      "ja": "1. 暗号化セキュリティ：TLSを使用して、2者間の安全な接続を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another's code.",
      "ja": "2. 相互運用性：独立したプログラマーは、お互いのコードを知らなくても暗号パラメーターを正常に交換できるTLSを利用したアプリケーションを開発できるはずです。"
    },
    {
      "indent": 3,
      "text": "3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.",
      "ja": "3. 拡張性：TLSは、必要に応じて新しい公開鍵とバルク暗号化方式を組み込むことができるフレームワークを提供しようとしています。これはまた、2つのサブゴールを達成します。新しいプロトコルを作成する必要をなくし（そして考えられる新しい弱点の導入を危険にさらす）、新しいセキュリティライブラリ全体を実装する必要を回避します。"
    },
    {
      "indent": 3,
      "text": "4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.",
      "ja": "4. 相対的な効率：暗号化操作は、CPUを集中的に使用する傾向があり、特に公開鍵の操作です。このため、TLSプロトコルにはオプションのセッションキャッシングスキームが組み込まれており、最初から確立する必要のある接続の数を減らすことができます。さらに、ネットワークアクティビティを減らすように注意が払われています。"
    },
    {
      "indent": 0,
      "text": "3. Goals of This Document",
      "section_title": true,
      "ja": "3. このドキュメントの目的"
    },
    {
      "indent": 3,
      "text": "This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.1, TLS 1.0, and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.",
      "ja": "このドキュメントとTLSプロトコル自体は、Netscapeによって発行されたSSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、TLS 1.1、TLS 1.0、およびSSL 3.0が相互運用できないほど重要です（ただし、各プロトコルには、実装が以前のバージョンをバックダウンできるメカニズムが組み込まれています）。このドキュメントは、主にプロトコルを実装する読者、およびプロトコルの暗号分析を行う読者を対象としています。仕様はこれを念頭に置いて作成されており、2つのグループのニーズを反映することを目的としています。そのため、アルゴリズムに依存するデータ構造とルールの多くが（付録ではなく）テキストの本文に含まれ、それらに簡単にアクセスできます。"
    },
    {
      "indent": 3,
      "text": "This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.",
      "ja": "このドキュメントは、サービス定義またはインターフェイス定義の詳細を提供することを意図していませんが、堅固なセキュリティの維持に必要なポリシーの特定の領域をカバーしています。"
    },
    {
      "indent": 0,
      "text": "4. Presentation Language",
      "section_title": true,
      "ja": "4. プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language \"C\" in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.",
      "ja": "このドキュメントでは、外部表現でのデータのフォーマットを扱います。次の非常に基本的で、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造のいくつかのソースから引き出されます。構文はプログラミング言語「C」に似ており、構文も意図もXDR [XDR]に似ていますが、あまりにも多くの類似点を描くのは危険です。このプレゼンテーション言語の目的は、TLSのみを文書化することです。その特定の目標を超える一般的な用途はありません。"
    },
    {
      "indent": 0,
      "text": "4.1. Basic Block Size",
      "section_title": true,
      "ja": "4.1. 基本ブロックサイズ"
    },
    {
      "indent": 3,
      "text": "The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the bytestream, a multi-byte item (a numeric in the example) is formed (using C notation) by:",
      "ja": "すべてのデータ項目の表現は明示的に指定されています。基本的なデータブロックサイズは1バイト（8ビット）です。複数バイトのデータ項目は、左から右、上から下へのバイトの連結です。バイトストリームから、マルチバイト項目（この例では数値）は（C表記を使用して）次のように形成されます。"
    },
    {
      "indent": 7,
      "text": "value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |\n        ... | byte[n-1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This byte ordering for multi-byte values is the commonplace network byte order or big endian format.",
      "ja": "このマルチバイト値のバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です。"
    },
    {
      "indent": 0,
      "text": "4.2. Miscellaneous",
      "section_title": true,
      "ja": "4.2. 雑多"
    },
    {
      "indent": 3,
      "text": "Comments begin with \"/*\" and end with \"*/\".",
      "ja": "コメントは「/ *」で始まり、「* /」で終わります。"
    },
    {
      "indent": 3,
      "text": "Optional components are denoted by enclosing them in \"[[ ]]\" double brackets.",
      "ja": "オプションのコンポーネントは、 \"[[]]\"の二重括弧で囲んで示されます。"
    },
    {
      "indent": 3,
      "text": "Single-byte entities containing uninterpreted data are of type opaque.",
      "ja": "未解釈のデータを含むシングルバイトエンティティは、不透明タイプです。"
    },
    {
      "indent": 0,
      "text": "4.3. Vectors",
      "section_title": true,
      "ja": "4.3. ベクタ"
    },
    {
      "indent": 3,
      "text": "A vector (single dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T', that is a fixed-length vector of type T is",
      "ja": "ベクトル（1次元配列）は、同種のデータ要素のストリームです。ベクトルのサイズは、ドキュメント化時に指定するか、実行時まで指定しないでおくことができます。どちらの場合も、長さはベクトルの要素数ではなくバイト数を宣言します。 T型の固定長ベクトルである新しい型T 'を指定する構文は、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "T T'[n];",
      "ja": "T T '[n];"
    },
    {
      "indent": 3,
      "text": "Here, T' occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.",
      "ja": "ここで、T 'はデータストリームのnバイトを占めます。nはTのサイズの倍数です。ベクトルの長さは、エンコードされたストリームには含まれません。"
    },
    {
      "indent": 3,
      "text": "In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.",
      "ja": "次の例では、Datumはプロトコルが解釈しない3つの連続したバイトとして定義されていますが、Dataは3つの連続したDatumであり、合計9バイトを消費します。"
    },
    {
      "indent": 7,
      "text": "opaque Datum[3];      /* three uninterpreted bytes */\nDatum Data[9];        /* 3 consecutive 3 byte vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation <floor..ceiling>. When these are encoded, the actual length precedes the vector's contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector's specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.",
      "ja": "可変長ベクトルは、表記<floor..ceiling>を使用して、有効な長さの部分範囲を包括的に指定することによって定義されます。これらがエンコードされると、実際の長さはバイトストリーム内のベクトルの内容に先行します。長さは、ベクターの指定された最大（天井）長さを保持するために必要なバイト数を消費する数の形式になります。実際の長さがゼロの可変長ベクトルは、空のベクトルと呼ばれます。"
    },
    {
      "indent": 7,
      "text": "T T'<floor..ceiling>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).",
      "ja": "次の例では、必須は、不透明なタイプの300〜400バイトを含む必要があるベクトルです。空にすることはできません。実際の長さフィールドは、値400を表すのに十分な2バイト、uint16を消費します（セクション4.4を参照）。一方、longerは最大800バイトのデータ、または400 uint16要素を表すことができ、空の場合があります。そのエンコードには、ベクターの前に付加される2バイトの実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素の長さの偶数倍でなければなりません（たとえば、uint16の17バイトのベクトルは不正です）。"
    },
    {
      "indent": 7,
      "text": "opaque mandatory<300..400>;\n      /* length field is 2 bytes, cannot be empty */\nuint16 longer<0..800>;\n      /* zero to 400 16-bit unsigned integers */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4. Numbers",
      "section_title": true,
      "ja": "4.4. 数字"
    },
    {
      "indent": 3,
      "text": "The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.",
      "ja": "基本的な数値データ型は、符号なしバイト（uint8）です。より大きな数値データ型はすべて、セクション4.1で説明されているように連結された固定長の一連のバイトから形成され、これも符号なしです。次の数値タイプが事前定義されています。"
    },
    {
      "indent": 7,
      "text": "uint8 uint16[2];\nuint8 uint24[3];\nuint8 uint32[4];\nuint8 uint64[8];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "All values, here and elsewhere in the specification, are stored in \"network\" or \"big-endian\" order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.",
      "ja": "仕様のここや他の場所にあるすべての値は、「ネットワーク」または「ビッグエンディアン」の順序で格納されます。 16進バイト01 02 03 04で表されるuint32は、10進値16909060と同等です。"
    },
    {
      "indent": 0,
      "text": "4.5. Enumerateds",
      "section_title": true,
      "ja": "4.5. 列挙型"
    },
    {
      "indent": 3,
      "text": "An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.",
      "ja": "enumと呼ばれる追加のスパースデータタイプを使用できます。 enum型のフィールドは、定義で宣言された値のみを想定できます。各定義は異なるタイプです。同じタイプの列挙型のみを割り当てたり、比較したりできます。次の例に示すように、列挙型のすべての要素に値を割り当てる必要があります。列挙型の要素は順序付けされていないため、一意の値を任意の順序で割り当てることができます。"
    },
    {
      "indent": 7,
      "text": "enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Enumerateds occupy as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.",
      "ja": "列挙型は、バイトストリーム内で定義された最大の序数値と同じだけのスペースを占有します。次の定義では、1バイトを使用してColorタイプのフィールドを伝送します。"
    },
    {
      "indent": 7,
      "text": "enum { red(3), blue(5), white(7) } Color;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element. In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.",
      "ja": "オプションで、関連するタグなしで値を指定して、余分な要素を定義せずに幅の定義を強制できます。次の例では、Tasteはデータストリームで2バイトを消費しますが、1、2、または4の値しか想定できません。"
    },
    {
      "indent": 7,
      "text": "enum { sweet(1), sour(2), bitter(4), (32000) } Taste;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.",
      "ja": "列挙型の要素の名前は、定義された型内でスコープされます。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります。割り当てのターゲットが明確に指定されている場合、そのような資格は必要ありません。"
    },
    {
      "indent": 7,
      "text": "Color color = Color.blue;     /* overspecified, legal */\nColor color = blue;           /* correct, type implicit */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For enumerateds that are never converted to external representation, the numerical information may be omitted.",
      "ja": "外部表現に変換されない列挙型の場合、数値情報は省略できます。"
    },
    {
      "indent": 7,
      "text": "enum { low, medium, high } Amount;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6. Constructed Types",
      "section_title": true,
      "ja": "4.6. 構築された型"
    },
    {
      "indent": 3,
      "text": "Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.",
      "ja": "構造型は、便宜上、プリミティブ型から構築できます。各仕様は、新しい一意の型を宣言します。定義の構文はCの構文によく似ています。"
    },
    {
      "indent": 7,
      "text": "struct {\n  T1 f1;\n  T2 f2;\n  ...\n  Tn fn;\n} [[T]];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields within a structure may be qualified using the type's name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.",
      "ja": "構造体内のフィールドは、列挙型で使用できる構文とよく似た構文で、型の名前を使用して修飾できます。たとえば、T.f2は前の宣言の2番目のフィールドを参照します。構造定義を埋め込むことができます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Variants",
      "section_title": true,
      "ja": "4.6.1. バリアント"
    },
    {
      "indent": 3,
      "text": "Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.",
      "ja": "定義された構造には、環境内で利用可能ないくつかの知識に基づいたバリアントがある場合があります。セレクターは、構造が定義する可能なバリアントを定義する列挙型である必要があります。 selectで宣言された列挙のすべての要素にケースアームが必要です。バリアント構造の本体には、参照用のラベルを付けることができます。実行時にバリアントが選択されるメカニズムは、プレゼンテーション言語では規定されていません。"
    },
    {
      "indent": 7,
      "text": "struct {\n    T1 f1;\n    T2 f2;\n    ....\n    Tn fn;\n    select (E) {\n        case e1: Te1;\n        case e2: Te2;\n        ....\n        case en: Ten;\n    } [[fv]];\n} [[Tv]];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 7,
      "text": "enum { apple, orange } VariantTag;\nstruct {\n    uint16 number;\n    opaque string<0..10>; /* variable length */\n} V1;\nstruct {\n    uint32 number;\n    opaque string[10];    /* fixed length */\n} V2;\nstruct {\n    select (VariantTag) { /* value of selector is implicit */\n        case apple: V1;   /* VariantBody, tag = apple */\n        case orange: V2;  /* VariantBody, tag = orange */\n    } variant_body;       /* optional label on variant */\n} VariantRecord;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Variant structures may be qualified (narrowed) by specifying a value for the selector prior to the type. For example, an",
      "ja": "バリアント構造は、型の前にセレクターの値を指定することで修飾（狭め）できます。たとえば、"
    },
    {
      "indent": 7,
      "text": "orange VariantRecord",
      "ja": "オレンジVariantRecord"
    },
    {
      "indent": 3,
      "text": "is a narrowed type of a VariantRecord containing a variant_body of type V2.",
      "ja": "V2型のvariant_bodyを含むVariantRecordのナロー型です。"
    },
    {
      "indent": 0,
      "text": "4.7. Cryptographic Attributes",
      "section_title": true,
      "ja": "4.7. 暗号化属性"
    },
    {
      "indent": 3,
      "text": "The four cryptographic operations digital signing, stream cipher encryption, block cipher encryption, and public key encryption are designated digitally-signed, stream-ciphered, block-ciphered, and public-key-encrypted, respectively. A field's cryptographic processing is specified by prepending an appropriate key word designation before the field's type specification. Cryptographic keys are implied by the current session state (see Section 6.1).",
      "ja": "デジタル署名、ストリーム暗号化、ブロック暗号化、および公開鍵暗号化の4つの暗号化操作は、それぞれデジタル署名、ストリーム暗号化、ブロック暗号化、および公開鍵暗号化に指定されます。フィールドの暗号処理は、フィールドのタイプ指定の前に適切なキーワード指定を付加することによって指定されます。暗号化キーは、現在のセッション状態によって暗示されます（セクション6.1を参照）。"
    },
    {
      "indent": 3,
      "text": "In digital signing, one-way hash functions are used as input for a signing algorithm. A digitally-signed element is encoded as an opaque vector <0..2^16-1>, where the length is specified by the signing algorithm and key.",
      "ja": "デジタル署名では、一方向ハッシュ関数が署名アルゴリズムの入力として使用されます。デジタル署名された要素は、不透明なベクトル<0..2 ^ 16-1>としてエンコードされます。ここで、長さは署名アルゴリズムとキーによって指定されます。"
    },
    {
      "indent": 3,
      "text": "In RSA signing, a 36-byte structure of two hashes (one SHA and one MD5) is signed (encrypted with the private key). It is encoded with PKCS #1 block type 1, as described in [PKCS1A].",
      "ja": "RSA署名では、2つのハッシュ（1つのSHAと1つのMD5）の36バイト構造が署名されます（秘密鍵で暗号化されます）。 [PKCS1A]で説明されているように、PKCS＃1ブロックタイプ1でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Note: The standard reference for PKCS#1 is now RFC 3447 [PKCS1B]. However, to minimize differences with TLS 1.0 text, we are using the terminology of RFC 2313 [PKCS1A].",
      "ja": "注：PKCS＃1の標準参照はRFC 3447 [PKCS1B]になりました。ただし、TLS 1.0テキストとの違いを最小限に抑えるために、RFC 2313 [PKCS1A]の用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "In DSS, the 20 bytes of the SHA hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSS signature is an opaque vector, as above, the contents of which are the DER encoding of:",
      "ja": "DSSでは、SHAハッシュの20バイトは、追加のハッシュなしでデジタル署名アルゴリズムを介して直接実行されます。これにより、rとsの2つの値が生成されます。上記のように、DSS署名は不透明なベクトルであり、その内容は次のDERエンコードです。"
    },
    {
      "indent": 7,
      "text": "Dss-Sig-Value  ::=  SEQUENCE  {\n     r       INTEGER,\n     s       INTEGER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.",
      "ja": "ストリーム暗号の暗号化では、平文は、暗号で保護されたキー付きの疑似乱数ジェネレータから生成された同じ量の出力と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items that are block-ciphered will be an exact multiple of the cipher block length.",
      "ja": "ブロック暗号化暗号化では、平文のすべてのブロックが暗号文のブロックに暗号化されます。すべてのブロック暗号化暗号化はCBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されるすべてのアイテムは、暗号化ブロック長の正確な倍数になります。"
    },
    {
      "indent": 3,
      "text": "In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector <0..2^16-1>, where the length is specified by the signing algorithm and key.",
      "ja": "公開鍵暗号化では、公開鍵アルゴリズムを使用して、一致する秘密鍵でのみ復号化できるようにデータを暗号化します。公開鍵で暗号化された要素は、不透明なベクトル<0..2 ^ 16-1>としてエンコードされ、長さは署名アルゴリズムと鍵によって指定されます。"
    },
    {
      "indent": 3,
      "text": "An RSA-encrypted value is encoded with PKCS #1 block type 2, as described in [PKCS1A].",
      "ja": "[PKCS1A]で説明されているように、RSAで暗号化された値はPKCS＃1ブロックタイプ2でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "In the following example,",
      "ja": "次の例では、"
    },
    {
      "indent": 7,
      "text": "stream-ciphered struct {\n    uint8 field1;\n    uint8 field2;\n    digitally-signed opaque hash[20];\n} UserType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "the contents of hash are used as input for the signing algorithm, and then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. This is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.",
      "ja": "ハッシュの内容は署名アルゴリズムの入力として使用され、構造全体がストリーム暗号で暗号化されます。この構造の長さ（バイト単位）は、field1とfield2の2バイト、署名の長さの2バイト、および署名アルゴリズムの出力の長さになります。署名に使用されるアルゴリズムとキーは、この構造をエンコードまたはデコードする前に既知であるため、これは既知です。"
    },
    {
      "indent": 0,
      "text": "4.8. Constants",
      "section_title": true,
      "ja": "4.8. 定数"
    },
    {
      "indent": 3,
      "text": "Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it. Under-specified types (opaque, variable length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.",
      "ja": "型付き定数は、目的の型のシンボルを宣言してそれに値を割り当てることにより、仕様の目的で定義できます。指定不足の型（不透明、可変長ベクトル、不透明を含む構造体）には値を割り当てることができません。複数要素の構造体またはベクトルのフィールドは省略できません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 f1;\n    uint8 f2;\n} Example1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. HMAC and the Pseudorandom Function",
      "section_title": true,
      "ja": "5. HMACと疑似ランダム関数"
    },
    {
      "indent": 3,
      "text": "A number of operations in the TLS record and handshake layer require a keyed MAC; this is a secure digest of some data protected by a secret. Forging the MAC is infeasible without knowledge of the MAC secret. The construction we use for this operation is known as HMAC, and is described in [HMAC].",
      "ja": "TLSレコードとハンドシェイクレイヤーの多くの操作では、キー付きMACが必要です。これは、シークレットで保護された一部のデータの安全なダイジェストです。 MACシークレットを知らなければ、MACの偽造は不可能です。この操作に使用する構造はHMACと呼ばれ、[HMAC]で説明されています。"
    },
    {
      "indent": 3,
      "text": "HMAC can be used with a variety of different hash algorithms. TLS uses it in the handshake with two different algorithms, MD5 and SHA-1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret, data). Additional hash algorithms can be defined by cipher suites and used to protect record data, but MD5 and SHA-1 are hard coded into the description of the handshaking for this version of the protocol.",
      "ja": "HMACは、さまざまな異なるハッシュアルゴリズムで使用できます。 TLSは、MD5とSHA-1の2つの異なるアルゴリズムを使用してハンドシェイクでこれを使用し、これらをHMAC_MD5（secret、data）およびHMAC_SHA（secret、data）として示します。追加のハッシュアルゴリズムを暗号スイートで定義し、レコードデータを保護するために使用できますが、MD5とSHA-1は、このバージョンのプロトコルのハンドシェイクの説明にハードコーディングされています。"
    },
    {
      "indent": 3,
      "text": "In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudo-random function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.",
      "ja": "さらに、キーの生成または検証のために、シークレットをデータのブロックに拡張するための構造が必要です。この疑似ランダム関数（PRF）は、シークレット、シード、および識別ラベルを入力として受け取り、任意の長さの出力を生成します。"
    },
    {
      "indent": 3,
      "text": "In order to make the PRF as secure as possible, it uses two hash algorithms in a way that should guarantee its security if either algorithm remains secure.",
      "ja": "PRFをできるだけ安全にするために、2つのハッシュアルゴリズムを使用して、いずれかのアルゴリズムが安全なままである場合にそのセキュリティを保証します。"
    },
    {
      "indent": 3,
      "text": "First, we define a data expansion function, P_hash(secret, data) that uses a single hash function to expand a secret and seed into an arbitrary quantity of output:",
      "ja": "最初に、単一のハッシュ関数を使用してシークレットを拡張し、任意の量の出力にシードするデータ拡張関数P_hash（secret、data）を定義します。"
    },
    {
      "indent": 7,
      "text": "P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...",
      "ja": "P_hash（secret、seed）= HMAC_hash（secret、A（1）+ seed）+ HMAC_hash（secret、A（2）+ seed）+ HMAC_hash（secret、A（3）+ seed）+ ..."
    },
    {
      "indent": 3,
      "text": "Where + indicates concatenation.",
      "ja": "+は連結を示します。"
    },
    {
      "indent": 3,
      "text": "A() is defined as:",
      "ja": "A()は次のように定義されます。"
    },
    {
      "indent": 7,
      "text": "A(0) = seed\nA(i) = HMAC_hash(secret, A(i-1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "P_hash can be iterated as many times as is necessary to produce the required quantity of data. For example, if P_SHA-1 is being used to create 64 bytes of data, it will have to be iterated 4 times (through A(4)), creating 80 bytes of output data; the last 16 bytes of the final iteration will then be discarded, leaving 64 bytes of output data.",
      "ja": "P_hashは、必要な量のデータを生成するために必要な回数だけ繰り返すことができます。たとえば、P_SHA-1を使用して64バイトのデータを作成している場合は、（A（4）を介して）4回繰り返して80バイトの出力データを作成する必要があります。最後の反復の最後の16バイトは破棄され、64バイトの出力データが残ります。"
    },
    {
      "indent": 3,
      "text": "TLS's PRF is created by splitting the secret into two halves and using one half to generate data with P_MD5 and the other half to generate data with P_SHA-1, then exclusive-ORing the outputs of these two expansion functions together.",
      "ja": "TLSのPRFは、シークレットを2つに分割し、半分を使用してP_MD5でデータを生成し、残りの半分をP_SHA-1でデータを生成してから、これら2つの拡張関数の出力を排他的論理和します。"
    },
    {
      "indent": 3,
      "text": "S1 and S2 are the two halves of the secret, and each is the same length. S1 is taken from the first half of the secret, S2 from the second half. Their length is created by rounding up the length of the overall secret, divided by two; thus, if the original secret is an odd number of bytes long, the last byte of S1 will be the same as the first byte of S2.",
      "ja": "S1とS2はシークレットの2つの半分であり、それぞれが同じ長さです。 S1は秘密の前半から、S2は後半から取得されます。それらの長さは、秘密全体の長さを2で割った値を切り上げて作成されます。したがって、元のシークレットが奇数バイト長である場合、S1の最後のバイトはS2の最初のバイトと同じになります。"
    },
    {
      "indent": 7,
      "text": "L_S = length in bytes of secret;\nL_S1 = L_S2 = ceil(L_S / 2);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The secret is partitioned into two halves (with the possibility of one shared byte) as described above, S1 taking the first L_S1 bytes, and S2 the last L_S2 bytes.",
      "ja": "上記のように、シークレットは2つの半分に分割され（1つの共有バイトの可能性があります）、S1は最初のL_S1バイトを取り、S2は最後のL_S2バイトを取ります。"
    },
    {
      "indent": 3,
      "text": "The PRF is then defined as the result of mixing the two pseudorandom streams by exclusive-ORing them together.",
      "ja": "PRFは、2つの疑似ランダムストリームを排他的論理和することによって混合した結果として定義されます。"
    },
    {
      "indent": 7,
      "text": "PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR\n                           P_SHA-1(S2, label + seed);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label \"slithy toves\" would be processed by hashing the following bytes:",
      "ja": "ラベルはASCII文字列です。これは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式で含める必要があります。たとえば、「slithy toves」というラベルは、次のバイトをハッシュすることによって処理されます。"
    },
    {
      "indent": 7,
      "text": "73 6C 69 74 68 79 20 74 6F 76 65 73",
      "ja": "73 Taq Taq 74 Taq Haq 20 74 Taq Taq 74 Taq Taq 73"
    },
    {
      "indent": 3,
      "text": "Note that because MD5 produces 16-byte outputs and SHA-1 produces 20-byte outputs, the boundaries of their internal iterations will not be aligned. Generating an 80-byte output will require that P_MD5 iterate through A(5), while P_SHA-1 will only iterate through A(4).",
      "ja": "MD5は16バイトの出力を生成し、SHA-1は20バイトの出力を生成するため、それらの内部反復の境界は揃えられないことに注意してください。 80バイトの出力を生成するには、P_MD5がA（5）を反復する必要がありますが、P_SHA-1はA（4）のみを反復する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. The TLS Record Protocol",
      "section_title": true,
      "ja": "6. TLSレコードプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.",
      "ja": "TLS Record Protocolは階層型プロトコルです。各層で、メッセージには長さ、説明、および内容のフィールドが含まれる場合があります。 Record Protocolは、送信されるメッセージを受け取り、データを管理可能なブロックに断片化し、オプションでデータを圧縮し、MACを適用し、暗号化して、結果を送信します。受信したデータは、復号化、検証、解凍、再構成されてから、上位のクライアントに配信されます。"
    },
    {
      "indent": 3,
      "text": "Four record protocol clients are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record types can be supported by the record protocol. Any new record types SHOULD allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.1). All such values must be defined by RFC 2434 Standards Action. See Section 11 for IANA Considerations for ContentType values.",
      "ja": "このドキュメントでは、ハンドシェイクプロトコル、アラートプロトコル、暗号仕様変更プロトコル、アプリケーションデータプロトコルの4つのレコードプロトコルクライアントについて説明します。 TLSプロトコルの拡張を可能にするために、追加のレコードタイプをレコードプロトコルでサポートできます。新しいレコードタイプは、ここで説明する4つのレコードタイプのContentType値のすぐ上にタイプ値を割り当てる必要があります（付録A.1を参照）。このような値はすべて、RFC 2434標準アクションによって定義されている必要があります。 ContentType値に関するIANAの考慮事項については、セクション11を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a TLS implementation receives a record type it does not understand, it SHOULD just ignore it. Any protocol designed for use over TLS MUST be carefully designed to deal with all possible attacks against it. Note that because the type and length of a record are not protected by encryption, care SHOULD be taken to minimize the value of traffic analysis of these values.",
      "ja": "TLS実装が理解できないレコードタイプを受け取った場合、それを無視する必要があります（SHOULD）。 TLSを介して使用するために設計されたプロトコルは、それに対する可能なすべての攻撃に対処するように注意深く設計されなければなりません。レコードのタイプと長さは暗号化によって保護されないため、これらの値のトラフィック分析の値を最小限に抑えるように注意する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Connection States",
      "section_title": true,
      "ja": "6.1. 接続状態"
    },
    {
      "indent": 3,
      "text": "A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, and encryption algorithm, and a MAC algorithm. In addition, the parameters for these algorithms are known: the MAC secret and the bulk encryption keys for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the Change Cipher Spec can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state that has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.",
      "ja": "TLS接続状態は、TLSレコードプロトコルの動作環境です。圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します。さらに、これらのアルゴリズムのパラメーターは既知です。読み取りと書き込みの両方向の接続のMACシークレットとバルク暗号化キーです。論理的には、未処理の接続状態が常に4つあります。現在の読み取り状態と書き込み状態、および保留中の読み取り状態と書き込み状態です。すべてのレコードは、現在の読み取り状態と書き込み状態で処理されます。保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定でき、Change Cipher Specはいずれかの保留状態を選択的に最新にすることができます。この場合、適切な現在の状態が破棄され、保留状態に置き換えられます。次に、保留状態が空の状態に再初期化されます。セキュリティパラメータで初期化されていない状態を現在の状態にすることは違法です。初期の現在の状態では、暗号化、圧縮、またはMACが使用されないことが常に指定されています。"
    },
    {
      "indent": 3,
      "text": "The security parameters for a TLS Connection read and write state are set by providing the following values:",
      "ja": "TLS接続の読み取りおよび書き込み状態のセキュリティパラメータは、次の値を指定することによって設定されます。"
    },
    {
      "indent": 3,
      "text": "connection end Whether this entity is considered the \"client\" or the \"server\" in this connection.",
      "ja": "このエンティティがこの接続で「クライアント」または「サーバー」と見なされるかどうか。"
    },
    {
      "indent": 3,
      "text": "bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, how much of that key is secret, whether it is a block or stream cipher, and the block size of the cipher (if appropriate).",
      "ja": "バルク暗号化アルゴリズムバルク暗号化に使用されるアルゴリズム。この仕様には、このアルゴリズムの鍵サイズ、秘密鍵の量、ブロック暗号かストリーム暗号か、暗号のブロックサイズ（該当する場合）が含まれます。"
    },
    {
      "indent": 3,
      "text": "MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the hash returned by the MAC algorithm.",
      "ja": "MACアルゴリズムメッセージ認証に使用されるアルゴリズム。この仕様には、MACアルゴリズムによって返されるハッシュのサイズが含まれます。"
    },
    {
      "indent": 3,
      "text": "compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires compression.",
      "ja": "圧縮アルゴリズムデータ圧縮に使用されるアルゴリズム。この仕様には、アルゴリズムが圧縮に必要なすべての情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "master secret A 48-byte secret shared between the two peers in the connection.",
      "ja": "マスターシークレット接続の2つのピア間で共有される48バイトのシークレット。"
    },
    {
      "indent": 3,
      "text": "client random A 32-byte value provided by the client.",
      "ja": "クライアントランダムクライアントが提供する32バイトの値。"
    },
    {
      "indent": 3,
      "text": "server random A 32-byte value provided by the server.",
      "ja": "サーバーランダムサーバーが提供する32バイトの値。"
    },
    {
      "indent": 3,
      "text": "These parameters are defined in the presentation language as:",
      "ja": "これらのパラメータは、プレゼンテーション言語で次のように定義されています。"
    },
    {
      "indent": 7,
      "text": "enum { server, client } ConnectionEnd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum { null, rc4, rc2, des, 3des, des40, idea, aes }\nBulkCipherAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum { stream, block } CipherType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum { null, md5, sha } MACAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* The algorithms specified in CompressionMethod,\n   BulkCipherAlgorithm, and MACAlgorithm may be added to. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    ConnectionEnd          entity;\n    BulkCipherAlgorithm    bulk_cipher_algorithm;\n    CipherType             cipher_type;\n    uint8                  key_size;\n    uint8                  key_material_length;\n    MACAlgorithm           mac_algorithm;\n    uint8                  hash_size;\n    CompressionMethod      compression_algorithm;\n    opaque                 master_secret[48];\n    opaque                 client_random[32];\n    opaque                 server_random[32];\n} SecurityParameters;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The record layer will use the security parameters to generate the following four items:",
      "ja": "レコードレイヤーは、セキュリティパラメーターを使用して、次の4つのアイテムを生成します。"
    },
    {
      "indent": 7,
      "text": "client write MAC secret server write MAC secret client write key server write key",
      "ja": "クライアント書き込みMACシークレットサーバー書き込みMACシークレットクライアント書き込みキーサーバー書き込みキー"
    },
    {
      "indent": 3,
      "text": "The client write parameters are used by the server when receiving and processing records and vice-versa. The algorithm used for generating these items from the security parameters is described in Section 6.3.",
      "ja": "クライアントの書き込みパラメータは、レコードを受信して​​処理するときにサーバーによって使用され、その逆も同様です。セキュリティパラメータからこれらのアイテムを生成するために使用されるアルゴリズムについては、セクション6.3で説明します。"
    },
    {
      "indent": 3,
      "text": "Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states MUST be updated for each record processed. Each connection state includes the following elements:",
      "ja": "セキュリティパラメータを設定してキーを生成したら、現在の状態にすることで接続状態をインスタンス化できます。これらの現在の状態は、処理されるレコードごとに更新する必要があります。各接続状態には、次の要素が含まれます。"
    },
    {
      "indent": 3,
      "text": "compression state The current state of the compression algorithm.",
      "ja": "圧縮状態圧縮アルゴリズムの現在の状態。"
    },
    {
      "indent": 3,
      "text": "cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. For stream ciphers, this will also contain whatever state information is necessary to allow the stream to continue to encrypt or decrypt data.",
      "ja": "暗号化状態暗号化アルゴリズムの現在の状態。これは、その接続用にスケジュールされたキーで構成されます。ストリーム暗号の場合、ストリームにデータの暗号化または復号化を継続させるために必要な状態情報も含まれます。"
    },
    {
      "indent": 3,
      "text": "MAC secret The MAC secret for this connection, as generated above.",
      "ja": "MACシークレット上記で生成された、この接続のMACシークレット。"
    },
    {
      "indent": 3,
      "text": "sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number MUST be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do not wrap. If a TLS implementation would need to wrap a sequence number, it must renegotiate instead. A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.",
      "ja": "シーケンス番号各接続状態にはシーケンス番号が含まれており、読み取り状態と書き込み状態で別々に保持されます。接続状態がアクティブ状態になるときは常に、シーケンス番号をゼロに設定する必要があります。シーケンス番号のタイプはuint64で、2 ^ 64-1を超えることはできません。シーケンス番号は折り返されません。 TLS実装でシーケンス番号をラップする必要がある場合は、代わりに再ネゴシエーションする必要があります。シーケンス番号は各レコードの後に​​増加します。具体的には、特定の接続状態で送信される最初のレコードはシーケンス番号0を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Record layer",
      "section_title": true,
      "ja": "6.2. 記録層"
    },
    {
      "indent": 3,
      "text": "The TLS Record Layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.",
      "ja": "TLS Record Layerは、任意のサイズの空でないブロックで上位の層から未解釈のデータを受け取ります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Fragmentation",
      "section_title": true,
      "ja": "6.2.1. 断片化"
    },
    {
      "indent": 3,
      "text": "The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).",
      "ja": "レコード層は、情報ブロックを2 ^ 14バイト以下のチャンクでデータを運ぶTLSPlaintextレコードにフラグメント化します。クライアントメッセージの境界はレコードレイヤーで保持されません（つまり、同じContentTypeの複数のクライアントメッセージが単一のTLSPlaintextレコードに合体されるか、単一のメッセージが複数のレコードにフラグメント化される場合があります）。"
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 major, minor;\n} ProtocolVersion;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum {\n    change_cipher_spec(20), alert(21), handshake(22),\n    application_data(23), (255)\n} ContentType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type The higher-level protocol used to process the enclosed fragment.",
      "ja": "type囲まれたフラグメントの処理に使用される上位レベルのプロトコル。"
    },
    {
      "indent": 3,
      "text": "version The version of the protocol being employed. This document describes TLS Version 1.1, which uses the version { 3, 2 }. The version value 3.2 is historical: TLS version 1.1 is a minor modification to the TLS 1.0 protocol, which was itself a minor modification to the SSL 3.0 protocol, which bears the version value 3.0. (See Appendix A.1.)",
      "ja": "version使用されているプロトコルのバージョン。このドキュメントでは、バージョン{3、2}を使用するTLSバージョン1.1について説明します。バージョン値3.2は歴史的なものです。TLSバージョン1.1はTLS 1.0プロトコルへのマイナー変更であり、それ自体がバージョン値3.0を持つSSL 3.0プロトコルへのマイナー変更でした。 （付録A.1を参照）"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSPlaintext.fragment. The length should not exceed 2^14.",
      "ja": "length次のTLSPlaintext.fragmentの長さ（バイト単位）。長さは2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The application data. This data is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.",
      "ja": "フラグメントアプリケーションデータ。このデータは透過的であり、typeフィールドで指定された上位プロトコルによって処理される独立したブロックとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Note: Data of different TLS Record layer content types MAY be interleaved. Application data is generally of lower precedence for transmission than other content types. However, records MUST be delivered to the network in the same order as they are protected by the record layer. Recipients MUST receive and process interleaved application layer traffic during handshakes subsequent to the first one on a connection.",
      "ja": "注：異なるTLSレコードレイヤーコンテンツタイプのデータはインターリーブされる場合があります。アプリケーションデータは一般に、他のコンテンツタイプよりも送信の優先順位が低くなります。ただし、レコードは、レコードレイヤーによって保護されているのと同じ順序でネットワークに配信する必要があります。受信者は、接続の最初のハンドシェイクに続くハンドシェイク中に、インターリーブされたアプリケーションレイヤートラフィックを受信して​​処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Record Compression and Decompression",
      "section_title": true,
      "ja": "6.2.2. レコードの圧縮と解凍"
    },
    {
      "indent": 3,
      "text": "All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active.",
      "ja": "すべてのレコードは、現在のセッション状態で定義された圧縮アルゴリズムを使用して圧縮されます。常にアクティブな圧縮アルゴリズムがあります。ただし、最初はCompressionMethod.nullとして定義されています。圧縮アルゴリズムは、TLSPlaintext構造をTLSCompressed構造に変換します。接続状態がアクティブになると、圧縮関数はデフォルトの状態情報で初期化されます。"
    },
    {
      "indent": 3,
      "text": "Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it should report a fatal decompression failure error.",
      "ja": "圧縮はロスレスでなければならず、コンテンツの長さが1024バイトを超えないようにする必要があります。解凍関数が2 ^ 14バイトを超える長さに解凍するTLSCompressed.fragmentを検出した場合、致命的な解凍エラーを報告する必要があります。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;       /* same as TLSPlaintext.type */\n    ProtocolVersion version;/* same as TLSPlaintext.version */\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCompressed.fragment. The length should not exceed 2^14 + 1024.",
      "ja": "length次のTLSCompressed.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 1024を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The compressed form of TLSPlaintext.fragment.",
      "ja": "fragment TLSPlaintext.fragmentの圧縮形式。"
    },
    {
      "indent": 3,
      "text": "Note: A CompressionMethod.null operation is an identity operation; no fields are altered.",
      "ja": "注：CompressionMethod.null操作はID操作です。フィールドは変更されません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.",
      "ja": "実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Record Payload Protection",
      "section_title": true,
      "ja": "6.2.3. ペイロード保護の記録"
    },
    {
      "indent": 3,
      "text": "The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra, or repeated messages are detectable.",
      "ja": "暗号化およびMAC関数は、TLSCompressed構造をTLSCiphertextに変換します。復号化関数はプロセスを逆にします。レコードのMACにはシーケンス番号も含まれているため、欠落、余分、または繰り返しのメッセージを検出できます。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (CipherSpec.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block: GenericBlockCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type The type field is identical to TLSCompressed.type.",
      "ja": "type typeフィールドはTLSCompressed.typeと同じです。"
    },
    {
      "indent": 3,
      "text": "version The version field is identical to TLSCompressed.version.",
      "ja": "version versionフィールドはTLSCompressed.versionと同じです。"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCiphertext.fragment. The length may not exceed 2^14 + 2048.",
      "ja": "length次のTLSCiphertext.fragmentの長さ（バイト単位）。長さは2 ^ 14 + 2048を超えることはできません。"
    },
    {
      "indent": 3,
      "text": "fragment The encrypted form of TLSCompressed.fragment, with the MAC.",
      "ja": "fragment暗号化された形式のTLSCompressed.fragmentとMAC。"
    },
    {
      "indent": 0,
      "text": "6.2.3.1. Null or Standard Stream Cipher",
      "section_title": true,
      "ja": "6.2.3.1. ヌルまたは標準ストリーム暗号"
    },
    {
      "indent": 3,
      "text": "Stream ciphers (including BulkCipherAlgorithm.null, see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.",
      "ja": "ストリーム暗号（BulkCipherAlgorithm.nullを含む。付録A.6を参照）は、TLSCompressed.fragment構造をストリームTLSCiphertext.fragment構造との間で変換します。"
    },
    {
      "indent": 7,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n} GenericStreamCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MAC is generated as:",
      "ja": "MACは次のように生成されます。"
    },
    {
      "indent": 7,
      "text": "HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +\n              TLSCompressed.version + TLSCompressed.length +\n              TLSCompressed.fragment));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where \"+\" denotes concatenation.",
      "ja": "「+」は連結を示します。"
    },
    {
      "indent": 3,
      "text": "seq_num The sequence number for this record.",
      "ja": "seq_numこのレコードのシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "hash The hashing algorithm specified by SecurityParameters.mac_algorithm.",
      "ja": "hash SecurityParameters.mac_algorithmで指定されたハッシュアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the CipherSuite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted, and the MAC size is zero, implying that no MAC is used). TLSCiphertext.length is TLSCompressed.length plus CipherSpec.hash_size.",
      "ja": "MACは暗号化の前に計算されることに注意してください。ストリーム暗号は、MACを含むブロック全体を暗号化します。同期ベクトルを使用しないストリーム暗号（RC4など）の場合、1つのレコードの終わりからのストリーム暗号の状態は、後続のパケットで単純に使用されます。 CipherSuiteがTLS_NULL_WITH_NULL_NULLの場合、暗号化はID操作で構成されます（つまり、データは暗号化されず、MACサイズはゼロであり、MACが使用されないことを意味します）。 TLSCiphertext.lengthは、TLSCompressed.lengthにCipherSpec.hash_sizeを加えたものです。"
    },
    {
      "indent": 0,
      "text": "6.2.3.2. CBC Block Cipher",
      "section_title": true,
      "ja": "6.2.3.2. CBCブロック暗号"
    },
    {
      "indent": 3,
      "text": "For block ciphers (such as RC2, DES, or AES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.",
      "ja": "ブロック暗号（RC2、DES、AESなど）の場合、暗号化およびMAC関数は、TLSCompressed.fragment構造とブロックTLSCiphertext.fragment構造との間で変換を行います。"
    },
    {
      "indent": 7,
      "text": "block-ciphered struct {\n    opaque IV[CipherSpec.block_length];\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n    uint8 padding[GenericBlockCipher.padding_length];\n    uint8 padding_length;\n} GenericBlockCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MAC is generated as described in Section 6.2.3.1.",
      "ja": "MACはセクション6.2.3.1で説明されているように生成されます。"
    },
    {
      "indent": 3,
      "text": "IV Unlike previous versions of SSL and TLS, TLS 1.1 uses an explicit IV in order to prevent the attacks described by [CBCATT]. We recommend the following equivalently strong procedures. For clarity we use the following notation.",
      "ja": "IV以前のバージョンのSSLおよびTLSとは異なり、TLS 1.1は[CBCATT]で説明されている攻撃を防ぐために明示的なIVを使用します。以下の同等の強力な手順をお勧めします。明確にするために、次の表記を使用します。"
    },
    {
      "indent": 6,
      "text": "IV The transmitted value of the IV field in the GenericBlockCipher structure.",
      "ja": "IV GenericBlockCipher構造体のIVフィールドの送信された値。"
    },
    {
      "indent": 6,
      "text": "CBC residue The last ciphertext block of the previous record.",
      "ja": "CBC剰余前のレコードの最後の暗号文ブロック。"
    },
    {
      "indent": 6,
      "text": "mask The actual value that the cipher XORs with the plaintext prior to encryption of the first cipher block of the record.",
      "ja": "maskレコードの最初の暗号ブロックを暗号化する前に、暗号XORと平文との実際の値。"
    },
    {
      "indent": 6,
      "text": "In prior versions of TLS, there was no IV field and the CBC residue and mask were one and the same. See Sections 6.1, 6.2.3.2, and 6.3, of [TLS1.0] for details of TLS 1.0 IV handling.",
      "ja": "TLSの以前のバージョンでは、IVフィールドはなく、CBCの残りとマスクは1つで同じでした。 TLS 1.0 IVの処理の詳細については、[TLS1.0]のセクション6.1、6.2.3.2、および6.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "One of the following two algorithms SHOULD be used to generate the per-record IV:",
      "ja": "次の2つのアルゴリズムのいずれかを使用して、レコードごとのIVを生成する必要があります。"
    },
    {
      "indent": 6,
      "text": "(1) Generate a cryptographically strong random string R of length CipherSpec.block_length. Place R in the IV field. Set the mask to R. Thus, the first cipher block will be encrypted as E(R XOR Data).",
      "ja": "（1）長さCipherSpec.block_lengthの暗号的に強力なランダム文字列Rを生成します。 IVフィールドにRを配置します。マスクをRに設定します。したがって、最初の暗号ブロックはE（R XORデータ）として暗号化されます。"
    },
    {
      "indent": 6,
      "text": "(2) Generate a cryptographically strong random number R of length CipherSpec.block_length and prepend it to the plaintext prior to encryption. In this case either:",
      "ja": "（2）長さCipherSpec.block_lengthの暗号的に強い乱数Rを生成し、暗号化の前に平文の前に付加します。この場合、次のいずれかです。"
    },
    {
      "indent": 10,
      "text": "(a) The cipher may use a fixed mask such as zero. (b) The CBC residue from the previous record may be used as the mask. This preserves maximum code compatibility with TLS 1.0 and SSL 3. It also has the advantage that it does not require the ability to quickly reset the IV, which is known to be a problem on some systems.",
      "ja": "（a）暗号は、ゼロなどの固定マスクを使用できます。 （b）前のレコードのCBC残差をマスクとして使用できます。これにより、TLS 1.0およびSSL 3とのコードの互換性が最大に保たれます。また、一部のシステムで問題となるIVをすばやくリセットする必要がないという利点もあります。"
    },
    {
      "indent": 10,
      "text": "In either (2)(a) or (2)(b) the data (R || data) is fed into the encryption process. The first cipher block (containing E(mask XOR R) is placed in the IV field. The first block of content contains E(IV XOR data).",
      "ja": "（2）（a）または（2）（b）のいずれかでは、データ（R || data）が暗号化プロセスに送られます。最初の暗号ブロック（E（マスクXOR Rを含む）がIVフィールドに配置されます。コンテンツの最初のブロックにはE（IV XORデータ）が含まれます。"
    },
    {
      "indent": 6,
      "text": "The following alternative procedure MAY be used; however, it has not been demonstrated to be as cryptographically strong as the above procedures. The sender prepends a fixed block F to the plaintext (or, alternatively, a block generated with a weak PRNG). He then encrypts as in (2), above, using the CBC residue from the previous block as the mask for the prepended block. Note that in this case the mask for the first record transmitted by the application (the Finished) MUST be generated using a cryptographically strong PRNG.",
      "ja": "次の代替手順を使用できます。ただし、上記の手順ほど暗号的に強力であることは実証されていません。送信者は、固定ブロックFを平文（または、弱いPRNGで生成されたブロック）の前に付加します。次に、前のブロックのCBC残差を先頭に追加されたブロックのマスクとして使用して、上記の（2）のように暗号化します。この場合、アプリケーション（Finished）によって送信される最初のレコードのマスクは、暗号的に強力なPRNGを使用して生成する必要があることに注意してください。"
    },
    {
      "indent": 6,
      "text": "The decryption operation for all three alternatives is the same. The receiver decrypts the entire GenericBlockCipher structure and then discards the first cipher block, corresponding to the IV component.",
      "ja": "3つの選択肢すべての復号化操作は同じです。レシーバーはGenericBlockCipher構造全体を復号化してから、IVコンポーネントに対応する最初の暗号ブロックを破棄します。"
    },
    {
      "indent": 3,
      "text": "padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher's block length. The padding MAY be any length up to 255 bytes, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol that are based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector MUST be filled with the padding length value. The receiver MUST check this padding and SHOULD use the bad_record_mac alert to indicate padding errors.",
      "ja": "平文の長さをブロック暗号のブロック長の整数倍にするために追加されるパディング。パディングは、TLSCiphertext.lengthがブロック長の整数倍になる限り、255バイトまでの任意の長さである可能性があります。交換されたメッセージの長さの分析に基づくプロトコルへの攻撃を妨げるには、必要以上に長い長さが望ましい場合があります。パディングデータベクトルの各uint8には、パディング長の値を入力する必要があります。受信者はこのパディングをチェックしなければならず（MUST）、bad_record_macアラートを使用してパディングエラーを示す必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "padding_length The padding length MUST be such that the total size of the GenericBlockCipher structure is a multiple of the cipher's block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.",
      "ja": "padding_lengthパディングの長さは、GenericBlockCipher構造の合計サイズが暗号のブロック長の倍数になるようにする必要があります。有効な値の範囲は0〜255です。この長さは、padding_lengthフィールド自体を除いたpaddingフィールドの長さを指定します。"
    },
    {
      "indent": 3,
      "text": "The encrypted data length (TLSCiphertext.length) is one more than the sum of CipherSpec.block_length, TLSCompressed.length, CipherSpec.hash_size, and padding_length.",
      "ja": "暗号化されたデータの長さ（TLSCiphertext.length）は、CipherSpec.block_length、TLSCompressed.length、CipherSpec.hash_size、およびpadding_lengthの合計よりも1つ長くなります。"
    },
    {
      "indent": 3,
      "text": "Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the length before padding is 82 bytes (this does not include the IV, which may or may not be encrypted, as discussed above). Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.",
      "ja": "例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイトです（これにはIVは含まれません）。上記のように暗号化されません）。したがって、合計長を8バイト（ブロック長）の偶数倍にするためには、8を法とするパディング長は6に等しくなければなりません。パディングの長さは、6、14、22などで、254まで可能です。パディングの長さが最低限必要な6である場合、パディングは6バイトであり、それぞれに値6が含まれます。したがって、最後の8オクテットブロック暗号化前のGenericBlockCipherはxx 06 06 06 06 06 06 06となります。ここで、xxはMACの最後のオクテットです。"
    },
    {
      "indent": 3,
      "text": "Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical that the entire plaintext of the record be known before any ciphertext is transmitted. Otherwise, it is possible for the attacker to mount the attack described in [CBCATT].",
      "ja": "注：CBCモード（暗号ブロック連鎖）のブロック暗号では、暗号文を送信する前に、レコードの平文全体を知っておくことが重要です。それ以外の場合、攻撃者は[CBCATT]で説明されている攻撃を仕掛けることができます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Canvel et al. [CBCTIME] have demonstrated a timing attack on CBC padding based on the time required to compute the MAC. In order to defend against this attack, implementations MUST ensure that record processing time is essentially the same whether or not the padding is correct. In general, the best way to do this is to compute the MAC even if the padding is incorrect, and only then reject the packet. For instance, if the pad appears to be incorrect, the implementation might assume a zero-length pad and then compute the MAC. This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal.",
      "ja": "実装ノート：Canvel et al。 [CBCTIME]は、MACの計算に必要な時間に基づいて、CBCパディングに対するタイミング攻撃を実証しました。この攻撃を防ぐために、実装では、パディングが正しいかどうかに関係なく、レコード処理時間が基本的に同じであることを確認する必要があります。一般に、これを行う最良の方法は、パディングが正しくない場合でもMACを計算し、その後でのみパケットを拒否することです。たとえば、パッドが正しくないように見える場合、実装では長さゼロのパッドを想定し、MACを計算する場合があります。 MACのパフォーマンスはデータフラグメントのサイズにある程度依存するため、これにより小さなタイミングチャネルが残りますが、既存のMACのブロックサイズが大きく、MACのサイズが小さいため、悪用できるほど十分に大きいとは考えられていません。タイミング信号。"
    },
    {
      "indent": 0,
      "text": "6.3. Key Calculation",
      "section_title": true,
      "ja": "6.3. キー計算"
    },
    {
      "indent": 3,
      "text": "The Record Protocol requires an algorithm to generate keys, and MAC secrets from the security parameters provided by the handshake protocol.",
      "ja": "レコードプロトコルには、キーを生成するアルゴリズムと、ハンドシェイクプロトコルによって提供されるセキュリティパラメータからのMACシークレットが必要です。"
    },
    {
      "indent": 3,
      "text": "The master secret is hashed into a sequence of secure bytes, which are assigned to the MAC secrets and keys required by the current connection state (see Appendix A.6). CipherSpecs require a client write MAC secret, a server write MAC secret, a client write key, and a server write key, each of which is generated from the master secret in that order. Unused values are empty.",
      "ja": "マスターシークレットは、現在の接続状態で必要なMACシークレットとキーに割り当てられている一連のセキュアバイトにハッシュされます（付録A.6を参照）。 CipherSpecには、クライアント書き込みMACシークレット、サーバー書き込みMACシークレット、クライアント書き込みキー、およびサーバー書き込みキーが必要です。これらはそれぞれ、マスターシークレットからこの順序で生成されます。未使用の値は空です。"
    },
    {
      "indent": 3,
      "text": "When keys and MAC secrets are generated, the master secret is used as an entropy source.",
      "ja": "キーとMACシークレットが生成されると、マスターシークレットがエントロピーソースとして使用されます。"
    },
    {
      "indent": 3,
      "text": "To generate the key material, compute",
      "ja": "キーマテリアルを生成するには、"
    },
    {
      "indent": 7,
      "text": "key_block = PRF(SecurityParameters.master_secret, \"key expansion\", SecurityParameters.server_random + SecurityParameters.client_random);",
      "ja": "key_block = PRF（SecurityParameters.master_secret、 \"key Expansion\"、SecurityParameters.server_random + SecurityParameters.client_random）;"
    },
    {
      "indent": 3,
      "text": "until enough output has been generated. Then the key_block is partitioned as follows:",
      "ja": "十分な出力が生成されるまで。次に、key_blockは次のようにパーティション化されます。"
    },
    {
      "indent": 7,
      "text": "client_write_MAC_secret[SecurityParameters.hash_size]\nserver_write_MAC_secret[SecurityParameters.hash_size]\nclient_write_key[SecurityParameters.key_material_length]\nserver_write_key[SecurityParameters.key_material_length]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementation note: The currently defined cipher suite that requires the most material is AES_256_CBC_SHA, defined in [TLSAES]. It requires 2 x 32 byte keys, 2 x 20 byte MAC secrets, and 2 x 16 byte Initialization Vectors, for a total of 136 bytes of key material.",
      "ja": "実装に関するメモ：最も定義が必要な現在定義されている暗号スイートは、[TLSAES]で定義されているAES_256_CBC_SHAです。合計136バイトの鍵素材には、2 x 32バイトの鍵、2 x 20バイトのMACシークレット、および2 x 16バイトの初期化ベクトルが必要です。"
    },
    {
      "indent": 0,
      "text": "7. The TLS Handshaking Protocols",
      "section_title": true,
      "ja": "7. TLSハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "TLS has three subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.",
      "ja": "TLSには3つのサブプロトコルがあり、ピアがレコードレイヤーのセキュリティパラメーターについて合意し、自身を認証し、ネゴシエートされたセキュリティパラメーターをインスタンス化し、エラー状態を互いに報告することができます。"
    },
    {
      "indent": 3,
      "text": "The Handshake Protocol is responsible for negotiating a session, which consists of the following items:",
      "ja": "ハンドシェイクプロトコルは、次の項目で構成されるセッションのネゴシエーションを担当します。"
    },
    {
      "indent": 3,
      "text": "session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.",
      "ja": "セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバーによって選択された任意のバイトシーケンス。"
    },
    {
      "indent": 3,
      "text": "peer certificate X509v3 [X509] certificate of the peer. This element of the state may be null.",
      "ja": "ピア証明書X509v3 [X509]ピアの証明書。状態のこの要素はnullである可能性があります。"
    },
    {
      "indent": 3,
      "text": "compression method The algorithm used to compress data prior to encryption.",
      "ja": "圧縮方式暗号化の前にデータを圧縮するために使用されるアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher spec Specifies the bulk data encryption algorithm (such as null, DES, etc.) and a MAC algorithm (such as MD5 or SHA). It also defines cryptographic attributes such as the hash_size. (See Appendix A.6 for formal definition.)",
      "ja": "暗号仕様バルクデータ暗号化アルゴリズム（null、DESなど）とMACアルゴリズム（MD5またはSHAなど）を指定します。また、hash_sizeなどの暗号化属性も定義します。 （正式な定義については、付録A.6を参照してください。）"
    },
    {
      "indent": 3,
      "text": "master secret 48-byte secret shared between the client and server.",
      "ja": "マスターシークレットクライアントとサーバー間で共有される48バイトのシークレット。"
    },
    {
      "indent": 3,
      "text": "is resumable A flag indicating whether the session can be used to initiate new connections.",
      "ja": "is resumableセッションを使用して新しい接続を開始できるかどうかを示すフラグ。"
    },
    {
      "indent": 3,
      "text": "These items are then used to create security parameters for use by the Record Layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.",
      "ja": "次に、これらのアイテムを使用して、アプリケーションデータを保護するときにレコードレイヤーで使用するセキュリティパラメーターを作成します。 TLSハンドシェイクプロトコルの再開機能により、同じセッションを使用して多くの接続をインスタンス化できます。"
    },
    {
      "indent": 0,
      "text": "7.1. Change Cipher Spec Protocol",
      "section_title": true,
      "ja": "7.1. 暗号仕様プロトコルの変更"
    },
    {
      "indent": 3,
      "text": "The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.",
      "ja": "暗号仕様の変更プロトコルは、暗号化戦略の移行を知らせるために存在します。プロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態で暗号化および圧縮されます。メッセージは、値1の1バイトで構成されます。"
    },
    {
      "indent": 7,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The change cipher spec message is sent by both the client and the server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the Record Layer to immediately copy the read pending state into the read current state.",
      "ja": "暗号仕様変更メッセージはクライアントとサーバーの両方から送信され、後続のレコードが新しくネゴシエートされたCipherSpecとキーで保護されることを受信側に通知します。このメッセージを受信すると、受信側はレコードレイヤーに読み取り保留状態を読み取り現在状態にすぐにコピーするように指示します。"
    },
    {
      "indent": 3,
      "text": "Immediately after sending this message, the sender MUST instruct the record layer to make the write pending state the write active state. (See Section 6.1.) The change cipher spec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying finished message is sent (see Section 7.4.9).",
      "ja": "このメッセージを送信した直後に、送信者はレコードレイヤーに書き込み保留状態を書き込みアクティブ状態にするように指示する必要があります。 （セクション6.1を参照してください。）暗号仕様変更メッセージは、ハンドシェイク中にセキュリティパラメータが合意された後、ただし検証完了メッセージが送信される前に送信されます（セクション7.4.9を参照）。"
    },
    {
      "indent": 3,
      "text": "Note: If a rehandshake occurs while data is flowing on a connection, the communicating parties may continue to send data using the old CipherSpec. However, once the ChangeCipherSpec has been sent, the new CipherSpec MUST be used. The first side to send the ChangeCipherSpec does not know that the other side has finished computing the new keying material (e.g., if it has to perform a time consuming public key operation). Thus, a small window of time, during which the recipient must buffer the data, MAY exist. In practice, with modern machines this interval is likely to be fairly short.",
      "ja": "注：データが接続上を流れている間に再ハンドシェイクが発生した場合、通信側は古いCipherSpecを使用してデータを送信し続ける場合があります。ただし、ChangeCipherSpecが送信されたら、新しいCipherSpecを使用する必要があります。 ChangeCipherSpecを送信する最初の側は、反対側が新しいキー生成情報の計算を完了したことを知りません（たとえば、時間のかかる公開キー操作を実行する必要がある場合）。したがって、受信者がデータをバッファリングしなければならない小さな時間枠が存在する場合があります。実際には、最近のマシンでは、この間隔はかなり短い可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Alert Protocol",
      "section_title": true,
      "ja": "7.2. アラートプロトコル"
    },
    {
      "indent": 9,
      "text": "One of the content types supported by the TLS Record layer is the alert type. Alert messages convey the severity of the message and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier MUST be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.",
      "ja": "TLSレコードレイヤーでサポートされているコンテンツタイプの1つはアラートタイプです。アラートメッセージは、メッセージの重大度とアラートの説明を伝えます。致命的なレベルのアラートメッセージは、接続を即座に終了させます。この場合、セッションに対応する他の接続は継続できますが、セッション識別子を無効にして、失敗したセッションが新しい接続の確立に使用されないようにする必要があります。他のメッセージと同様に、現在の接続状態で指定されているように、アラートメッセージは暗号化および圧縮されます。"
    },
    {
      "indent": 13,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    no_certificate_RESERVED (41),\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48), access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction_RESERVED(60),\n    protocol_version(70),\n    insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    (255)\n} AlertDescription;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2.1. Closure Alerts",
      "section_title": true,
      "ja": "7.2.1. 閉鎖アラート"
    },
    {
      "indent": 3,
      "text": "The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.",
      "ja": "クライアントとサーバーは、切り捨て攻撃を回避するために、接続が終了しているという知識を共有する必要があります。どちらの当事者も終了メッセージの交換を開始できます。"
    },
    {
      "indent": 3,
      "text": "close_notify This message notifies the recipient that the sender will not send any more messages on this connection. Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed. This is a change from TLS 1.0 to conform with widespread implementation practice.",
      "ja": "close_notifyこのメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します。 TLS 1.1以降、接続を適切に閉じるのに失敗しても、セッションを再開する必要はなくなりました。これは、広範囲に及ぶ実装慣行に準拠するためのTLS 1.0からの変更点です。"
    },
    {
      "indent": 3,
      "text": "Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.",
      "ja": "どちらのパーティも、close_notifyアラートを送信してクローズを開始できます。閉鎖アラートの後に受信したデータは無視されます。"
    },
    {
      "indent": 3,
      "text": "Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection. The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.",
      "ja": "他の致命的なアラートが送信されない限り、各パーティは接続の書き込み側を閉じる前にclose_notifyアラートを送信する必要があります。他方のパーティは、自分自身のclose_notifyアラートで応答し、保留中の書き込みを破棄して、接続をすぐに閉じる必要があります。クローズのイニシエーターが、接続の読み取り側を閉じる前に、応答するclose_notifyアラートを待つ必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.",
      "ja": "TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後、基になるトランスポートを介してデータが伝送される可能性がある場合、TLS実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答するclose_notifyアラートを受信する必要があります。アプリケーションプロトコルが追加のデータを転送せず、基になるトランスポート接続のみを閉じる場合、実装は、応答するclose_notifyを待たずにトランスポートを閉じることを選択できます（MAY）。この標準のどの部分も、接続のオープンまたはクローズ時を含め、TLSの使用プロファイルがデータ転送を管理する方法を決定するために取られるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.",
      "ja": "注：接続を閉じると、トランスポートを破棄する前に、保留中のデータが確実に配信されると想定されています。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Error Alerts",
      "section_title": true,
      "ja": "7.2.2. エラーアラート"
    },
    {
      "indent": 3,
      "text": "Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed. The following error alerts are defined:",
      "ja": "TLSハンドシェイクプロトコルでのエラー処理は非常に簡単です。エラーが検出されると、検出側は相手にメッセージを送信します。致命的な警告メッセージを送信または受信すると、両者は直ちに接続を閉じます。サーバーとクライアントは、失敗した接続に関連付けられたセッション識別子、キー、およびシークレットをすべて忘れる必要があります。したがって、致命的なアラートで終了した接続は再開してはなりません。次のエラーアラートが定義されています。"
    },
    {
      "indent": 3,
      "text": "unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.",
      "ja": "予期しないメッセージを受信しました。このアラートは常に致命的であり、適切な実装間の通信で監視されることはありません。"
    },
    {
      "indent": 3,
      "text": "bad_record_mac This alert is returned if a record is received with an incorrect MAC. This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length, or its padding values, when checked, weren't correct. This message is always fatal.",
      "ja": "bad_record_macこのアラートは、不正なMACでレコードを受信した場合に返されます。このアラートは、TLSCiphertextが無効な方法で復号化されたためにアラートが送信された場合にも返される必要があります。つまり、ブロック長の偶数倍でなかったか、チェックされたときのパディング値が正しくなかったかのいずれかです。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decryption_failed This alert MAY be returned if a TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length, or its padding values, when checked, weren't correct. This message is always fatal.",
      "ja": "decryption_failedこのアラートは、TLSCiphertextが無効な方法で復号化された場合に返される可能性があります。それは、ブロック長の偶数倍でなかったか、チェックしたときのパディング値が正しくなかったかのいずれかです。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "Note: Differentiating between bad_record_mac and decryption_failed alerts may permit certain attacks against CBC mode as used in TLS [CBCATT]. It is preferable to uniformly use the bad_record_mac alert to hide the specific type of the error.",
      "ja": "注：bad_record_macアラートとdecryption_failedアラートを区別すると、TLS [CBCATT]で使用されるCBCモードに対する特定の攻撃が許可される場合があります。エラーの特定のタイプを非表示にするには、bad_record_macアラートを一律に使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "record_overflow A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.",
      "ja": "record_overflow 2 ^ 14 + 2048バイトを超える長さのTLSCiphertextレコード、または2 ^ 14 + 1024バイトを超えるTLSCompressedレコードに復号化されたレコードを受信しました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decompression_failure The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal.",
      "ja": "decompression_failure The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal."
    },
    {
      "indent": 3,
      "text": "handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.",
      "ja": "handshake_failure handshake_failureアラートメッセージの受信は、送信者が、利用可能なオプションを前提として、許容可能なセキュリティパラメータのセットをネゴシエートできなかったことを示します。これは致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "no_certificate_RESERVED This alert was used in SSLv3 but not in TLS. It should not be sent by compliant implementations.",
      "ja": "no_certificate_RESERVEDこのアラートはSSLv3では使用されましたが、TLSでは使用されませんでした。準拠した実装では送信しないでください。"
    },
    {
      "indent": 3,
      "text": "bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.",
      "ja": "bad_certificate証明書が破損しているか、正しく検証されない署名が含まれているなど。"
    },
    {
      "indent": 3,
      "text": "unsupported_certificate A certificate was of an unsupported type.",
      "ja": "unsupported_certificate証明書のタイプはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "certificate_revoked A certificate was revoked by its signer.",
      "ja": "certificate_revoked証明書が署名者によって取り消されました。"
    },
    {
      "indent": 3,
      "text": "certificate_expired A certificate has expired or is not currently valid.",
      "ja": "certificate_expired A certificate has expired or is not currently valid."
    },
    {
      "indent": 3,
      "text": "certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.",
      "ja": "certificate_unknown証明書の処理中に他の（指定されていない）問題が発生し、受け入れられなくなりました。"
    },
    {
      "indent": 3,
      "text": "illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This is always fatal.",
      "ja": "illegal_parameterハンドシェイクのフィールドが範囲外であるか、他のフィールドと矛盾しています。これは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA. This message is always fatal.",
      "ja": "unknown_ca有効な証明書チェーンまたは部分チェーンを受け取りましたが、CA証明書が見つからなかったか、既知の信頼できるCAと一致しなかったため、証明書は受け入れられませんでした。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.",
      "ja": "access_denied有効な証明書が受信されましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.",
      "ja": "decode_error一部のフィールドが指定された範囲外だったか、メッセージの長さが正しくなかったため、メッセージをデコードできませんでした。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.",
      "ja": "decrypt_errorハンドシェイク暗号化操作が失敗しました。これには、署名の正しい検証、鍵交換の復号化、完成したメッセージの検証などが含まれません。"
    },
    {
      "indent": 3,
      "text": "export_restriction_RESERVED This alert was used in TLS 1.0 but not TLS 1.1.",
      "ja": "export_restriction_RESERVED This alert was used in TLS 1.0 but not TLS 1.1."
    },
    {
      "indent": 3,
      "text": "protocol_version The protocol version the client has attempted to negotiate is recognized but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.",
      "ja": "protocol_versionクライアントが交渉しようとしたプロトコルバージョンは認識されますが、サポートされていません。 （たとえば、古いプロトコルバージョンは、セキュリティ上の理由から回避される場合があります）。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.",
      "ja": "insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal."
    },
    {
      "indent": 3,
      "text": "internal_error An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue. This message is always fatal.",
      "ja": "internal_errorピアに関係のない内部エラーまたはプロトコルの正確性（メモリ割り当ての失敗など）により、続行できません。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.",
      "ja": "user_canceledこのハンドシェイクは、プロトコル障害とは無関係の何らかの理由でキャンセルされています。ハンドシェイクの完了後にユーザーが操作をキャンセルした場合は、close_notifyを送信して接続を閉じるだけの方が適切です。このアラートの後には、close_notifyが続く必要があります。このメッセージは通常警告です。"
    },
    {
      "indent": 3,
      "text": "no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert. At that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate is where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.",
      "ja": "no_renegotiation最初のハンドシェイク後に、hello要求に応答してクライアントから送信されるか、クライアントhelloに応答してサーバーから送信されます。これらのいずれかは通常、再交渉につながります。それが適切でない場合、受信者はこのアラートで応答する必要があります。その時点で、元のリクエスターは接続を続行するかどうかを決定できます。これが適切なケースの1つは、サーバーが要求を満たすためにプロセスを生成した場合です。プロセスは、起動時にセキュリティパラメータ（キーの長さ、認証など）を受け取り、その後のこれらのパラメータの変更を伝達することが困難になる場合があります。このメッセージは常に警告です。"
    },
    {
      "indent": 3,
      "text": "For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether this is a fatal error or not; if an alert with a level of warning is received, the receiving party MAY decide at its discretion whether to treat this as a fatal error or not. However, all messages that are transmitted with a level of fatal MUST be treated as fatal messages.",
      "ja": "アラートレベルが明示的に指定されていないすべてのエラーについて、送信側は、これが致命的なエラーであるかどうかを独自の裁量で判断してもよい（MAY）。警告レベルのアラートが受信された場合、受信側は、その裁量でこれを致命的なエラーとして扱うかどうかを決定できます（MAY）。ただし、致命的なレベルで送信されるすべてのメッセージは、致命的なメッセージとして扱われる必要があります。"
    },
    {
      "indent": 3,
      "text": "New alert values MUST be defined by RFC 2434 Standards Action. See Section 11 for IANA Considerations for alert values.",
      "ja": "新しいアラート値は、RFC 2434標準アクションによって定義されている必要があります。アラート値のIANAに関する考慮事項については、セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3. Handshake Protocol Overview",
      "section_title": true,
      "ja": "7.3. ハンドシェイクプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS Record Layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.",
      "ja": "セッション状態の暗号パラメーターは、TLSレコードレイヤー上で動作するTLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバーが最初に通信を開始すると、プロトコルバージョンに同意し、暗号化アルゴリズムを選択し、オプションで相互に認証し、公開鍵暗号化技術を使用して共有シークレットを生成します。"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol involves the following steps:",
      "ja": "TLSハンドシェイクプロトコルには、次の手順が含まれます。"
    },
    {
      "indent": 3,
      "text": "- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.",
      "ja": "- helloメッセージを交換してアルゴリズムについて合意し、ランダムな値を交換し、セッションの再開を確認します。"
    },
    {
      "indent": 3,
      "text": "- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.",
      "ja": "- 必要な暗号化パラメーターを交換して、クライアントとサーバーがプリマスターシークレットについて合意できるようにします。"
    },
    {
      "indent": 3,
      "text": "- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.",
      "ja": "- 証明書と暗号化情報を交換して、クライアントとサーバーが自分自身を認証できるようにします。"
    },
    {
      "indent": 3,
      "text": "- Generate a master secret from the premaster secret and exchanged random values.",
      "ja": "- Generate a master secret from the premaster secret and exchanged random values."
    },
    {
      "indent": 3,
      "text": "- Provide security parameters to the record layer.",
      "ja": "- レコードパラメータにセキュリティパラメータを提供します。"
    },
    {
      "indent": 3,
      "text": "- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.",
      "ja": "- クライアントとサーバーが、ピアが同じセキュリティパラメータを計算したことと、攻撃者が改ざんせずにハンドシェイクが行われたことを確認できるようにします。"
    },
    {
      "indent": 3,
      "text": "Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two peers. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available. For example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024 bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.",
      "ja": "上位層は、TLSが常に2つのピア間の可能な限り最強の接続をネゴシエートするかどうかに過度に依存しないように注意してください。中間者攻撃者が2つのエンティティをサポートする最も安全性の低い方法にドロップダウンさせる方法はいくつかあります。このプロトコルは、このリスクを最小限に抑えるように設計されていますが、まだ利用可能な攻撃があります。たとえば、攻撃者は、セキュリティで保護されたサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続をネゴシエートさせたりする可能性があります。基本的なルールは、より高いレベルはセキュリティ要件が何であるかを認識している必要があり、必要なものよりも安全性の低いチャネルを介して情報を送信しないことです。 TLSプロトコルは安全であり、あらゆる暗号スイートが約束されたレベルのセキュリティを提供します。1024ビットのRSA鍵交換で3DESを、証明書を検証したホストとネゴシエートすると、その安全性が期待できます。"
    },
    {
      "indent": 3,
      "text": "However, one SHOULD never send data over a link encrypted with 40-bit security unless one feels that data is worth no more than the effort required to break that encryption.",
      "ja": "ただし、40ビットのセキュリティで暗号化されたリンクを介してデータを送信してはならない（SHOULD）。ただし、その暗号化を解くために必要な労力以上の価値はないと感じた場合を除きます。"
    },
    {
      "indent": 3,
      "text": "These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a client hello message to which the server must respond with a server hello message, or else a fatal error will occur and the connection will fail. The client hello and server hello are used to establish security enhancement capabilities between client and server. The client hello and server hello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.",
      "ja": "これらの目標は、次のように要約できるハンドシェイクプロトコルによって達成されます。クライアントは、サーバーがサーバーのhelloメッセージで応答する必要があるクライアントのhelloメッセージを送信します。そうしないと、致命的なエラーが発生して接続が失敗します。 client helloとserver helloは、クライアントとサーバー間のセキュリティ強化機能を確立するために使用されます。 client helloとserver helloは、プロトコルバージョン、セッションID、暗号スイート、および圧縮方法の属性を確立します。さらに、2つのランダムな値が生成および交換されます：ClientHello.randomとServerHello.random。"
    },
    {
      "indent": 3,
      "text": "The actual key exchange uses up to four messages: the server certificate, the server key exchange, the client certificate, and the client key exchange. New key exchange methods can be created by specifying a format for these messages and by defining the use of the messages to allow the client and server to agree upon a shared secret. This secret MUST be quite long; currently defined key exchange methods exchange secrets that range from 48 to 128 bytes in length.",
      "ja": "実際の鍵交換は最大4つのメッセージを使用します。サーバー証明書、サーバー鍵交換、クライアント証明書、およびクライアント鍵交換です。これらのメッセージの形式を指定し、メッセージの使用を定義してクライアントとサーバーが共有シークレットに同意できるようにすることで、新しい鍵交換方法を作成できます。この秘密はかなり長くなければなりません。現在定義されている鍵交換方式は、長さが48〜128バイトの秘密を交換します。"
    },
    {
      "indent": 3,
      "text": "Following the hello messages, the server will send its certificate, if it is to be authenticated. Additionally, a server key exchange message may be sent, if it is required (e.g., if the server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Next, the server will send the server hello done message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a certificate request message, the client must send the certificate message. The client key exchange message is now sent, and the content of that message will depend on the public key algorithm selected between the client hello and the server hello. If the client has sent a certificate with signing ability, a digitally- signed certificate verify message is sent to explicitly verify the certificate.",
      "ja": "helloメッセージに続いて、サーバーは、認証される場合に証明書を送信します。さらに、必要な場合（サーバーに証明書がない場合、またはサーバーの証明書が署名専用の場合など）は、サーバーの鍵交換メッセージが送信される場合があります。サーバーが認証されると、選択された暗号スイートに適切である場合、サーバーはクライアントに証明書を要求します。次に、サーバーはサーバーのhello doneメッセージを送信し、ハンドシェイクのhelloメッセージフェーズが完了したことを示します。その後、サーバーはクライアントの応答を待ちます。サーバーが証明書要求メッセージを送信した場合、クライアントは証明書メッセージを送信する必要があります。これでクライアントキー交換メッセージが送信され、そのメッセージの内容は、クライアントハローとサーバーハローの間で選択された公開キーアルゴリズムに依存します。クライアントが署名機能付きの証明書を送信した場合、デジタル署名された証明書検証メッセージが送信され、証明書を明示的に検証します。"
    },
    {
      "indent": 3,
      "text": "At this point, a change cipher spec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the finished message under the new algorithms, keys, and secrets. In response, the server will send its own change cipher spec message, transfer the pending to the current Cipher Spec, and send its finished message under the new Cipher Spec. At this point, the handshake is complete, and the client and server may begin to exchange application layer data. (See flow chart below.) Application data MUST NOT be sent prior to the completion of the first handshake (before a cipher suite other TLS_NULL_WITH_NULL_NULL is established).",
      "ja": "この時点で、クライアントは暗号仕様変更メッセージを送信し、クライアントは保留中の暗号仕様を現在の暗号仕様にコピーします。次に、クライアントは、新しいアルゴリズム、キー、およびシークレットで完成したメッセージをすぐに送信します。それに応じて、サーバーは独自の暗号仕様変更メッセージを送信し、保留を現在の暗号仕様に転送し、新しい暗号仕様で完成したメッセージを送信します。この時点で、ハンドシェイクが完了し、クライアントとサーバーがアプリケーション層データの交換を開始します。 （以下のフローチャートを参照してください。）アプリケーションデータは、最初のハンドシェイクの完了前（他のTLS_NULL_WITH_NULL_NULL暗号スイートが確立される前）に送信してはなりません（MUST NOT）。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                  -------->\n                                                ServerHello\n                                               Certificate*\n                                         ServerKeyExchange*\n                                        CertificateRequest*\n                             <--------      ServerHelloDone\nCertificate*\nClientKeyExchange\nCertificateVerify*\n[ChangeCipherSpec]\nFinished                     -------->\n                                         [ChangeCipherSpec]\n                             <--------             Finished\nApplication Data             <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Fig. 1. Message flow for a full handshake",
      "ja": "図1.フルハンドシェイクのメッセージフロー"
    },
    {
      "indent": 6,
      "text": "* Indicates optional or situation-dependent messages that are not always sent.",
      "ja": "* 常に送信されるわけではないオプションのメッセージまたは状況依存のメッセージを示します。"
    },
    {
      "indent": 3,
      "text": "Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.",
      "ja": "注：パイプラインのストールを回避するために、ChangeCipherSpecは独立したTLSプロトコルコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters), the message flow is as follows:",
      "ja": "クライアントとサーバーが（新しいセキュリティパラメータをネゴシエートする代わりに）以前のセッションを再開するか、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります。"
    },
    {
      "indent": 3,
      "text": "The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match.",
      "ja": "The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match."
    },
    {
      "indent": 3,
      "text": "If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server MUST send change cipher spec messages and proceed directly to finished messages. Once the re-establishment is complete, the client and server MAY begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID and the TLS client and server perform a full handshake.",
      "ja": "一致が見つかり、サーバーが指定されたセッション状態で接続を再確立する用意がある場合、同じセッションID値でServerHelloを送信します。この時点で、クライアントとサーバーの両方が暗号仕様変更メッセージを送信し、完了したメッセージに直接進む必要があります。再確立が完了すると、クライアントとサーバーはアプリケーション層データの交換を開始する場合があります。 （以下のフローチャートを参照してください。）セッションIDの一致が見つからない場合、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバーは完全なハンドシェイクを実行します。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                   -------->\n                                                 ServerHello\n                                          [ChangeCipherSpec]\n                              <--------             Finished\n[ChangeCipherSpec]\nFinished                      -------->\nApplication Data              <------->     Application Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Fig. 2. Message flow for an abbreviated handshake",
      "ja": "図2.省略されたハンドシェイクのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "The contents and significance of each message will be presented in detail in the following sections.",
      "ja": "各メッセージの内容と重要性については、次のセクションで詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "7.4. Handshake Protocol",
      "section_title": true,
      "ja": "7.4. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS Record Layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.",
      "ja": "TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義済みの高レベルクライアントの1つです。このプロトコルは、セッションの安全な属性をネゴシエートするために使用されます。ハンドシェイクメッセージはTLSレコードレイヤーに提供され、1つ以上のTLSPlaintext構造内にカプセル化されます。これらの構造は、現在アクティブなセッション状態で指定されたとおりに処理および送信されます。"
    },
    {
      "indent": 6,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), (255)\n} HandshakeType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* bytes in message */\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The handshake protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but is described only in its first position. The one message that is not bound by these ordering rules is the Hello Request message, which can be sent at any time, but which should be ignored by the client if it arrives in the middle of a handshake.",
      "ja": "以下に、ハンドシェイクプロトコルメッセージを送信する必要がある順序で示します。予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーが発生します。ただし、不要なハンドシェイクメッセージは省略できます。順序付けの1つの例外に注意してください。証明書メッセージはハンドシェイクで2回（サーバーからクライアントへ、次にクライアントからサーバーへ）使用されますが、最初の位置でのみ説明されています。これらの順序付けルールに拘束されないメッセージは、Hello Requestメッセージです。これはいつでも送信できますが、ハンドシェイクの途中で到着した場合、クライアントは無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "New Handshake message type values MUST be defined via RFC 2434 Standards Action. See Section 11 for IANA Considerations for these values.",
      "ja": "新しいハンドシェイクメッセージタイプの値は、RFC 2434標準アクションを介して定義する必要があります。これらの値に関するIANAの考慮事項については、セクション11を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Hello Messages",
      "section_title": true,
      "ja": "7.4.1. こんにちはメッセージ"
    },
    {
      "indent": 3,
      "text": "The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the Record Layer's connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.",
      "ja": "helloフェーズメッセージは、クライアントとサーバー間でセキュリティ強化機能を交換するために使用されます。新しいセッションが始まると、レコードレイヤーの接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態は、再ネゴシエーションメッセージに使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4.1.1. Hello request",
      "section_title": true,
      "ja": "7.4.1.1. こんにちはリクエスト"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "When this message will be sent:"
    },
    {
      "indent": 6,
      "text": "The hello request message MAY be sent by the server at any time.",
      "ja": "The hello request message MAY be sent by the server at any time."
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "Hello request is a simple notification that the client should begin the negotiation process anew by sending a client hello message when convenient. This message will be ignored by the client if the client is currently negotiating a session. This message may be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a hello request but does not receive a client hello in response, it may close the connection with a fatal alert.",
      "ja": "Hello要求は、クライアントが都合の良いときにクライアントのHelloメッセージを送信することによって、ネゴシエーションプロセスを新たに開始する必要があるという単純な通知です。クライアントが現在セッションをネゴシエートしている場合、このメッセージはクライアントによって無視されます。このメッセージは、セッションの再ネゴシエーションを望まない場合はクライアントによって無視されるか、必要に応じてno_renegotiationアラートで応答する場合があります。ハンドシェイクメッセージはアプリケーションデータよりも送信の優先度を高くすることを目的としているため、クライアントから受信するレコードが数個以下になる前にネゴシエーションが開始されることが予想されます。サーバーがhelloリクエストを送信しても、応答としてclient helloを受信しない場合は、致命的なアラートで接続を閉じることがあります。"
    },
    {
      "indent": 6,
      "text": "After sending a hello request, servers SHOULD not repeat the request until the subsequent handshake negotiation is complete.",
      "ja": "helloリクエストを送信した後、サーバーは次のハンドシェイクネゴシエーションが完了するまでリクエストを繰り返さないでください（SHOULD）。"
    },
    {
      "indent": 9,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 13,
      "text": "struct { } HelloRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: This message MUST NOT be included in the message hashes that are maintained throughout the handshake and used in the finished messages and the certificate verify message.",
      "ja": "注：このメッセージは、ハンドシェイク全体で維持され、完成したメッセージと証明書検証メッセージで使用されるメッセージハッシュに含めることはできません。"
    },
    {
      "indent": 0,
      "text": "7.4.1.2. Client Hello",
      "section_title": true,
      "ja": "7.4.1.2. こんにちは"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "When a client first connects to a server it is required to send the client hello as its first message. The client can also send a client hello in response to a hello request or on its own initiative in order to renegotiate the security parameters in an existing connection.",
      "ja": "クライアントが最初にサーバーに接続するとき、最初のメッセージとしてクライアントのHelloを送信する必要があります。クライアントは、既存の接続でセキュリティパラメータを再ネゴシエートするために、helloリクエストへの応答として、または独自のイニシアチブでクライアントhelloを送信することもできます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "The client hello message includes a random structure, which is used later in the protocol.",
      "ja": "The client hello message includes a random structure, which is used later in the protocol."
    },
    {
      "indent": 6,
      "text": "struct {\n   uint32 gmt_unix_time;\n   opaque random_bytes[28];\n} Random;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT, ignoring leap seconds) according to the sender's internal clock. Clocks are not required to be set correctly by the basic TLS Protocol; higher-level or application protocols may define additional requirements.",
      "ja": "gmt_unix_time送信者の内部クロックによる、標準のUNIX 32ビット形式の現在の日時（1970年1月1日から始まる午前0時からの秒数、GMT、うるう秒は無視）。基本的なTLSプロトコルでクロックを正しく設定する必要はありません。より高いレベルまたはアプリケーションプロトコルは、追加の要件を定義する場合があります。"
    },
    {
      "indent": 9,
      "text": "random_bytes 28 bytes generated by a secure random number generator.",
      "ja": "random_bytes 28 bytes generated by a secure random number generator."
    },
    {
      "indent": 3,
      "text": "The client hello message includes a variable-length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier MAY be from an earlier connection, from this connection, or from another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, and the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until it is removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.",
      "ja": "クライアントのhelloメッセージには、可変長のセッション識別子が含まれています。空でない場合、値は、同じクライアントと、クライアントが再利用したいセキュリティパラメータを持つサーバー間のセッションを識別します。セッション識別子は、以前の接続、この接続、または現在アクティブな別の接続からのものである場合があります。 2番目のオプションは、クライアントが接続のランダムな構造と派生値のみを更新する場合に便利です。3番目のオプションを使用すると、完全なハンドシェイクプロトコルを繰り返さなくても、複数の独立した安全な接続を確立できます。これらの独立した接続は、順次または同時に発生します。セッションIDは、ネゴシエートするハンドシェイクが完了メッセージの交換で完了したときに有効になり、エージングまたはセッションに関連付けられた接続で致命的なエラーが発生したために削除されるまで保持されます。 SessionIDの実際の内容はサーバーによって定義されます。"
    },
    {
      "indent": 6,
      "text": "opaque SessionID<0..32>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers MUST not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)",
      "ja": "Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers MUST not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)"
    },
    {
      "indent": 3,
      "text": "The CipherSuite list, passed from the client to the server in the client hello message, contains the combinations of cryptographic algorithms supported by the client in order of the client's preference (favorite choice first). Each CipherSuite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length), and a MAC algorithm. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection.",
      "ja": "クライアントのhelloメッセージでクライアントからサーバーに渡されるCipherSuiteリストには、クライアントがサポートする暗号化アルゴリズムの組み合わせが、クライアントの優先順（優先順が最初）に含まれています。各CipherSuiteは、鍵交換アルゴリズム、バルク暗号化アルゴリズム（秘密鍵の長さを含む）、およびMACアルゴリズムを定義します。サーバーは暗号スイートを選択するか、受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗アラートを返し、接続を閉じます。"
    },
    {
      "indent": 6,
      "text": "uint8 CipherSuite[2];    /* Cryptographic suite selector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client hello includes a list of compression algorithms supported by the client, ordered according to the client's preference.",
      "ja": "クライアントのhelloには、クライアントがサポートする圧縮アルゴリズムのリストが含まれており、クライアントの設定に従って並べられています。"
    },
    {
      "indent": 6,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-1>;\n    CompressionMethod compression_methods<1..2^8-1>;\n} ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "client_version The version of the TLS protocol by which the client wishes to communicate during this session. This SHOULD be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.2. (See Appendix E for details about backward compatibility.)",
      "ja": "client_versionクライアントがこのセッション中に通信したいTLSプロトコルのバージョン。これは、クライアントがサポートする最新の（最も価値の高い）バージョンである必要があります（SHOULD）。このバージョンの仕様では、バージョンは3.2になります。 （下位互換性の詳細については、付録Eを参照してください。）"
    },
    {
      "indent": 3,
      "text": "random A client-generated random structure.",
      "ja": "randomクライアントが生成したランダムな構造。"
    },
    {
      "indent": 3,
      "text": "session_id The ID of a session the client wishes to use for this connection. This field should be empty if no session_id is available or if the client wishes to generate new security parameters.",
      "ja": "session_idクライアントがこの接続に使用するセッションのID。 session_idが使用できない場合、またはクライアントが新しいセキュリティパラメータを生成する場合は、このフィールドを空にする必要があります。"
    },
    {
      "indent": 3,
      "text": "cipher_suites This is a list of the cryptographic options supported by the client, with the client's first preference first. If the session_id field is not empty (implying a session resumption request) this vector MUST include at least the cipher_suite from that session. Values are defined in Appendix A.5.",
      "ja": "cipher_suitesこれは、クライアントがサポートする暗号化オプションのリストで、クライアントの最初の設定が最初です。 session_idフィールドが空でない場合（セッション再開要求を意味します）、このベクターには少なくともそのセッションからのcipher_suiteが含まれている必要があります。値は付録A.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request) it MUST include the compression_method from that session. This vector MUST contain, and all implementations MUST support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.",
      "ja": "compression_methodsこれは、クライアント設定でソートされた、クライアントでサポートされている圧縮方式のリストです。 session_idフィールドが空でない場合（セッション再開要求を意味します）、そのセッションからのcompression_methodを含める必要があります。このベクターはCompressionMethod.nullを含んでいる必要があり、すべての実装がサポートする必要があります。したがって、クライアントとサーバーは常に圧縮方法について合意することができます。"
    },
    {
      "indent": 3,
      "text": "After sending the client hello message, the client waits for a server hello message. Any other handshake message returned by the server except for a hello request is treated as a fatal error.",
      "ja": "クライアントのhelloメッセージを送信した後、クライアントはサーバーのhelloメッセージを待ちます。 helloリクエストを除く、サーバーから返されるその他のハンドシェイクメッセージは、致命的なエラーとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Forward compatibility note: In the interests of forward compatibility, it is permitted that a client hello message include extra data after the compression methods. This data MUST be included in the handshake hashes, but must otherwise be ignored. This is the only handshake message for which this is legal; for all other messages, the amount of data in the message MUST match the description of the message precisely.",
      "ja": "前方互換性に関する注意：前方互換性のために、クライアントhelloメッセージに圧縮方法の後に追加のデータを含めることが許可されています。このデータはハンドシェイクハッシュに含める必要がありますが、それ以外の場合は無視する必要があります。これが合法な唯一のハンドシェイクメッセージです。他のすべてのメッセージの場合、メッセージ内のデータ量はメッセージの説明と正確に一致する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: For the intended use of trailing data in the ClientHello, see RFC 3546 [TLSEXT].",
      "ja": "注：ClientHelloでのトレーリングデータの使用目的については、RFC 3546 [TLSEXT]を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.4.1.3. Server Hello",
      "section_title": true,
      "ja": "7.4.1.3. サーバーこんにちは"
    },
    {
      "indent": 3,
      "text": "The server will send this message in response to a client hello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.",
      "ja": "サーバーは、受け入れ可能なアルゴリズムのセットを見つけることができたときに、クライアントのHelloメッセージに応答してこのメ​​ッセージを送信します。そのような一致が見つからない場合は、ハンドシェイク失敗アラートで応答します。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 7,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n} ServerHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.2. (See Appendix E for details about backward compatibility.)",
      "ja": "server_versionこのフィールドには、クライアントがクライアントhelloで提案した値の低い方と、サーバーがサポートする最も高い方が含まれます。このバージョンの仕様では、バージョンは3.2です。 （下位互換性の詳細については、付録Eを参照してください。）"
    },
    {
      "indent": 3,
      "text": "random This structure is generated by the server and MUST be independently generated from the ClientHello.random.",
      "ja": "randomこの構造はサーバーによって生成され、ClientHello.randomから独立して生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the finished messages. Otherwise this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.",
      "ja": "session_idこれは、この接続に対応するセッションのIDです。 ClientHello.session_idが空でない場合、サーバーは一致するかどうかセッションキャッシュを調べます。一致が見つかり、サーバーが指定されたセッション状態を使用して新しい接続を確立する用意がある場合、サーバーはクライアントから提供されたものと同じ値で応答します。これは、再開されたセッションを示し、当事者が完了したメッセージに直接進む必要があることを示します。それ以外の場合、このフィールドには、新しいセッションを識別する別の値が含まれます。サーバーは空のsession_idを返し、セッションがキャッシュされないため再開できないことを示します。セッションを再開する場合は、最初にネゴシエートしたときと同じ暗号スイートを使用して再開する必要があります。"
    },
    {
      "indent": 3,
      "text": "cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions, this field is the value from the state of the session being resumed.",
      "ja": "cipher_suiteサーバーがClientHello.cipher_suitesのリストから選択した単一の暗号スイート。再開されたセッションの場合、このフィールドは、再開されているセッションの状態からの値です。"
    },
    {
      "indent": 3,
      "text": "compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state.",
      "ja": "compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state."
    },
    {
      "indent": 0,
      "text": "7.4.2. Server Certificate",
      "section_title": true,
      "ja": "7.4.2. サーバー証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The server MUST send a certificate whenever the agreed-upon key exchange method is not an anonymous one. This message will always immediately follow the server hello message.",
      "ja": "合意された鍵交換方法が匿名でない場合は常に、サーバーは証明書を送信する必要があります。このメッセージは、常にサーバーのHelloメッセージの直後に続きます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "The certificate type MUST be appropriate for the selected cipher suite's key exchange algorithm, and is generally an X.509v3 certificate. It MUST contain a key that matches the key exchange method, as follows. Unless otherwise specified, the signing algorithm for the certificate MUST be the same as the algorithm for the certificate key. Unless otherwise specified, the public key MAY be of any length.",
      "ja": "証明書タイプは、選択した暗号スイートの鍵交換アルゴリズムに適切である必要があり、通常はX.509v3証明書です。次のように、鍵交換方法に一致する鍵を含める必要があります。特に指定がない限り、証明書の署名アルゴリズムは、証明書キーのアルゴリズムと同じでなければなりません。特に明記されていない限り、公開鍵の長さは任意です。"
    },
    {
      "indent": 6,
      "text": "Key Exchange Algorithm Certificate Key Type",
      "ja": "鍵交換アルゴリズム証明書の鍵タイプ"
    },
    {
      "indent": 6,
      "text": "RSA RSA public key; the certificate MUST allow the key to be used for encryption.",
      "ja": "RSA RSA公開鍵。証明書では、キーを暗号化に使用できるようにする必要があります。"
    },
    {
      "indent": 6,
      "text": "DHE_DSS DSS public key.",
      "ja": "DHE_DSS DSS公開鍵。"
    },
    {
      "indent": 6,
      "text": "DHE_RSA RSA public key that can be used for signing.",
      "ja": "DHE_RSA署名に使用できるRSA公開鍵。"
    },
    {
      "indent": 6,
      "text": "DH_DSS Diffie-Hellman key. The algorithm used to sign the certificate MUST be DSS.",
      "ja": "DH_DSS Diffie-Hellmanキー。証明書の署名に使用されるアルゴリズムはDSSである必要があります。"
    },
    {
      "indent": 6,
      "text": "DH_RSA Diffie-Hellman key. The algorithm used to sign the certificate MUST be RSA.",
      "ja": "DH_RSA Diffie-Hellmanキー。証明書の署名に使用されるアルゴリズムはRSAでなければなりません。"
    },
    {
      "indent": 3,
      "text": "All certificate profiles and key and cryptographic formats are defined by the IETF PKIX working group [PKIX]. When a key usage extension is present, the digitalSignature bit MUST be set for the key to be eligible for signing, as described above, and the keyEncipherment bit MUST be present to allow encryption, as described above. The keyAgreement bit must be set on Diffie-Hellman certificates.",
      "ja": "すべての証明書プロファイルとキーおよび暗号化形式は、IETF PKIXワーキンググループ[PKIX]によって定義されています。鍵用途拡張が存在する場合、前述のように、署名に適格になるように鍵のdigitalSignatureビットを設定する必要があり、暗号化を許可するには、前述のようにkeyEnciphermentビットが存在する必要があります。 Diffie-Hellman証明書では、keyAgreementビットを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "As CipherSuites that specify new key exchange methods are specified for the TLS Protocol, they will imply certificate format and the required encoded keying information.",
      "ja": "新しい鍵交換方式を指定するCipherSuiteはTLSプロトコル用に指定されているため、証明書の形式と必要なエンコードされた鍵情報が含まれます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "opaque ASN.1Cert<1..2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ASN.1Cert certificate_list<0..2^24-1>;\n} Certificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "certificate_list This is a sequence (chain) of X.509v3 certificates. The sender's certificate must come first in the list. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.",
      "ja": "certificate_listこれは、X.509v3証明書のシーケンス（チェーン）です。送信者の証明書がリストの最初に来る必要があります。次の各証明書は、その前の証明書を直接証明する必要があります。証明書の検証ではルートキーを個別に配布する必要があるため、ルート認証局を指定する自己署名証明書は、リモートエンドがそれを検証するためにすでに所有している必要があるという前提で、オプションでチェーンから省略できます。"
    },
    {
      "indent": 3,
      "text": "The same message type and structure will be used for the client's response to a certificate request message. Note that a client MAY send no certificates if it does not have an appropriate certificate to send in response to the server's authentication request.",
      "ja": "証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用されます。サーバーの認証要求に応答して送信する適切な証明書がない場合、クライアントは証明書を送信しない場合があります。"
    },
    {
      "indent": 6,
      "text": "Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.",
      "ja": "注：PKCS＃6 [PKCS6]拡張証明書は使用されないため、PKCS＃7 [PKCS7]は証明書ベクトルの形式として使用されません。また、PKCS＃7はSEQUENCEではなくSETを定義しているため、リストを解析するタスクがより困難になります。"
    },
    {
      "indent": 0,
      "text": "7.4.3. Server Key Exchange Message",
      "section_title": true,
      "ja": "7.4.3. サーバーキー交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This message will be sent immediately after the server certificate message (or the server hello message, if this is an anonymous negotiation).",
      "ja": "このメッセージは、サーバー証明書メッセージ（または匿名のネゴシエーションの場合はサーバーのhelloメッセージ）の直後に送信されます。"
    },
    {
      "indent": 6,
      "text": "The server key exchange message is sent by the server only when the server certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:",
      "ja": "サーバーキー交換メッセージは、サーバー証明書メッセージ（送信された場合）に、クライアントがプリマスターシークレットを交換するのに十分なデータが含まれていない場合にのみサーバーから送信されます。これは、次の鍵交換方法に当てはまります。"
    },
    {
      "indent": 11,
      "text": "DHE_DSS DHE_RSA DH_anon",
      "ja": "DHE_DSS AND_RSA DH_anon"
    },
    {
      "indent": 6,
      "text": "It is not legal to send the server key exchange message for the following key exchange methods:",
      "ja": "次のキー交換方法でサーバーキー交換メッセージを送信することはできません。"
    },
    {
      "indent": 11,
      "text": "RSA DH_DSS DH_RSA",
      "ja": "RSA DH_DSS DH_RSA"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message conveys cryptographic information to allow the client to communicate the premaster secret: either an RSA public key with which to encrypt the premaster secret, or a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret).",
      "ja": "このメッセージは、クライアントがプリマスターシークレットを通信できるようにする暗号化情報を伝えます。プリマスターシークレットを暗号化するためのRSA公開キー、またはクライアントがキー交換を完了できるDiffie-Hellman公開キー（結果はプレマスターシークレット）。"
    },
    {
      "indent": 3,
      "text": "As additional CipherSuites are defined for TLS that include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.",
      "ja": "新しいキー交換アルゴリズムを含む追加のCipherSuiteがTLSに定義されているため、サーバーキー交換メッセージは、キー交換アルゴリズムに関連付けられた証明書タイプがクライアントがプリマスターシークレットを交換するのに十分な情報を提供しない場合にのみ送信されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum { rsa, diffie_hellman } KeyExchangeAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque rsa_modulus<1..2^16-1>;\n    opaque rsa_exponent<1..2^16-1>;\n} ServerRSAParams;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "rsa_modulus The modulus of the server's temporary RSA key.",
      "ja": "rsa_modulusサーバーの一時RSAキーの係数。"
    },
    {
      "indent": 6,
      "text": "rsa_exponent The public exponent of the server's temporary RSA key.",
      "ja": "rsa_exponentサーバーの一時的なRSAキーの公開指数。"
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque dh_p<1..2^16-1>;\n    opaque dh_g<1..2^16-1>;\n    opaque dh_Ys<1..2^16-1>;\n} ServerDHParams;     /* Ephemeral DH parameters */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "dh_p The prime modulus used for the Diffie-Hellman operation.",
      "ja": "dh_p The prime modulus used for the Diffie-Hellman operation."
    },
    {
      "indent": 6,
      "text": "dh_g The generator used for the Diffie-Hellman operation.",
      "ja": "dh_g Diffie-Hellman操作に使用されるジェネレータ。"
    },
    {
      "indent": 6,
      "text": "dh_Ys The server's Diffie-Hellman public value (g^X mod p).",
      "ja": "dh_YsサーバーのDiffie-Hellmanパブリック値（g ^ X mod p）。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;\n            Signature signed_params;\n        case rsa:\n            ServerRSAParams params;\n            Signature signed_params;\n    };\n} ServerKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;\n        case rsa:\n            ServerRSAParams params;\n    };\n } ServerParams;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "params The server's key exchange parameters.",
      "ja": "paramsサーバーの鍵交換パラメーター。"
    },
    {
      "indent": 6,
      "text": "signed_params For non-anonymous key exchanges, a hash of the corresponding params value, with the signature appropriate to that hash applied.",
      "ja": "signed_pa​​rams非匿名の鍵交換の場合、対応するparams値のハッシュと、そのハッシュに適した署名が適用されます。"
    },
    {
      "indent": 6,
      "text": "md5_hash\n    MD5(ClientHello.random + ServerHello.random + ServerParams);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "sha_hash\n    SHA(ClientHello.random + ServerHello.random + ServerParams);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "enum { anonymous, rsa, dsa } SignatureAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    select (SignatureAlgorithm) {\n        case anonymous: struct { };\n        case rsa:\n            digitally-signed struct {\n                opaque md5_hash[16];\n                opaque sha_hash[20];\n            };\n        case dsa:\n            digitally-signed struct {\n                opaque sha_hash[20];\n            };\n        };\n    };\n} Signature;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.4. Certificate request",
      "section_title": true,
      "ja": "7.4.4. 証明書の要求"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "A non-anonymous server can optionally request a certificate from the client, if it is appropriate for the selected cipher suite.",
      "ja": "非匿名サーバーは、選択した暗号スイートに適している場合、オプションでクライアントに証明書を要求できます。"
    },
    {
      "indent": 6,
      "text": "This message, if sent, will immediately follow the Server Key Exchange message (if it is sent; otherwise, the Server Certificate message).",
      "ja": "このメッセージが送信された場合、サーバーキー交換メッセージの直後に送信されます（送信された場合、送信されない場合はサーバー証明書メッセージ）。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum {\n    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n fortezza_dms_RESERVED(20),\n    (255)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "} ClientCertificateType;",
      "ja": "} ClientCertificateType;"
    },
    {
      "indent": 6,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    DistinguishedName certificate_authorities<0..2^16-1>;\n} CertificateRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "certificate_types This field is a list of the types of certificates requested, sorted in order of the server's preference.",
      "ja": "certificate_typesこのフィールドは、要求された証明書のタイプのリストであり、サーバーの設定順にソートされています。"
    },
    {
      "indent": 6,
      "text": "certificate_authorities A list of the distinguished names of acceptable certificate authorities. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe both known roots and a desired authorization space. If the certificate_authorities list is empty then the client MAY send any certificate of the appropriate ClientCertificateType, unless there is some external arrangement to the contrary.",
      "ja": "certificate_authorities受け入れ可能な認証局の識別名のリスト。これらの識別名は、ルートCAまたは下位CAに必要な識別名を指定できます。したがって、このメッセージを使用して、既知のルートと目的の承認スペースの両方を説明できます。 certificate_authoritiesリストが空の場合、反対の何らかの外部の取り決めがない限り、クライアントは適切なClientCertificateTypeの証明書を送信できます（MAY）。"
    },
    {
      "indent": 3,
      "text": "ClientCertificateType values are divided into three groups:",
      "ja": "ClientCertificateType値は、3つのグループに分けられます。"
    },
    {
      "indent": 6,
      "text": "1. Values from 0 (zero) through 63 decimal (0x3F) inclusive are reserved for IETF Standards Track protocols.",
      "ja": "1. 0（ゼロ）から63（10x3F）までの値は、IETF標準トラックプロトコル用に予約されています。"
    },
    {
      "indent": 6,
      "text": "2. Values from 64 decimal (0x40) through 223 decimal (0xDF) inclusive are reserved for assignment for non-Standards Track methods.",
      "ja": "2. 10進数の64（0x40）から10進数の223（0xDF）までの値は、非標準のTrackメソッドの割り当て用に予約されています。"
    },
    {
      "indent": 6,
      "text": "3. Values from 224 decimal (0xE0) through 255 decimal (0xFF) inclusive are reserved for private use.",
      "ja": "3. 10進数の224（0xE0）から10進数の255（0xFF）までの値は、私用に予約されています。"
    },
    {
      "indent": 3,
      "text": "Additional information describing the role of IANA in the allocation of ClientCertificateType code points is described in Section 11.",
      "ja": "ClientCertificateTypeコードポイントの割り当てにおけるIANAの役割を説明する追加情報は、セクション11で説明されています。"
    },
    {
      "indent": 3,
      "text": "Note: Values listed as RESERVED may not be used. They were used in SSLv3.",
      "ja": "注：RESERVEDとしてリストされている値は使用できません。 SSLv3で使用されました。"
    },
    {
      "indent": 3,
      "text": "Note: DistinguishedName is derived from [X501]. DistinguishedNames are represented in DER-encoded format.",
      "ja": "注：DistinguishedNameは[X501]から派生しています。 DistinguishedNameは、DERエンコード形式で表されます。"
    },
    {
      "indent": 3,
      "text": "Note: It is a fatal handshake_failure alert for an anonymous server to request client authentication.",
      "ja": "注：匿名サーバーがクライアント認証を要求することは、致命的なhandshake_failureアラートです。"
    },
    {
      "indent": 0,
      "text": "7.4.5. Server Hello Done",
      "section_title": true,
      "ja": "7.4.5. サーバーこんにちは完了"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "The server hello done message is sent by the server to indicate the end of the server hello and associated messages. After sending this message, the server will wait for a client response.",
      "ja": "server hello doneメッセージは、サーバーから送信され、サーバーhelloの終了と関連メッセージを示します。このメッセージを送信した後、サーバーはクライアントの応答を待ちます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.",
      "ja": "このメッセージは、サーバーが鍵交換をサポートするメッセージの送信を完了し、クライアントが鍵交換のフェーズを続行できることを意味します。"
    },
    {
      "indent": 6,
      "text": "Upon receipt of the server hello done message, the client SHOULD verify that the server provided a valid certificate, if required and check that the server hello parameters are acceptable.",
      "ja": "server hello doneメッセージを受信すると、クライアントは、必要に応じてサーバーが有効な証明書を提供したことを確認し、サーバーhelloパラメータが受け入れ可能であることを確認する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct { } ServerHelloDone;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.6. Client certificate",
      "section_title": true,
      "ja": "7.4.6. クライアント証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This is the first message the client can send after receiving a server hello done message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client SHOULD send a certificate message containing no certificates. That is, the certificate_list structure has a length of zero. If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert. Client certificates are sent using the Certificate structure defined in Section 7.4.2.",
      "ja": "これは、サーバーのhello doneメッセージを受信した後にクライアントが送信できる最初のメッセージです。このメッセージは、サーバーが証明書を要求した場合にのみ送信されます。適切な証明書が利用できない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります（SHOULD）。つまり、certificate_list構造の長さはゼロです。サーバーがハンドシェイクを続行するためにクライアント認証が必要な場合、サーバーは致命的なハンドシェイク失敗アラートで応答することがあります。クライアント証明書は、セクション7.4.2で定義された証明書構造を使用して送信されます。"
    },
    {
      "indent": 3,
      "text": "Note: When using a static Diffie-Hellman based key exchange method (DH_DSS or DH_RSA), if client authentication is requested, the Diffie-Hellman group and generator encoded in the client's certificate MUST match the server specified Diffie-Hellman parameters if the client's parameters are to be used for the key exchange.",
      "ja": "注：静的なDiffie-Hellmanベースの鍵交換方式（DH_DSSまたはDH_RSA）を使用する場合、クライアント認証が要求された場合、クライアントのパラメーターにサーバーの指定されたDiffie-Hellmanパラメーターと一致する必要があります。鍵交換に使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4.7. Client Key Exchange Message",
      "section_title": true,
      "ja": "7.4.7. クライアントキー交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "This message is always sent by the client. It MUST immediately follow the client certificate message, if it is sent. Otherwise it MUST be the first message sent by the client after it receives the server hello done message.",
      "ja": "このメッセージは常にクライアントによって送信されます。送信される場合、クライアント証明書メッセージの直後に続く必要があります。それ以外の場合は、サーバーのhello doneメッセージを受信した後、クライアントが最初に送信するメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "With this message, the premaster secret is set, either though direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret. When the key exchange method is DH_RSA or DH_DSS, client certification has been requested, and the client was able to respond with a certificate that contained a Diffie-Hellman public key whose parameters (group and generator) matched those specified by the server in its certificate, this message MUST not contain any data.",
      "ja": "このメッセージでは、RSAで暗号化されたシークレットを直接送信するか、各サイドが同じプリマスターシークレットに同意できるDiffie-Hellmanパラメータを送信することによって、プリマスターシークレットが設定されます。鍵交換方式がDH_RSAまたはDH_DSSである場合、クライアント証明書が要求され、クライアントは、証明書でサーバーによって指定されたものとパラメーター（グループおよびジェネレーター）が一致するDiffie-Hellman公開鍵を含む証明書で応答できました、このメッセージにはデータを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.",
      "ja": "メッセージの選択は、選択された鍵交換方式によって異なります。 KeyExchangeAlgorithmの定義については、7.4.3項を参照してください。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa: EncryptedPreMasterSecret;\n        case diffie_hellman: ClientDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.4.7.1. RSA Encrypted Premaster Secret Message",
      "section_title": true,
      "ja": "7.4.7.1. RSA暗号化プリマスターシークレットメッセージ"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server's certificate or the temporary RSA key provided in a server key exchange message, and sends the result in an encrypted premaster secret message. This structure is a variant of the client key exchange message and is not a message in itself.",
      "ja": "RSAが鍵の合意と認証に使用されている場合、クライアントは48バイトのプリマスターシークレットを生成し、サーバーの証明書からの公開鍵またはサーバーの鍵交換メッセージで提供される一時的なRSA鍵を使用して暗号化し、結果を暗号化されたプリマスターシークレットメッセージ。この構造はクライアントの鍵交換メッセージの変形であり、それ自体はメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion client_version;\n    opaque random[46];\n} PreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "client_version The latest (newest) version supported by the client. This is used to detect version roll-back attacks. Upon receiving the premaster secret, the server SHOULD check that this value matches the value transmitted by the client in the client hello message.",
      "ja": "client_versionクライアントがサポートする最新（最新）バージョン。これは、バージョンロールバック攻撃を検出するために使用されます。プリマスターシークレットを受信すると、サーバーは、この値がクライアントのhelloメッセージでクライアントから送信された値と一致することを確認する必要があります（SHOULD）。"
    },
    {
      "indent": 6,
      "text": "random 46 securely-generated random bytes.",
      "ja": "random 46の安全に生成されたランダムバイト。"
    },
    {
      "indent": 6,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.",
      "ja": "pre_master_secretこのランダムな値はクライアントによって生成され、セクション8.1で指定されているように、マスターシークレットを生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Note: An attack discovered by Daniel Bleichenbacher [BLEI] can be used to attack a TLS server that is using PKCS#1 v 1.5 encoded RSA. The attack takes advantage of the fact that, by failing in different ways, a TLS server can be coerced into revealing whether a particular message, when decrypted, is properly PKCS#1 v1.5 formatted or not.",
      "ja": "注：Daniel Bleichenbacher [BLEI]によって発見された攻撃は、PKCS＃1 v 1.5エンコードされたRSAを使用しているTLSサーバーを攻撃するために使用できます。攻撃は、さまざまな方法で失敗することにより、TLSサーバーが強制的に特定のメッセージが復号化されたときに適切にPKCS＃1 v1.5形式であるかどうかを明らかにすることができるという事実を利用します。"
    },
    {
      "indent": 9,
      "text": "The best way to avoid vulnerability to this attack is to treat incorrectly formatted messages in a manner indistinguishable from correctly formatted RSA blocks. Thus, when a server receives an incorrectly formatted RSA block, it should generate a random 48-byte value and proceed using it as the premaster secret. Thus, the server will act identically whether the received RSA block is correctly encoded or not.",
      "ja": "この攻撃に対する脆弱性を回避する最良の方法は、正しくフォーマットされたRSAブロックと区別できない方法で、誤ってフォーマットされたメッセージを処理することです。したがって、サーバーが誤ってフォーマットされたRSAブロックを受信すると、ランダムな48バイトの値を生成し、それをプリマスターシークレットとして使用する必要があります。したがって、サーバーは、受信したRSAブロックが正しくエンコードされているかどうかにかかわらず、同じように動作します。"
    },
    {
      "indent": 9,
      "text": "[PKCS1B] defines a newer version of PKCS#1 encoding that is more secure against the Bleichenbacher attack. However, for maximal compatibility with TLS 1.0, TLS 1.1 retains the original encoding. No variants of the Bleichenbacher attack are known to exist provided that the above recommendations are followed.",
      "ja": "[PKCS1B]は、ブライチェンバッハ攻撃に対してより安全なPKCS＃1エンコーディングの新しいバージョンを定義しています。ただし、TLS 1.0との互換性を最大限に高めるために、TLS 1.1は元のエンコーディングを保持します。上記の推奨事項に従う限り、ブライチェンバッハー攻撃の亜種は存在しないことがわかっています。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Public-key-encrypted data is represented as an opaque vector <0..2^16-1> (see Section 4.7). Thus, the RSA-encrypted PreMasterSecret in a ClientKeyExchange is preceded by two length bytes. These bytes are redundant in the case of RSA because the EncryptedPreMasterSecret is the only data in the ClientKeyExchange and its length can therefore be unambiguously determined. The SSLv3 specification was not clear about the encoding of public-key-encrypted data, and therefore many SSLv3 implementations do not include the length bytes, encoding the RSA encrypted data directly in the ClientKeyExchange message.",
      "ja": "実装上の注意：公開鍵で暗号化されたデータは、不透明なベクトル<0..2 ^ 16-1>として表されます（セクション4.7を参照）。したがって、ClientKeyExchange内のRSA暗号化されたPreMasterSecretの前には、2バイトの長さがあります。 EncryptedPreMasterSecretはClientKeyExchange内の唯一のデータであり、その長さは明確に決定できるため、RSAの場合、これらのバイトは冗長です。 SSLv3仕様では、公開鍵で暗号化されたデータのエンコードについて明確ではなかったため、多くのSSLv3実装には長さバイトが含まれておらず、RSA暗号化データをClientKeyExchangeメッセージに直接エンコードしています。"
    },
    {
      "indent": 24,
      "text": "This specification requires correct encoding of the EncryptedPreMasterSecret complete with length bytes. The resulting PDU is incompatible with many SSLv3 implementations. Implementors upgrading from SSLv3 must modify their implementations to generate and accept the correct encoding. Implementors who wish to be compatible with both SSLv3 and TLS should make their implementation's behavior dependent on the protocol version.",
      "ja": "この仕様では、長さバイトで完全なEncryptedPreMasterSecretの正しいエンコードが必要です。結果のPDUは、多くのSSLv3実装と互換性がありません。 SSLv3からアップグレードする実装者は、正しいエンコーディングを生成して受け入れるように実装を変更する必要があります。 SSLv3とTLSの両方との互換性を希望する実装者は、実装の動作をプロトコルバージョンに依存させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: It is now known that remote timing-based attacks on SSL are possible, at least when the client and server are on the same LAN. Accordingly, implementations that use static RSA keys SHOULD use RSA blinding or some other anti-timing technique, as described in [TIMING].",
      "ja": "Implementation Note: It is now known that remote timing-based attacks on SSL are possible, at least when the client and server are on the same LAN. Accordingly, implementations that use static RSA keys SHOULD use RSA blinding or some other anti-timing technique, as described in [TIMING]."
    },
    {
      "indent": 3,
      "text": "Note: The version number in the PreMasterSecret MUST be the version offered by the client in the ClientHello, not the version negotiated for the connection. This feature is designed to prevent rollback attacks. Unfortunately, many implementations use the negotiated version instead, and therefore checking the version number may lead to failure to interoperate with such incorrect client implementations. Client implementations, MUST and Server implementations MAY, check the version number. In practice, since the TLS handshake MACs prevent downgrade and no good attacks are known on those MACs, ambiguity is not considered a serious security risk. Note that if servers choose to check the version number, they should randomize the PreMasterSecret in case of error, rather than generate an alert, in order to avoid variants on the Bleichenbacher attack. [KPR03]",
      "ja": "注：PreMasterSecretのバージョン番号は、接続のためにネゴシエートされたバージョンではなく、ClientHelloでクライアントによって提供されたバージョンである必要があります。この機能は、ロールバック攻撃を防ぐように設計されています。残念ながら、多くの実装ではネゴシエートされたバージョンを代わりに使用するため、バージョン番号を確認すると、このような不適切なクライアント実装との相互運用に失敗する可能性があります。クライアント実装、MUSTおよびサーバー実装は、バージョン番号を確認できます。実際には、TLSハンドシェイクMACはダウングレードを防止し、これらのMACに対する適切な攻撃は知られていないため、あいまいさは重大なセキュリティリスクとは見なされません。サーバーがバージョン番号をチェックすることを選択した場合、ブライチェンバッハ攻撃の変種を回避するために、アラートを生成するのではなく、エラーが発生した場合にPreMasterSecretをランダム化する必要があります。 [KPR03]"
    },
    {
      "indent": 0,
      "text": "7.4.7.2. Client Diffie-Hellman Public Value",
      "section_title": true,
      "ja": "7.4.7.2. クライアントDiffie-Hellmanパブリックバリュー"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "This structure conveys the client's Diffie-Hellman public value (Yc) if it was not already included in the client's certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message and not a message in itself.",
      "ja": "この構造は、クライアントの証明書にまだ含まれていない場合、クライアントのDiffie-Hellmanパブリック値（Yc）を伝えます。 Ycに使用されるエンコーディングは、列挙されたPublicValueEncodingによって決定されます。この構造はクライアント鍵交換メッセージの変形であり、それ自体はメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "implicit If the client certificate already contains a suitable Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In this case, the client key exchange message will be sent, but it MUST be empty.",
      "ja": "暗黙的クライアント証明書に適切なDiffie-Hellman鍵がすでに含まれている場合、Ycは暗黙的であり、再度送信する必要はありません。この場合、クライアントの鍵交換メッセージが送信されますが、空でなければなりません。"
    },
    {
      "indent": 6,
      "text": "explicit Yc needs to be sent.",
      "ja": "明示的なYcを送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct { };\n        case explicit: opaque dh_Yc<1..2^16-1>;\n    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "dh_Yc The client's Diffie-Hellman public value (Yc).",
      "ja": "dh_YcクライアントのDiffie-Hellmanパブリック値（Yc）。"
    },
    {
      "indent": 0,
      "text": "7.4.8. Certificate verify",
      "section_title": true,
      "ja": "7.4.8. 証明書の確認"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "When this message will be sent:"
    },
    {
      "indent": 6,
      "text": "This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e., all certificates except those containing fixed Diffie-Hellman parameters). When sent, it MUST immediately follow the client key exchange message.",
      "ja": "このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます。このメッセージは、署名機能を持つクライアント証明書（つまり、固定Diffie-Hellmanパラメータを含むものを除くすべての証明書）に続いてのみ送信されます。送信されると、クライアント鍵交換メッセージの直後に続く必要があります。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 6,
      "text": "struct {\n     Signature signature;\n} CertificateVerify;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The Signature type is defined in 7.4.3.",
      "ja": "署名タイプは、7.4.3で定義されています。"
    },
    {
      "indent": 6,
      "text": "CertificateVerify.signature.md5_hash MD5(handshake_messages);",
      "ja": "CertificateVerify.signature.md5_hash MD5(handshake_messages);"
    },
    {
      "indent": 6,
      "text": "CertificateVerify.signature.sha_hash SHA(handshake_messages);",
      "ja": "CertificateVerify.signature.sha_hash SHA（handshake_messages）;"
    },
    {
      "indent": 3,
      "text": "Here handshake_messages refers to all handshake messages sent or received starting at client hello up to but not including this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures, as defined in 7.4, exchanged thus far.",
      "ja": "ここで、handshake_messagesは、クライアントhelloからこのメッセージまで（ただし、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む）までに送受信されるすべてのハンドシェイクメッセージを指します。これは、これまでに交換された、7.4で定義されているすべてのハンドシェイク構造の連結です。"
    },
    {
      "indent": 0,
      "text": "7.4.9. Finished",
      "section_title": true,
      "ja": "7.4.9. 完成した"
    },
    {
      "indent": 3,
      "text": "When this message will be sent:",
      "ja": "このメッセージが送信されるタイミング："
    },
    {
      "indent": 6,
      "text": "A finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.",
      "ja": "完成したメッセージは常に暗号仕様変更メッセージの直後に送信され、鍵交換と認証プロセスが成功したことを確認します。他のハンドシェイクメッセージと完了メッセージの間に、暗号仕様変更メッセージを受信することが不可欠です。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 6,
      "text": "The finished message is the first protected with the just-negotiated algorithms, keys, and secrets. Recipients of finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.",
      "ja": "完成したメッセージは、交渉されたばかりのアルゴリズム、キー、およびシークレットで保護された最初のメッセージです。完成したメッセージの受信者は、内容が正しいことを確認する必要があります。サイドが完了メッセージを送信し、ピアから完了メッセージを受信して​​検証すると、接続を介してアプリケーションデータの送受信を開始できます。"
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque verify_data[12];\n} Finished;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "verify_data\n    PRF(master_secret, finished_label, MD5(handshake_messages) +\n    SHA-1(handshake_messages)) [0..11];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "finished_label For Finished messages sent by the client, the string \"client finished\". For Finished messages sent by the server, the string \"server finished\".",
      "ja": "finished_labelクライアントが送信した完了メッセージの場合、ストリング「client finished」。サーバーによって送信された終了メッセージの場合、文字列「サーバー終了」。"
    },
    {
      "indent": 6,
      "text": "handshake_messages All of the data from all messages in this handshake (not including any HelloRequest messages) up to but not including this message. This is only data visible at the handshake layer and does not include record layer headers. This is the concatenation of all the Handshake structures, as defined in 7.4, exchanged thus far.",
      "ja": "handshake_messagesこのハンドシェイク内のすべてのメッセージ（HelloRequestメッセージを含まない）からこのメッセージを含まないすべてのデータ。これは、ハンドシェイクレイヤーでのみ表示されるデータであり、レコードレイヤーヘッダーは含まれません。これは、これまでに交換された、7.4で定義されているすべてのハンドシェイク構造の連結です。"
    },
    {
      "indent": 3,
      "text": "It is a fatal error if a finished message is not preceded by a change cipher spec message at the appropriate point in the handshake.",
      "ja": "ハンドシェイクの適切な時点で、完了したメッセージの前に暗号仕様変更メッセージが付いていない場合は、致命的なエラーになります。"
    },
    {
      "indent": 3,
      "text": "The value handshake_messages includes all handshake messages starting at client hello up to, but not including, this finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the certificate verify message (if sent). Also, the handshake_messages for the finished message sent by the client will be different from that for the finished message sent by the server, because the one that is sent second will include the prior one.",
      "ja": "値handshake_messagesには、クライアントhelloからこの終了メッセージまでのすべてのハンドシェイクメッセージが含まれますが、このメッセージは含まれません。証明書検証メッセージ（送信された場合）が含まれるため、これはセクション7.4.8のhandshake_messagesとは異なる場合があります。また、クライアントから送信された終了メッセージのhandshake_messagesは、サーバーから送信された終了メッセージのhandshake_messagesとは異なります。これは、2番目に送信されるメッセージに前のメッセージが含まれるためです。"
    },
    {
      "indent": 3,
      "text": "Note: Change cipher spec messages, alerts, and any other record types are not handshake messages and are not included in the hash computations. Also, Hello Request messages are omitted from handshake hashes.",
      "ja": "注：暗号仕様変更メッセージ、アラート、およびその他のレコードタイプはハンドシェイクメッセージではなく、ハッシュ計算には含まれません。また、Hello Requestメッセージはハンドシェイクハッシュから省略されます。"
    },
    {
      "indent": 0,
      "text": "8. Cryptographic Computations",
      "section_title": true,
      "ja": "8. 暗号計算"
    },
    {
      "indent": 3,
      "text": "In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the server hello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.",
      "ja": "接続保護を開始するために、TLSレコードプロトコルでは、一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムは、サーバーによって選択され、サーバーのHelloメッセージで明らかにされたcipher_suiteによって決定されます。圧縮アルゴリズムはhelloメッセージでネゴシエートされ、ランダムな値はhelloメッセージで交換されます。あとは、マスターシークレットを計算するだけです。"
    },
    {
      "indent": 0,
      "text": "8.1. Computing the Master Secret",
      "section_title": true,
      "ja": "8.1. マスターシークレットの計算"
    },
    {
      "indent": 3,
      "text": "For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.",
      "ja": "すべての鍵交換方法で、同じアルゴリズムを使用してpre_master_secretをmaster_secretに変換します。 master_secretが計算されたら、pre_master_secretをメモリから削除する必要があります。"
    },
    {
      "indent": 7,
      "text": "master_secret = PRF(pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47];",
      "ja": "master_secret = PRF(pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47];"
    },
    {
      "indent": 3,
      "text": "The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.",
      "ja": "マスターシークレットの長さは常に正確に48バイトです。プリマスターシークレットの長さは、鍵の交換方法によって異なります。"
    },
    {
      "indent": 0,
      "text": "8.1.1. RSA",
      "section_title": true,
      "ja": "8.1.1. RSA"
    },
    {
      "indent": 3,
      "text": "When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.",
      "ja": "RSAがサーバー認証と鍵交換に使用される場合、48バイトのpre_master_secretがクライアントによって生成され、サーバーの公開鍵で暗号化されてサーバーに送信されます。サーバーは、その秘密鍵を使用してpre_master_secretを復号化します。次に、両方の当事者が、上記のようにpre_master_secretをmaster_secretに変換します。"
    },
    {
      "indent": 3,
      "text": "RSA digital signatures are performed using PKCS #1 [PKCS1] block type 1. RSA public key encryption is performed using PKCS #1 block type 2.",
      "ja": "RSAデジタル署名は、PKCS＃1 [PKCS1]ブロックタイプ1を使用して実行されます。RSA公開鍵暗号化は、PKCS＃1ブロックタイプ2を使用して実行されます。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Diffie-Hellman",
      "section_title": true,
      "ja": "8.1.2. ディフィーヘルマン"
    },
    {
      "indent": 3,
      "text": "A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above. Leading bytes of Z that contain all zero bits are stripped before it is used as the pre_master_secret.",
      "ja": "従来のDiffie-Hellman計算が実行されます。ネゴシエートされたキー（Z）はpre_master_secretとして使用され、上記のようにmaster_secretに変換されます。すべてゼロのビットを含むZの先頭バイトは、pre_master_secretとして使用される前に取り除かれます。"
    },
    {
      "indent": 3,
      "text": "Note: Diffie-Hellman parameters are specified by the server and may be either ephemeral or contained within the server's certificate.",
      "ja": "注：Diffie-Hellmanパラメーターはサーバーによって指定され、一時的なものか、サーバーの証明書内に含まれるもののいずれかです。"
    },
    {
      "indent": 0,
      "text": "9. Mandatory Cipher Suites",
      "section_title": true,
      "ja": "9. Mandatory Cipher Suites"
    },
    {
      "indent": 3,
      "text": "In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_RSA_WITH_3DES_EDE_CBC_SHA.",
      "ja": "特に指定しないアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは、暗号スイートTLS_RSA_WITH_3DES_EDE_CBC_SHAを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Application Data Protocol",
      "section_title": true,
      "ja": "10. アプリケーションデータプロトコル"
    },
    {
      "indent": 3,
      "text": "Application data messages are carried by the Record Layer and are fragmented, compressed, and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.",
      "ja": "アプリケーションデータメッセージはレコードレイヤーによって運ばれ、現在の接続状態に基づいて断片化、圧縮、および暗号化されます。メッセージは、レコードレイヤーに対して透過的なデータとして扱われます。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo, especially in Appendices D, E, and F.",
      "ja": "Security issues are discussed throughout this memo, especially in Appendices D, E, and F."
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes a number of new registries that have been created by IANA. We recommended that they be placed as individual registries items under a common TLS category.",
      "ja": "このドキュメントでは、IANAによって作成されたいくつかの新しいレジストリについて説明します。それらを共通のTLSカテゴリの下の個別のレジストリ項目として配置することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Section 7.4.3 describes a TLS ClientCertificateType Registry to be maintained by the IANA, defining a number of such code point identifiers. ClientCertificateType identifiers with values in the range 0-63 (decimal) inclusive are assigned via RFC 2434 Standards Action. Values from the range 64-223 (decimal) inclusive are assigned via [RFC2434] Specification Required. Identifier values from 224-255 (decimal) inclusive are reserved for RFC 2434 Private Use. The registry will initially be populated with the values in this document, Section 7.4.4.",
      "ja": "セクション7.4.3では、IANAによって維持されるTLS ClientCertificateTypeレジストリについて説明し、そのようなコードポイント識別子をいくつか定義しています。 0〜63（10進数）の範囲の値を持つClientCertificateType識別子は、RFC 2434標準アクションを介して割り当てられます。 64〜223（10進数）の範囲の値は、[RFC2434]仕様が必要であることを介して割り当てられます。 224-255（10進数）を含むID値は、RFC 2434 Private Useのために予約されています。レジストリには、このドキュメントのセクション7.4.4の値が最初に入力されます。"
    },
    {
      "indent": 3,
      "text": "Section A.5 describes a TLS Cipher Suite Registry to be maintained by the IANA, and it defines a number of such cipher suite identifiers. Cipher suite values with the first byte in the range 0-191 (decimal) inclusive are assigned via RFC 2434 Standards Action. Values with the first byte in the range 192-254 (decimal) are assigned via RFC 2434 Specification Required. Values with the first byte 255 (decimal) are reserved for RFC 2434 Private Use. The registry will initially be populated with the values from Section A.5 of this document, [TLSAES], and from Section 3 of [TLSKRB].",
      "ja": "セクションA.5では、IANAによって維持されるTLS暗号スイートレジストリについて説明し、そのような暗号スイート識別子をいくつか定義しています。最初のバイトが0〜191（10進数）の範囲の暗号スイート値は、RFC 2434標準アクションを介して割り当てられます。最初のバイトが192〜254（10進数）の範囲の値は、RFC 2434仕様が必要であることを介して割り当てられます。最初のバイトが255（10進数）の値は、RFC 2434私的使用のために予約されています。レジストリには、このドキュメントのセクションA.5、[TLSAES]、および[TLSKRB]のセクション3の値が最初に入力されます。"
    },
    {
      "indent": 3,
      "text": "Section 6 requires that all ContentType values be defined by RFC 2434 Standards Action. IANA has created a TLS ContentType registry, initially populated with values from Section 6.2.1 of this document. Future values MUST be allocated via Standards Action as described in [RFC2434].",
      "ja": "セクション6では、すべてのContentType値がRFC 2434標準アクションによって定義されている必要があります。 IANAはTLS ContentTypeレジストリを作成し、最初にこのドキュメントのセクション6.2.1の値を入力します。 [RFC2434]で説明されているように、将来の値は標準アクションを介して割り当てられる必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 7.2.2 requires that all Alert values be defined by RFC 2434 Standards Action. IANA has created a TLS Alert registry, initially populated with values from Section 7.2 of this document and from Section 4 of [TLSEXT]. Future values MUST be allocated via Standards Action as described in [RFC2434].",
      "ja": "セクション7.2.2では、すべてのアラート値がRFC 2434標準アクションによって定義されている必要があります。 IANAはTLS Alertレジストリを作成し、最初にこのドキュメントのセクション7.2と[TLSEXT]のセクション4から値を入力します。 [RFC2434]で説明されているように、将来の値は標準アクションを介して割り当てられる必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 7.4 requires that all HandshakeType values be defined by RFC 2434 Standards Action. IANA has created a TLS HandshakeType registry, initially populated with values from Section 7.4 of this document and from Section 2.4 of [TLSEXT]. Future values MUST be allocated via Standards Action as described in [RFC2434].",
      "ja": "セクション7.4では、すべてのHandshakeType値がRFC 2434標準アクションによって定義されている必要があります。 IANAはTLS HandshakeTypeレジストリを作成し、最初にこのドキュメントのセクション7.4と[TLSEXT]のセクション2.4からの値を入力します。 [RFC2434]で説明されているように、将来の値は標準アクションを介して割り当てられる必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Protocol Constant Values",
      "section_title": true,
      "ja": "付録A.プロトコル定数値"
    },
    {
      "indent": 3,
      "text": "This section describes protocol types and constants.",
      "ja": "このセクションでは、プロトコルのタイプと定数について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Record Layer",
      "section_title": true,
      "ja": "A.1. レコード層"
    },
    {
      "indent": 3,
      "text": "struct {\n    uint8 major, minor;\n} ProtocolVersion;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ProtocolVersion version = { 3, 2 };     /* TLS v1.1 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    change_cipher_spec(20), alert(21), handshake(22),\n    application_data(23), (255)\n} ContentType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (CipherSpec.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block:  GenericBlockCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n} GenericStreamCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "block-ciphered struct {\n    opaque IV[CipherSpec.block_length];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n    uint8 padding[GenericBlockCipher.padding_length];\n    uint8 padding_length;\n} GenericBlockCipher;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. Change Cipher Specs Message",
      "section_title": true,
      "ja": "A.2. 暗号仕様メッセージの変更"
    },
    {
      "indent": 3,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. Alert Messages",
      "section_title": true,
      "ja": "A.3. 警告メッセージ"
    },
    {
      "indent": 3,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    no_certificate_RESERVED (41),\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction_RESERVED(60),\n    protocol_version(70),\n    insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    (255)\n} AlertDescription;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. Handshake Protocol",
      "section_title": true,
      "ja": "A.4. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), (255)\n} HandshakeType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    HandshakeType msg_type;\n    uint24 length;\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.1. Hello messages",
      "section_title": true,
      "ja": "A.4.1. こんにちはメッセージ"
    },
    {
      "indent": 3,
      "text": "struct { } HelloRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    uint32 gmt_unix_time;\n    opaque random_bytes[28];\n} Random;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "opaque SessionID<0..32>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "uint8 CipherSuite[2];",
      "ja": "uint8 CipherSuite [2];"
    },
    {
      "indent": 3,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-1>;\n    CompressionMethod compression_methods<1..2^8-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} ClientHello;",
      "ja": "} ClientHello;"
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n} ServerHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.2. Server Authentication and Key Exchange Messages",
      "section_title": true,
      "ja": "A.4.2. サーバー認証と主要交換メッセージ"
    },
    {
      "indent": 3,
      "text": "opaque ASN.1Cert<2^24-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ASN.1Cert certificate_list<0..2^24-1>;\n} Certificate;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { rsa, diffie_hellman } KeyExchangeAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque rsa_modulus<1..2^16-1>;\n    opaque rsa_exponent<1..2^16-1>;\n} ServerRSAParams;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque dh_p<1..2^16-1>;\n    opaque dh_g<1..2^16-1>;\n    opaque dh_Ys<1..2^16-1>;\n} ServerDHParams;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;\n            Signature signed_params;\n        case rsa:\n            ServerRSAParams params;\n            Signature signed_params;\n    };\n} ServerKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { anonymous, rsa, dsa } SignatureAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        case rsa:\n            ServerRSAParams params;\n    };\n} ServerParams;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    select (SignatureAlgorithm) {\n        case anonymous: struct { };\n        case rsa:\n            digitally-signed struct {\n                opaque md5_hash[16];\n                opaque sha_hash[20];\n            };\n        case dsa:\n            digitally-signed struct {\n                opaque sha_hash[20];\n            };\n        };\n    };\n} Signature;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum {\n    rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),\n fortezza_dms_RESERVED(20),\n (255)\n} ClientCertificateType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    DistinguishedName certificate_authorities<0..2^16-1>;\n} CertificateRequest;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct { } ServerHelloDone;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.3. Client Authentication and Key Exchange Messages",
      "section_title": true,
      "ja": "A.4.3. クライアント認証と主要交換メッセージ"
    },
    {
      "indent": 3,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa: EncryptedPreMasterSecret;\n        case diffie_hellman: ClientDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    ProtocolVersion client_version;\n    opaque random[46];\n}\nPreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct {};\n        case explicit: opaque DH_Yc<1..2^16-1>;\n    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n    Signature signature;\n} CertificateVerify;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4.4. Handshake Finalization Message",
      "section_title": true,
      "ja": "A.4.4. ハンドシェイク終了メッセージ"
    },
    {
      "indent": 3,
      "text": "struct {\n    opaque verify_data[12];\n} Finished;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. The CipherSuite",
      "section_title": true,
      "ja": "A.5. 暗号スイート"
    },
    {
      "indent": 3,
      "text": "The following values define the CipherSuite codes used in the client hello and server hello messages.",
      "ja": "次の値は、クライアントのhelloメッセージとサーバーのhelloメッセージで使用されるCipherSuiteコードを定義します。"
    },
    {
      "indent": 3,
      "text": "A CipherSuite defines a cipher specification supported in TLS Version 1.1.",
      "ja": "CipherSuiteは、TLSバージョン1.1でサポートされる暗号仕様を定義します。"
    },
    {
      "indent": 3,
      "text": "TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but must not be negotiated, as it provides no more protection than an unsecured connection.",
      "ja": "TLS_NULL_WITH_NULL_NULLが指定されており、そのチャネルでの最初のハンドシェイク中のTLS接続の初期状態ですが、セキュリティで保護されていない接続以上の保護は提供されないため、ネゴシエーションしてはいけません。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request either an RSA or a DSS signature-capable certificate in the certificate request message.",
      "ja": "以下のCipherSuite定義では、サーバーが鍵交換に使用できるRSA証明書を提供する必要があります。サーバーは、証明書要求メッセージでRSAまたはDSS署名対応の証明書を要求できます。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };\nCipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };\nCipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };\nCipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };\nCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };\nCipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };\nCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following CipherSuite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server's certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a DSS or RSA certificate that has been signed by the CA. The signing algorithm used is specified after the DH or DHE parameter. The server can request an RSA or DSS signature-capable certificate from the client for client authentication or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.",
      "ja": "次のCipherSuite定義は、サーバー認証（およびオプションでクライアント認証）Diffie-Hellmanに使用されます。 DHは、サーバーの証明書に認証局（CA）によって署名されたDiffie-Hellmanパラメーターが含まれている暗号スイートを示します。 DHEは一時的なDiffie-Hellmanを示します。Diffie-Hellmanパラメータは、CAによって署名されたDSSまたはRSA証明書によって署名されます。使用される署名アルゴリズムは、DHまたはDHEパラメーターの後に指定されます。サーバーは、クライアント認証のためにクライアントにRSAまたはDSS署名対応証明書を要求できます。または、Diffie-Hellman証明書を要求することもできます。クライアントによって提供されるすべてのDiffie-Hellman証明書は、サーバーによって記述されたパラメーター（グループおよびジェネレーター）を使用する必要があります。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };\nCipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };\nCipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };\nCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };\nCipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };\nCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };\nCipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };\nCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks and is therefore deprecated.",
      "ja": "次の暗号スイートは、どちらの当事者も認証されない完全に匿名のDiffie-Hellman通信に使用されます。このモードはman-in-the-middle攻撃に対して脆弱であるため、非推奨であることに注意してください。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };\nCipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };\nCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When SSLv3 and TLS 1.0 were designed, the United States restricted the export of cryptographic software containing certain strong encryption algorithms. A series of cipher suites were designed to operate at reduced key lengths in order to comply with those regulations. Due to advances in computer performance, these algorithms are now unacceptably weak, and export restrictions have since been loosened. TLS 1.1 implementations MUST NOT negotiate these cipher suites in TLS 1.1 mode. However, for backward compatibility they may be offered in the ClientHello for use with TLS 1.0 or SSLv3-only servers. TLS 1.1 clients MUST check that the server did not choose one of these cipher suites during the handshake. These ciphersuites are listed below for informational purposes and to reserve the numbers.",
      "ja": "SSLv3とTLS 1.0が設計されたとき、米国は特定の強力な暗号化アルゴリズムを含む暗号化ソフトウェアの輸出を制限していました。一連の暗号スイートは、これらの規制に準拠するために、短縮されたキー長で動作するように設計されています。コンピュータのパフォーマンスの進歩により、これらのアルゴリズムは現在許容できないほど弱く、輸出制限は緩和されています。 TLS 1.1実装は、TLS 1.1モードでこれらの暗号スイートをネゴシエートしてはなりません（MUST NOT）。ただし、下位互換性のために、ClientHelloで提供され、TLS 1.0またはSSLv3のみのサーバーで使用できます。 TLS 1.1クライアントは、サーバーがハンドシェイク中にこれらの暗号スイートの1つを選択しなかったことを確認する必要があります。これらの暗号スイートは、情報提供と番号の予約のために以下にリストされています。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };\nCipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };\nCipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };\nCipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };\nCipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };\nCipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };\nCipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };\nCipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };\nCipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following cipher suites were defined in [TLSKRB] and are included here for completeness. See [TLSKRB] for details:",
      "ja": "以下の暗号スイートは[TLSKRB]で定義され、完全を期すためにここに含まれています。詳細については、[TLSKRB]を参照してください。"
    },
    {
      "indent": 4,
      "text": "CipherSuite    TLS_KRB5_WITH_DES_CBC_SHA           = { 0x00,0x1E }:\nCipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1F };\nCipherSuite    TLS_KRB5_WITH_RC4_128_SHA           = { 0x00,0x20 };\nCipherSuite    TLS_KRB5_WITH_IDEA_CBC_SHA          = { 0x00,0x21 };\nCipherSuite    TLS_KRB5_WITH_DES_CBC_MD5           = { 0x00,0x22 };\nCipherSuite    TLS_KRB5_WITH_3DES_EDE_CBC_MD5      = { 0x00,0x23 };\nCipherSuite    TLS_KRB5_WITH_RC4_128_MD5           = { 0x00,0x24 };\nCipherSuite    TLS_KRB5_WITH_IDEA_CBC_MD5          = { 0x00,0x25 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following exportable cipher suites were defined in [TLSKRB] and are included here for completeness. TLS 1.1 implementations MUST NOT negotiate these cipher suites.",
      "ja": "以下のエクスポート可能な暗号スイートは[TLSKRB]で定義されており、完全を期すためにここに含まれています。 TLS 1.1実装は、これらの暗号スイートをネゴシエートしてはなりません（MUST NOT）。"
    },
    {
      "indent": 4,
      "text": "CipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA    = { 0x00,0x26};\nCipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA    = { 0x00,0x27};\nCipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_SHA        = { 0x00,0x28};\nCipherSuite  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5    = { 0x00,0x29};\nCipherSuite  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5    = { 0x00,0x2A};\nCipherSuite  TLS_KRB5_EXPORT_WITH_RC4_40_MD5        = { 0x00,0x2B};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following cipher suites were defined in [TLSAES] and are included here for completeness. See [TLSAES] for details:",
      "ja": "以下の暗号スイートは[TLSAES]で定義され、完全を期すためにここに含まれています。詳細については、[TLSAES]を参照してください。"
    },
    {
      "indent": 9,
      "text": "CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA      = { 0x00, 0x2F };\nCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA   = { 0x00, 0x30 };\nCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA   = { 0x00, 0x31 };\nCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA  = { 0x00, 0x32 };\nCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA  = { 0x00, 0x33 };\nCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA  = { 0x00, 0x34 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA      = { 0x00, 0x35 };\nCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA   = { 0x00, 0x36 };\nCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA   = { 0x00, 0x37 };\nCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA  = { 0x00, 0x38 };\nCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA  = { 0x00, 0x39 };\nCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA  = { 0x00, 0x3A };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "The cipher suite space is divided into three regions:",
      "ja": "暗号スイートスペースは3つの領域に分かれています。"
    },
    {
      "indent": 6,
      "text": "1. Cipher suite values with first byte 0x00 (zero) through decimal 191 (0xBF) inclusive are reserved for the IETF Standards Track protocols.",
      "ja": "1. 最初のバイトが0x00（ゼロ）から10進数の191（0xBF）までの暗号スイート値は、IETF標準トラックプロトコル用に予約されています。"
    },
    {
      "indent": 6,
      "text": "2. Cipher suite values with first byte decimal 192 (0xC0) through decimal 254 (0xFE) inclusive are reserved for assignment for non-Standards Track methods.",
      "ja": "2. 最初のバイトが10進192（0xC0）から10進254（0xFE）までの暗号スイート値は、非標準トラックメソッドの割り当て用に予約されています。"
    },
    {
      "indent": 6,
      "text": "3. Cipher suite values with first byte 0xFF are reserved for private use.",
      "ja": "3. 最初のバイトが0xFFの暗号スイートの値は、私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Additional information describing the role of IANA in the allocation of cipher suite code points is described in Section 11.",
      "ja": "暗号スイートのコードポイントの割り当てにおけるIANAの役割を説明する追加情報については、セクション11で説明します。"
    },
    {
      "indent": 3,
      "text": "Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.",
      "ja": "注：暗号スイートの値{0x00、0x1C}および{0x00、0x1D}は、SSL 3のFortezzaベースの暗号スイートとの衝突を避けるために予約されています。"
    },
    {
      "indent": 0,
      "text": "A.6. The Security Parameters",
      "section_title": true,
      "ja": "A.6. セキュリティパラメータ"
    },
    {
      "indent": 9,
      "text": "These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS Record Layer in order to initialize a connection state. SecurityParameters includes:",
      "ja": "これらのセキュリティパラメータは、TLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためのパラメータとしてTLSレコードレイヤに提供されます。 SecurityParametersには以下が含まれます。"
    },
    {
      "indent": 12,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "enum { server, client } ConnectionEnd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "enum { null, rc4, rc2, des, 3des, des40, aes, idea }\nBulkCipherAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "enum { stream, block } CipherType;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "enum { null, md5, sha } MACAlgorithm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "/* The algorithms specified in CompressionMethod,\nBulkCipherAlgorithm, and MACAlgorithm may be added to. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "struct {\n    ConnectionEnd entity;\n    BulkCipherAlgorithm bulk_cipher_algorithm;\n    CipherType cipher_type;\n    uint8 key_size;\n    uint8 key_material_length;\n    MACAlgorithm mac_algorithm;\n    uint8 hash_size;\n    CompressionMethod compression_algorithm;\n    opaque master_secret[48];\n    opaque client_random[32];\n    opaque server_random[32];\n} SecurityParameters;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Glossary",
      "section_title": true,
      "ja": "付録B用語集"
    },
    {
      "indent": 3,
      "text": "Advanced Encryption Standard (AES) AES is a widely used symmetric encryption algorithm. AES is a block cipher with a 128, 192, or 256 bit keys and a 16 byte block size. [AES] TLS currently only supports the 128 and 256 bit key sizes.",
      "ja": "Advanced Encryption Standard（AES）AESは、広く使用されている対称暗号化アルゴリズムです。 AESは、128、192、または256ビットの鍵と16バイトのブロックサイズを持つブロック暗号です。 [AES] TLSは現在128ビットと256ビットの鍵サイズのみをサポートしています。"
    },
    {
      "indent": 3,
      "text": "application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.",
      "ja": "アプリケーションプロトコルアプリケーションプロトコルは、通常、トランスポート層（TCP / IPなど）の上に直接階層化されるプロトコルです。例としては、HTTP、TELNET、FTP、SMTPなどがあります。"
    },
    {
      "indent": 3,
      "text": "asymmetric cipher See public key cryptography.",
      "ja": "非対称暗号公開鍵暗号を参照してください。"
    },
    {
      "indent": 3,
      "text": "authentication Authentication is the ability of one entity to determine the identity of another entity.",
      "ja": "認証認証とは、あるエンティティが別のエンティティのIDを決定する機能です。"
    },
    {
      "indent": 3,
      "text": "block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits is a common block size.",
      "ja": "ブロック暗号ブロック暗号は、ブロックと呼ばれるビットのグループでプレーンテキストを操作するアルゴリズムです。 64ビットは一般的なブロックサイズです。"
    },
    {
      "indent": 3,
      "text": "bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.",
      "ja": "バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).",
      "ja": "暗号ブロック連鎖（CBC）CBCは、ブロック暗号で暗号化されたすべての平文ブロックが、前の暗号テキストブロック（または、最初のブロックの場合は、初期化ベクトル）と最初に排他的ORされるモードです。復号化では、すべてのブロックが最初に復号化され、次に前の暗号文ブロック（またはIV）と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party's identity or some other attributes and its public key.",
      "ja": "証明書X.509プロトコル（別名ISO認証フレームワーク）の一部として、証明書は信頼できる認証局によって割り当てられ、パーティのIDまたはその他の属性とその公開鍵の間の強力なバインディングを提供します。"
    },
    {
      "indent": 3,
      "text": "client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.",
      "ja": "クライアントサーバーへのTLS接続を開始するアプリケーションエンティティ。これは、クライアントが基になるトランスポート接続を開始したことを意味する場合とそうでない場合があります。サーバーとクライアントの主な運用上の違いは、サーバーは通常認証されるのに対し、クライアントはオプションでのみ認証されることです。"
    },
    {
      "indent": 3,
      "text": "client write key The key used to encrypt data written by the client.",
      "ja": "クライアント書き込みキークライアントによって書き込まれたデータを暗号化するために使用されるキー。"
    },
    {
      "indent": 3,
      "text": "client write MAC secret The secret data used to authenticate data written by the client.",
      "ja": "クライアント書き込みMACシークレットクライアントによって書き込まれたデータを認証するために使用されるシークレットデータ。"
    },
    {
      "indent": 3,
      "text": "connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer-to-peer relationships. The connections are transient. Every connection is associated with one session.",
      "ja": "connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer-to-peer relationships. The connections are transient. Every connection is associated with one session."
    },
    {
      "indent": 3,
      "text": "Data Encryption Standard DES is a very widely used symmetric encryption algorithm. DES is a block cipher with a 56 bit key and an 8 byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8 byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security. [DES], [3DES]",
      "ja": "データ暗号化標準DESは、非常に広く使用されている対称暗号化アルゴリズムです。 DESは、56ビットの鍵と8バイトのブロックサイズを持つブロック暗号です。 TLSでは、鍵生成の目的で、DESは8バイトの鍵長（64ビット）を持つものとして扱われますが、それでも56ビットの保護しか提供しません。 （各キーバイトの下位ビットは、そのキーバイトで奇数パリティを生成するように設定されていると想定されています。）DESは、データの各ブロックに対して3つの独立したキーと3つの暗号化が使用されるモードでも動作できます。これは、168ビットの鍵（TLS鍵生成方式では24バイト）を使用し、112ビットのセキュリティと同等のものを提供します。 [DES]、[3DES]"
    },
    {
      "indent": 3,
      "text": "Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186, \"Digital Signature Standard,\" published May 1994 by the U.S. Dept. of Commerce. [DSS]",
      "ja": "デジタル署名標準（DSS）米国国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名の標準。1994年5月に米国国務省によって発行されたNIST FIPS PUB 186「デジタル署名標準」で定義されています。コマース。 [DSS]"
    },
    {
      "indent": 3,
      "text": "digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.",
      "ja": "デジタル署名デジタル署名は、公開鍵暗号と一方向ハッシュ関数を利用して、認証可能なデータの署名を生成します。この署名は、偽造または否認が困難です。"
    },
    {
      "indent": 3,
      "text": "handshake An initial negotiation between client and server that establishes the parameters of their transactions.",
      "ja": "ハンドシェイクトランザクションのパラメータを確立するクライアントとサーバー間の初期のネゴシエーション。"
    },
    {
      "indent": 3,
      "text": "Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.",
      "ja": "初期化ベクトル（IV）CBCモードでブロック暗号が使用される場合、初期化ベクトルは暗号化の前に最初の平文ブロックと排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]",
      "ja": "IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]"
    },
    {
      "indent": 3,
      "text": "Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.",
      "ja": "メッセージ認証コード（MAC）メッセージ認証コードは、メッセージといくつかの秘密データから計算された一方向のハッシュです。秘密のデータを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。"
    },
    {
      "indent": 3,
      "text": "master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.",
      "ja": "マスターシークレット暗号化キー、MACシークレット、およびIVの生成に使用される安全なシークレットデータ。"
    },
    {
      "indent": 3,
      "text": "MD5 MD5 is a secure hashing function that converts an arbitrarily long data stream into a digest of fixed size (16 bytes). [MD5]",
      "ja": "MD5 MD5は、任意の長いデータストリームを固定サイズ（16バイト）のダイジェストに変換する安全なハッシュ関数です。 [MD5]"
    },
    {
      "indent": 3,
      "text": "public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.",
      "ja": "公開鍵暗号2鍵暗号を使用する暗号技術のクラス。公開鍵で暗号化されたメッセージは、関連付けられた秘密鍵でのみ復号化できます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証できます。"
    },
    {
      "indent": 3,
      "text": "one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.",
      "ja": "一方向ハッシュ関数任意量のデータを固定長ハッシュに変換する一方向変換。変換を元に戻したり、衝突を見つけることは、計算上困難です。 MD5とSHAは一方向ハッシュ関数の例です。"
    },
    {
      "indent": 3,
      "text": "RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2].",
      "ja": "RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2]."
    },
    {
      "indent": 3,
      "text": "RC4 A stream cipher invented by Ron Rivest. A compatible cipher is described in [SCH].",
      "ja": "RC4 Ron Rivestが発明したストリーム暗号。互換性のある暗号は[SCH]で説明されています。"
    },
    {
      "indent": 3,
      "text": "RSA A very widely used public-key algorithm that can be used for either encryption or digital signing. [RSA]",
      "ja": "RSA暗号化またはデジタル署名のいずれかに使用できる、非常に広く使用されている公開鍵アルゴリズム。 [RSA]"
    },
    {
      "indent": 3,
      "text": "server The server is the application entity that responds to requests for connections from clients. See also under client.",
      "ja": "サーバーサーバーは、クライアントからの接続要求に応答するアプリケーションエンティティです。クライアントの下も参照してください。"
    },
    {
      "indent": 3,
      "text": "session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters that can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.",
      "ja": "セッションTLSセッションは、クライアントとサーバー間の関連付けです。セッションは、ハンドシェイクプロトコルによって作成されます。セッションは、複数の接続間で共有できる一連の暗号化セキュリティパラメータを定義します。セッションは、各接続の新しいセキュリティパラメータの高価なネゴシエーションを回避するために使用されます。"
    },
    {
      "indent": 3,
      "text": "session identifier A session identifier is a value generated by a server that identifies a particular session.",
      "ja": "セッション識別子セッション識別子は、特定のセッションを識別するサーバーによって生成される値です。"
    },
    {
      "indent": 3,
      "text": "server write key The key used to encrypt data written by the server.",
      "ja": "サーバー書き込みキーサーバーによって書き込まれたデータを暗号化するために使用されるキー。"
    },
    {
      "indent": 3,
      "text": "server write MAC secret The secret data used to authenticate data written by the server.",
      "ja": "サーバー書き込みMACシークレットサーバーによって書き込まれたデータを認証するために使用されるシークレットデータ。"
    },
    {
      "indent": 3,
      "text": "SHA The Secure Hash Algorithm is defined in FIPS PUB 180-2. It produces a 20-byte output. Note that all references to SHA actually use the modified SHA-1 algorithm. [SHA]",
      "ja": "SHAセキュアハッシュアルゴリズムはFIPS PUB 180-2で定義されています。 20バイトの出力を生成します。 SHAへのすべての参照は、実際には変更されたSHA-1アルゴリズムを使用することに注意してください。 [SHA]"
    },
    {
      "indent": 3,
      "text": "SSL Netscape's Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0",
      "ja": "SSL NetscapeのSecure Socket Layerプロトコル[SSL3]。 TLSはSSLバージョン3.0に基づいています"
    },
    {
      "indent": 3,
      "text": "stream cipher An encryption algorithm that converts a key into a cryptographically strong keystream, which is then exclusive-ORed with the plaintext.",
      "ja": "ストリーム暗号鍵を暗号的に強力な鍵ストリームに変換する暗号化アルゴリズム。次に、平文と排他的論理和がとられます。"
    },
    {
      "indent": 3,
      "text": "symmetric cipher See bulk cipher.",
      "ja": "対称暗号バルク暗号を参照してください。"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See \"Comments\" at the end of this document.",
      "ja": "トランスポート層セキュリティ（TLS）このプロトコル。また、Internet Engineering Task Force（IETF）のTransport Layer Securityワーキンググループ。このドキュメントの最後にある「コメント」を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix C. CipherSuite Definitions",
      "section_title": true,
      "ja": "付録C. CipherSuiteの定義"
    },
    {
      "indent": 0,
      "text": "CipherSuite Key Exchange Cipher Hash",
      "ja": "CipherSuite鍵交換暗号ハッシュ"
    },
    {
      "indent": 0,
      "text": "TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA",
      "ja": "沙TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128沙TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC沙TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC沙TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC沙TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC沙TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC沙TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC沙TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC沙TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSSオーバーMD5 TLS_RSA_WITH_NULL_SHA RSAオーバーTLS_NULL_WITH_NULL_NULLヌルヌルヌルTLS_RSA_WITH_NULL_MD5 RSA DES_CBC沙沙TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC沙沙TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC沙沙TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC"
    },
    {
      "indent": 6,
      "text": "Key Exchange Algorithm Description Key size limit",
      "ja": "鍵交換アルゴリズム説明鍵サイズの制限"
    },
    {
      "indent": 6,
      "text": "DHE_DSS Ephemeral DH with DSS signatures None DHE_RSA Ephemeral DH with RSA signatures None DH_anon Anonymous DH, no signatures None DH_DSS DH with DSS-based certificates None DH_RSA DH with RSA-based certificates None RSA = none NULL No key exchange N/A RSA RSA key exchange None",
      "ja": "DHE_DSS Ephemeral DH（DSS署名あり）なしDHE_RSA Ephemeral DH（RSA署名あり）なしDH_anon匿名DH、署名なしなしDH_DSS DH（DSSベースの証明書あり）なしDH_RSA DH（RSAベースの証明書あり）なしRSA =なしNULLキー交換なしN / A RSA RSAキー交換なし"
    },
    {
      "indent": 4,
      "text": " Key Expanded IV Block Cipher Type Material Key Material Size Size",
      "ja": "キー拡張IVブロック暗号タイプタイプマテリアルキーマテリアルサイズサイズ"
    },
    {
      "indent": 4,
      "text": "NULL Stream 0 0 0 N/A IDEA_CBC Block 16 16 8 8 RC2_CBC_40 Block 5 16 8 8 RC4_40 Stream 5 16 0 N/A RC4_128 Stream 16 16 0 N/A DES40_CBC Block 5 8 8 8 DES_CBC Block 8 8 8 8 3DES_EDE_CBC Block 24 24 8 8",
      "ja": "NULLストリーム0 0 0 N / A IDEA_CBCブロック16 16 8 8 RC2_CBC_40ブロック5 16 8 8 RC4_40ストリーム5 16 0 N / A RC4_128ストリーム16 16 0 N / A DES40_CBCブロック5 8 8 8 DES_CBCブロック8 8 8 8 3DES_EDE_CBCブロック24 24 8 8"
    },
    {
      "indent": 3,
      "text": "Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.",
      "ja": "タイプこれがストリーム暗号であるか、CBCモードで実行されているブロック暗号であるかを示します。"
    },
    {
      "indent": 3,
      "text": "Key Material The number of bytes from the key_block that are used for generating the write keys.",
      "ja": "Key Material書き込みキーの生成に使用されるkey_blockからのバイト数。"
    },
    {
      "indent": 3,
      "text": "Expanded Key Material The number of bytes actually fed into the encryption algorithm.",
      "ja": "拡張鍵素材実際に暗号化アルゴリズムに入力されたバイト数。"
    },
    {
      "indent": 3,
      "text": "IV Size The amount of data needed to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.",
      "ja": "IVサイズ初期化ベクトル用に生成する必要があるデータの量。ストリーム暗号の場合はゼロ。ブロック暗号のブロックサイズと同じです。"
    },
    {
      "indent": 3,
      "text": "Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.",
      "ja": "Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size."
    },
    {
      "indent": 7,
      "text": " Hash Hash Padding function Size Size NULL 0 0 MD5 16 48 SHA 20 40",
      "ja": "ハッシュハッシュパディング機能サイズサイズNULL 0 0 MD5 16 48 SHA 20 40"
    },
    {
      "indent": 0,
      "text": "Appendix D. Implementation Notes",
      "section_title": true,
      "ja": "付録D.実装上の注意"
    },
    {
      "indent": 3,
      "text": "The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.",
      "ja": "TLSプロトコルは、多くの一般的なセキュリティミスを防ぐことはできません。このセクションでは、実装者を支援するためのいくつかの推奨事項を示します。"
    },
    {
      "indent": 0,
      "text": "D.1. Random Number Generation and Seeding",
      "section_title": true,
      "ja": "D.1. 乱数の生成とシード"
    },
    {
      "indent": 3,
      "text": "TLS requires a cryptographically secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably MD5 and/or SHA, are acceptable, but cannot provide more security than the size of the random number generator state. (For example, MD5-based PRNGs usually provide 128 bits of state.)",
      "ja": "TLSには、暗号で保護された疑似乱数ジェネレータ（PRNG）が必要です。 PRNGの設計とシードには注意が必要です。安全なハッシュ演算、特にMD5やSHAに基づくPRNGは許容されますが、乱数ジェネレーターの状態のサイズよりも高いセキュリティを提供することはできません。 （たとえば、MD5ベースのPRNGは通常、128ビットの状態を提供します。）"
    },
    {
      "indent": 3,
      "text": "To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible's 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. Seeding a 128-bit PRNG would thus require approximately 100 such timer values.",
      "ja": "生成されるシードマテリアルの量を見積もるには、各シードバイトに予測できない情報のビット数を追加します。たとえば、PC互換の18.2 Hzタイマーから取得したキーストロークタイミング値は、カウンター値の合計サイズが16ビット以上であっても、それぞれ1ビットまたは2ビットのセキュアビットを提供します。したがって、128ビットのPRNGをシードすると、約100個のタイマー値が必要になります。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] provides guidance on the generation of random values.",
      "ja": "[RANDOM] provides guidance on the generation of random values."
    },
    {
      "indent": 0,
      "text": "D.2 Certificates and Authentication",
      "section_title": true,
      "ja": "D.2証明書と認証"
    },
    {
      "indent": 3,
      "text": "Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.",
      "ja": "実装は証明書の整合性を検証する責任があり、通常は証明書失効メッセージをサポートする必要があります。信頼できる認証局（CA）による適切な署名を確実にするために、証明書を常に検証する必要があります。信頼できるCAの選択と追加は、非常に慎重に行う必要があります。ユーザーは、証明書とルートCAに関する情報を表示できる必要があります。"
    },
    {
      "indent": 0,
      "text": "D.3 CipherSuites",
      "section_title": true,
      "ja": "D.3 CipherSuites"
    },
    {
      "indent": 3,
      "text": "TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512- bit RSA keys or signatures are not appropriate for high-security applications.",
      "ja": "TLSは、キーサイズとセキュリティレベルの範囲をサポートしています。適切な実装はおそらく多くの暗号スイートをサポートしません。たとえば、40ビットの暗号化は簡単に破られるため、強力なセキュリティを必要とする実装では、40ビットのキーを許可しないでください。同様に、匿名のDiffie-Hellmanは、中間者攻撃を防ぐことができないため、強くお勧めしません。アプリケーションは、最小および最大のキーサイズも適用する必要があります。たとえば、512ビットのRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションには適していません。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Backward Compatibility with SSL",
      "section_title": true,
      "ja": "付録E. SSLとの下位互換性"
    },
    {
      "indent": 3,
      "text": "For historical reasons and in order to avoid a profligate consumption of reserved port numbers, application protocols that are secured by TLS 1.1, TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share the same connection port. For example, the https protocol (HTTP secured by SSL or TLS) uses port 443 regardless of which security protocol it is using. Thus, some mechanism must be determined to distinguish and negotiate among the various protocols.",
      "ja": "歴史的な理由から、予約されたポート番号の浪費を避けるために、TLS 1.1、TLS 1.0、SSL 3.0、およびSSL 2.0によって保護されているアプリケーションプロトコルは、すべて同じ接続ポートを頻繁に共有します。たとえば、httpsプロトコル（SSLまたはTLSで保護されたHTTP）は、使用しているセキュリティプロトコルに関係なく、ポート443を使用します。したがって、さまざまなプロトコルを区別してネゴシエートするには、いくつかのメカニズムを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "TLS versions 1.1 and 1.0, and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with such older servers SHOULD send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 2} for the version field to note that they support TLS 1.1. If the server supports only TLS 1.0 or SSL 3.0, it will respond with a downrev 3.0 server hello; if it supports TLS 1.1 it will respond with a TLS 1.1 server hello. The negotiation then proceeds as appropriate for the negotiated protocol.",
      "ja": "TLSバージョン1.1と1.0、およびSSL 3.0は非常によく似ています。したがって、両方をサポートするのは簡単です。このような古いサーバーと交渉したいTLSクライアントは、SSL 3.0レコード形式とクライアントハロー構造を使用してクライアントハローメッセージを送信し、バージョンフィールドに{3、2}を送信して、TLS 1.1をサポートしていることを通知する必要があります。サーバーがTLS 1.0またはSSL 3.0のみをサポートしている場合は、downrev 3.0 server helloで応答します。 TLS 1.1をサポートしている場合は、TLS 1.1サーバーのhelloで応答します。その後、ネゴシエーションされたプロトコルに応じて、ネゴシエーションが進行します。"
    },
    {
      "indent": 3,
      "text": "Similarly, a TLS 1.1 server that wishes to interoperate with TLS 1.0 or SSL 3.0 clients SHOULD accept SSL 3.0 client hello messages and respond with a SSL 3.0 server hello if an SSL 3.0 client hello with a version field of {3, 0} is received, denoting that this client does not support TLS. Similarly, if a SSL 3.0 or TLS 1.0 hello with a version field of {3, 1} is received, the server SHOULD respond with a TLS 1.0 hello with a version field of {3, 1}.",
      "ja": "同様に、TLS 1.0またはSSL 3.0クライアントと相互運用するTLS 1.1サーバーは、バージョンフィールドが{3、0}のSSL 3.0クライアントhelloを受信した場合、SSL 3.0クライアントhelloメッセージを受け入れ、SSL 3.0サーバーhelloで応答する必要があります（SHOULD）。 、このクライアントはTLSをサポートしていないことを示しています。同様に、バージョンフィールドが{3、1}のSSL 3.0またはTLS 1.0 helloを受信した場合、サーバーはバージョンフィールドが{3、1}のTLS 1.0 helloで応答する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Whenever a client already knows the highest protocol known to a server (for example, when resuming a session), it SHOULD initiate the connection in that native protocol.",
      "ja": "クライアントがサーバーに知られている最高のプロトコルをすでに知っているときはいつでも（たとえば、セッションを再開するとき）、そのネイティブプロトコルで接続を開始する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "TLS 1.1 clients that support SSL Version 2.0 servers MUST send SSL Version 2.0 client hello messages [SSL2]. TLS servers SHOULD accept either client hello format if they wish to support SSL 2.0 clients on the same connection port. The only deviations from the Version 2.0 specification are the ability to specify a version with a value of three and the support for more ciphering types in the CipherSpec.",
      "ja": "SSLバージョン2.0サーバーをサポートするTLS 1.1クライアントは、SSLバージョン2.0クライアントのハローメッセージ[SSL2]を送信する必要があります。 TLSサーバーは、同じ接続ポートでSSL 2.0クライアントをサポートしたい場合、いずれかのクライアントのhello形式を受け入れる必要があります（SHOULD）。バージョン2.0仕様からの唯一の違いは、3の値でバージョンを指定できることと、CipherSpecでより多くの暗号化タイプをサポートすることです。"
    },
    {
      "indent": 2,
      "text": "Warning: The ability to send Version 2.0 client hello messages will be phased out with all due haste. Implementors SHOULD make every effort to move forward as quickly as possible. Version 3.0 provides better mechanisms for moving to newer versions.",
      "ja": "警告：バージョン2.0クライアントのhelloメッセージを送信する機能は、すべての急いで廃止されます。実装者は、できるだけ早く前進するためにあらゆる努力をする必要があります。バージョン3.0は、新しいバージョンに移行するための優れたメカニズムを提供します。"
    },
    {
      "indent": 7,
      "text": "The following cipher specifications are carryovers from SSL Version 2.0. These are assumed to use RSA for key exchange and authentication.",
      "ja": "以下の暗号仕様は、SSLバージョン2.0からのキャリーオーバーです。これらは、鍵交換と認証にRSAを使用すると想定されています。"
    },
    {
      "indent": 8,
      "text": "V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };\nV2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };\nV2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };\nV2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5\n                                           = { 0x04,0x00,0x80 };\nV2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };\nV2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };\nV2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs SHOULD also include the TLS equivalent (see Appendix A.5):",
      "ja": "Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs SHOULD also include the TLS equivalent (see Appendix A.5):"
    },
    {
      "indent": 8,
      "text": "V2CipherSpec (see TLS name) = { 0x00, CipherSuite };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: TLS 1.1 clients may generate the SSLv2 EXPORT cipher suites in handshakes for backward compatibility but MUST NOT negotiate them in TLS 1.1 mode.",
      "ja": "注：TLS 1.1クライアントは、下位互換性のためにハンドシェイクでSSLv2 EXPORT暗号スイートを生成する場合がありますが、TLS 1.1モードでそれらをネゴシエートしてはなりません。"
    },
    {
      "indent": 0,
      "text": "E.1. Version 2 Client Hello",
      "section_title": true,
      "ja": "E.1. バージョン2クライアントHello"
    },
    {
      "indent": 3,
      "text": "The Version 2.0 client hello message is presented below using this document's presentation model. The true definition is still assumed to be the SSL Version 2.0 specification. Note that this message MUST be sent directly on the wire, not wrapped as an SSLv3 record",
      "ja": "このドキュメントのプレゼンテーションモデルを使用して、バージョン2.0クライアントのhelloメッセージを以下に示します。本当の定義は、依然としてSSLバージョン2.0仕様であると想定されています。このメッセージはSSLv3レコードとしてラップされるのではなく、ネットワーク上で直接送信される必要があることに注意してください。"
    },
    {
      "indent": 5,
      "text": "uint8 V2CipherSpec[3];",
      "ja": "uint8 V2CipherSpec [3];"
    },
    {
      "indent": 5,
      "text": "struct {\n    uint16 msg_length;\n    uint8 msg_type;\n    Version version;\n    uint16 cipher_spec_length;\n    uint16 session_id_length;\n    uint16 challenge_length;\n    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n    opaque session_id[V2ClientHello.session_id_length];\n    opaque challenge[V2ClientHello.challenge_length;\n} V2ClientHello;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "msg_length This field is the length of the following data in bytes. The high bit MUST be 1 and is not part of the length.",
      "ja": "msg_lengthこのフィールドは、後続のデータの長さ（バイト単位）です。上位ビットは1でなければならず、長さの一部ではありません。"
    },
    {
      "indent": 3,
      "text": "msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value SHOULD be one (1).",
      "ja": "msg_typeこのフィールドは、versionフィールドとともに、バージョン2のクライアントのHelloメッセージを識別します。値は1にする必要があります（1）。"
    },
    {
      "indent": 3,
      "text": "version The highest version of the protocol supported by the client (equals ProtocolVersion.version; see Appendix A.1).",
      "ja": "versionクライアントがサポートするプロトコルの最高バージョン（ProtocolVersion.versionと同じ。付録A.1を参照）。"
    },
    {
      "indent": 3,
      "text": "cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and MUST be a multiple of the V2CipherSpec length (3).",
      "ja": "cipher_spec_lengthこのフィールドは、フィールドcipher_specsの全長です。ゼロにすることはできず、V2CipherSpecの長さ（3）の倍数にする必要があります。"
    },
    {
      "indent": 3,
      "text": "session_id_length This field MUST have a value of zero.",
      "ja": "session_id_lengthこのフィールドにはゼロの値が必要です。"
    },
    {
      "indent": 3,
      "text": "challenge_length The length in bytes of the client's challenge to the server to authenticate itself. When using the SSLv2 backward compatible handshake the client MUST use a 32-byte challenge.",
      "ja": "challenge_length自身を認証するためのサーバーへのクライアントのチャレンジの長さ（バイト単位）。 SSLv2下位互換ハンドシェイクを使用する場合、クライアントは32バイトのチャレンジを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "cipher_specs This is a list of all CipherSpecs the client is willing and able to use. There MUST be at least one CipherSpec acceptable to the server.",
      "ja": "cipher_specsこれは、クライアントが喜んで使用できるすべてのCipherSpecのリストです。サーバーに受け入れられるCipherSpecが少なくとも1つ必要です。"
    },
    {
      "indent": 3,
      "text": "session_id This field MUST be empty.",
      "ja": "session_idこのフィールドは空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary-length random. The TLS server will right-justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.",
      "ja": "チャレンジサーバーが自身を識別するためのサーバーへのクライアントチャレンジは、（ほぼ）任意の長さのランダムです。 TLSサーバーは、このプロトコル仕様で指定されているように、チャレンジデータを右寄せしてClientHello.randomデータ（必要に応じて先行ゼロが埋め込まれます）にします。チャレンジの長さが32バイトを超える場合、最後の32バイトのみが使用されます。 V3サーバーが16バイト未満のチャレンジデータを持つV2 ClientHelloを拒否することは正当です（必須ではありません）。"
    },
    {
      "indent": 6,
      "text": "Note: Requests to resume a TLS session MUST use a TLS client hello.",
      "ja": "注：TLSセッションを再開する要求は、TLSクライアントのHelloを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "E.2. Avoiding Man-in-the-Middle Version Rollback",
      "section_title": true,
      "ja": "E.2. 中間者バージョンのロールバックの回避"
    },
    {
      "indent": 3,
      "text": "When TLS clients fall back to Version 2.0 compatibility mode, they SHOULD use special PKCS #1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.",
      "ja": "TLSクライアントがバージョン2.0互換モードにフォールバックする場合、クライアントは特別なPKCS＃1ブロックフォーマットを使用する必要があります（SHOULD）。これは、TLSサーバーがTLS対応クライアントとのバージョン2.0セッションを拒否するように行われます。"
    },
    {
      "indent": 3,
      "text": "When TLS clients are in Version 2.0 compatibility mode, they set the right-hand (least significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random). After decrypting the ENCRYPTED-KEY-DATA field, servers that support TLS SHOULD issue an error if these eight padding bytes are 0x03. Version 2.0 servers receiving blocks padded in this manner will proceed normally.",
      "ja": "TLSクライアントがバージョン2.0互換モードの場合、これらのクライアントは、ENCRYPTED-KEY-DATAフィールドのRSA暗号化のために、PKCSパディングの右側（最下位）のランダムな8バイト（パディングの端末ヌルを含まない）を設定します。 CLIENT-MASTER-KEYを0x03に変更します（他のパディングバイトはランダムです）。 ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8つのパディングバイトが0x03の場合、TLSをサポートするサーバーはエラーを発行する必要があります（SHOULD）。この方法でパディングされたブロックを受信するバージョン2.0サーバーは、正常に処理されます。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Security Analysis",
      "section_title": true,
      "ja": "付録F.セキュリティ分析"
    },
    {
      "indent": 3,
      "text": "The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.",
      "ja": "TLSプロトコルは、安全でないチャネルを介して通信するクライアントとサーバー間の安全な接続を確立するように設計されています。このドキュメントは、攻撃者がかなりの計算リソースを持ち、プロトコルの外部のソースから秘密情報を取得できないことを含め、いくつかの従来の仮定を行います。攻撃者は、通信チャネルを介して送信されたメッセージをキャプチャ、変更、削除、再生、その他改ざんする機能を持っていると想定されています。この付録では、さまざまな攻撃に対抗するためにTLSがどのように設計されているかについて概説します。"
    },
    {
      "indent": 0,
      "text": "F.1. Handshake Protocol",
      "section_title": true,
      "ja": "F.1. Handshake Protocol"
    },
    {
      "indent": 3,
      "text": "The handshake protocol is responsible for selecting a CipherSpec and generating a Master Secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.",
      "ja": "ハンドシェイクプロトコルは、CipherSpecの選択とマスターシークレットの生成を担当します。マスターシークレットは、安全なセッションに関連付けられた主要な暗号化パラメーターを一緒に構成します。ハンドシェイクプロトコルは、信頼できる認証局によって署名された証明書を持つ当事者をオプションで認証することもできます。"
    },
    {
      "indent": 0,
      "text": "F.1.1. Authentication and Key Exchange",
      "section_title": true,
      "ja": "F.1.1. 認証と鍵交換"
    },
    {
      "indent": 3,
      "text": "TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other's certificate is valid and has not expired or been revoked.",
      "ja": "TLSは3つの認証モードをサポートします。両方の認証、非認証クライアントによるサーバー認証、完全な匿名性です。サーバーが認証されるたびに、チャネルは中間者攻撃に対して安全ですが、完全に匿名のセッションは本質的にそのような攻撃に対して脆弱です。匿名サーバーはクライアントを認証できません。サーバーが認証される場合、その証明書メッセージは、受け入れ可能な認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、受け入れ可能な証明書をサーバーに提供する必要があります。各当事者は、相手の証明書が有効であり、有効期限が切れていない、または取り消されていないことを確認する責任があります。"
    },
    {
      "indent": 3,
      "text": "The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the finished messages, encryption keys, and MAC secrets (see Sections 7.4.8, 7.4.9, and 6.3). By sending a correct finished message, parties thus prove that they know the correct pre_master_secret.",
      "ja": "鍵交換プロセスの一般的な目標は、攻撃者ではなく通信相手に知られるpre_master_secretを作成することです。 pre_master_secretは、master_secretを生成するために使用されます（セクション8.1を参照）。 master_secretは、完成したメッセージ、暗号化キー、およびMACシークレットを生成するために必要です（セクション7.4.8、7.4.9、および6.3を参照）。パーティは、正しい完成したメッセージを送信することにより、正しいpre_master_secretを知っていることを証明します。"
    },
    {
      "indent": 0,
      "text": "F.1.1.1. Anonymous Key Exchange",
      "section_title": true,
      "ja": "F.1.1.1. 匿名キー交換"
    },
    {
      "indent": 3,
      "text": "Completely anonymous sessions can be established using RSA or Diffie-Hellman for key exchange. With anonymous RSA, the client encrypts a pre_master_secret with the server's uncertified public key extracted from the server key exchange message. The result is sent in a client key exchange message. Since eavesdroppers do not know the server's private key, it will be infeasible for them to decode the pre_master_secret.",
      "ja": "鍵の交換にRSAまたはDiffie-Hellmanを使用して、完全に匿名のセッションを確立できます。匿名RSAを使用すると、クライアントは、サーバーの鍵交換メッセージから抽出されたサーバーの認証されていない公開鍵を使用してpre_master_secretを暗号化します。結果はクライアントの鍵交換メッセージで送信されます。盗聴者はサーバーの秘密鍵を知らないため、pre_master_secretを解読することは不可能です。"
    },
    {
      "indent": 3,
      "text": "Note: No anonymous RSA Cipher Suites are defined in this document.",
      "ja": "注：このドキュメントでは、匿名のRSA暗号スイートは定義されていません。"
    },
    {
      "indent": 3,
      "text": "With Diffie-Hellman, the server's public parameters are contained in the server key exchange message and the client's are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e., the pre_master_secret).",
      "ja": "Diffie-Hellmanを使用すると、サーバーの公開パラメーターはサーバーの鍵交換メッセージに含まれ、クライアントのパラメーターはクライアントの鍵交換メッセージで送信されます。プライベートな値を知らない盗聴者は、Diffie-Hellmanの結果（つまり、pre_master_secret）を見つけることができません。"
    },
    {
      "indent": 3,
      "text": "Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.",
      "ja": "警告：完全に匿名の接続は、受動的な盗聴に対する保護のみを提供します。独立した改ざん防止チャネルを使用して、完成したメッセージが攻撃者に置き換えられなかったことを確認しない限り、アクティブな中間者攻撃が懸念される環境ではサーバー認証が必要です。"
    },
    {
      "indent": 0,
      "text": "F.1.1.2. RSA Key Exchange and Authentication",
      "section_title": true,
      "ja": "F.1.1.2. RSAキー交換と認証"
    },
    {
      "indent": 3,
      "text": "With RSA, key exchange and server authentication are combined. The public key either may be contained in the server's certificate or may be a temporary RSA key sent in a server key exchange message. When temporary RSA keys are used, they are signed by the server's RSA certificate. The signature includes the current ClientHello.random, so old signatures and temporary keys cannot be replayed. Servers may use a single temporary RSA key for multiple negotiation sessions.",
      "ja": "RSAでは、鍵交換とサーバー認証が組み合わされています。公開キーは、サーバーの証明書に含まれている場合と、サーバーキー交換メッセージで送信される一時的なRSAキーの場合があります。一時的なRSAキーが使用される場合、それらはサーバーのRSA証明書によって署名されます。署名には現在のClientHello.randomが含まれているため、古い署名と一時キーは再生できません。サーバーは、複数のネゴシエーションセッションに単一の一時RSAキーを使用できます。"
    },
    {
      "indent": 3,
      "text": "Note: The temporary RSA key option is useful if servers need large",
      "ja": "注：サーバーが大きなサイズを必要とする場合、一時的なRSAキーオプションが役立ちます。"
    },
    {
      "indent": 9,
      "text": "certificates but must comply with government-imposed size limits on keys used for key exchange.",
      "ja": "証明書ですが、鍵交換に使用される鍵に政府が課すサイズ制限に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that if ephemeral RSA is not used, compromise of the server's static RSA key results in a loss of confidentiality for all sessions protected under that static key. TLS users desiring Perfect Forward Secrecy should use DHE cipher suites. The damage done by exposure of a private key can be limited by changing one's private key (and certificate) frequently.",
      "ja": "エフェメラルRSAを使用しない場合、サーバーの静的RSAキーが危険にさらされると、その静的キーで保護されているすべてのセッションの機密性が失われます。 Perfect Forward Secrecyを希望するTLSユーザーは、DHE暗号スイートを使用する必要があります。秘密鍵の公開による被害は、自分の秘密鍵（および証明書）を頻繁に変更することで制限できます。"
    },
    {
      "indent": 3,
      "text": "After verifying the server's certificate, the client encrypts a pre_master_secret with the server's public key. By successfully decoding the pre_master_secret and producing a correct finished message, the server demonstrates that it knows the private key corresponding to the server certificate.",
      "ja": "サーバーの証明書を確認した後、クライアントはサーバーの公開鍵を使用してpre_master_secretを暗号化します。 pre_master_secretを正常にデコードして正しい終了メッセージを生成することにより、サーバーは、サーバー証明書に対応する秘密鍵を知っていることを示します。"
    },
    {
      "indent": 3,
      "text": "When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from the master_secret and all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.",
      "ja": "RSAをキー交換に使用する場合、クライアントは証明書検証メッセージを使用して認証されます（セクション7.4.8を参照）。クライアントは、master_secretおよび先行するすべてのハンドシェイクメッセージから派生した値に署名します。これらのハンドシェイクメッセージには、署名をサーバーにバインドするサーバー証明書と、署名を現在のハンドシェイクプロセスにバインドするServerHello.randomが含まれます。"
    },
    {
      "indent": 0,
      "text": "F.1.1.3. Diffie-Hellman Key Exchange with Authentication",
      "section_title": true,
      "ja": "F.1.1.3. 認証付きのDiffie-Hellman鍵交換"
    },
    {
      "indent": 3,
      "text": "When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSS or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.",
      "ja": "Diffie-Hellman鍵交換が使用される場合、サーバーは、固定Diffie-Hellmanパラメーターを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSSまたはRSA証明書で署名された一時的なDiffie-Hellmanパラメーターのセットを送信できます。一時的なパラメーターは、署名前にhello.random値でハッシュされ、攻撃者が古いパラメーターを再生しないようにします。どちらの場合でも、クライアントは証明書または署名を検証して、パラメーターがサーバーに属していることを確認できます。"
    },
    {
      "indent": 3,
      "text": "If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.",
      "ja": "クライアントに固定Diffie-Hellmanパラメーターを含む証明書がある場合、その証明書には、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバーは、通信するたびに同じDiffie-Hellman結果（つまり、pre_master_secret）を生成することに注意してください。 pre_master_secretが必要以上に長くメモリに留まるのを防ぐには、できるだけ早くmaster_secretに変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換が機能するために、サーバーによって提供されるものと互換性がある必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client has a standard DSS or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.",
      "ja": "クライアントが標準のDSSまたはRSA証明書を持っているか、認証されていない場合、クライアントはクライアントの鍵交換メッセージで一時パラメーターのセットをサーバーに送信し、オプションで証明書検証メッセージを使用して自身を認証します。"
    },
    {
      "indent": 3,
      "text": "If the same DH keypair is to be used for multiple handshakes, either because the client or server has a certificate containing a fixed DH keypair or because the server is reusing DH keys, care must be taken to prevent small subgroup attacks. Implementations SHOULD follow the guidelines found in [SUBGROUP].",
      "ja": "同じDHキーペアを複数のハンドシェイクに使用する場合、クライアントまたはサーバーに固定DHキーペアを含む証明書があるか、サーバーがDHキーを再利用しているため、小さなサブグループ攻撃を防ぐように注意する必要があります。実装は[サブグループ]にあるガイドラインに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "Small subgroup attacks are most easily avoided by using one of the DHE ciphersuites and generating a fresh DH private key (X) for each handshake. If a suitable base (such as 2) is chosen, g^X mod p can be computed very quickly, therefore the performance cost is minimized. Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE ciphersuites.",
      "ja": "小さなサブグループ攻撃は、DHE暗号スイートの1つを使用し、ハンドシェイクごとに新しいDH秘密キー（X）を生成することで最も簡単に回避できます。適切なベース（2など）を選択すると、g ^ X mod pを非常に迅速に計算できるため、パフォーマンスコストが最小限に抑えられます。さらに、ハンドシェイクごとに新しいキーを使用すると、Perfect Forward Secrecyが提供されます。実装は、DHE暗号スイートを使用する場合、ハンドシェイクごとに新しいXを生成する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "F.1.2. Version Rollback Attacks",
      "section_title": true,
      "ja": "F.1.2. Version Rollback Attacks"
    },
    {
      "indent": 3,
      "text": "Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.",
      "ja": "TLSにはSSLバージョン2.0に対する大幅な改善が含まれているため、攻撃者はTLS対応のクライアントとサーバーをバージョン2.0にフォールバックしようとする可能性があります。この攻撃は、2つのTLS対応パーティがSSL 2.0ハンドシェイクを使用している場合にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application specified wait threshold has expired. Parties concerned about attacks of this scale should not use 40-bit encryption keys. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.",
      "ja": "非ランダムPKCS＃1ブロックタイプ2メッセージパディングを使用するソリューションは洗練されていませんが、バージョン3.0サーバーが攻撃を検出するためのかなり安全な方法を提供します。このソリューションは、攻撃者がキーをブルートフォースし、同じキーを含む新しいENCRYPTED-KEY-DATAメッセージを（ただし、通常のパディングを使用して）代用して、アプリケーションで指定された待機しきい値が満了する前に安全ではありません。この規模の攻撃を懸念する当事者は、40ビットの暗号化キーを使用しないでください。 PKCSパディングの最下位8バイトのパディングを変更しても、プロトコルで使用される署名付きハッシュのサイズとRSAキー長のセキュリティには影響しません。これは、入力ブロックサイズを8バイト増やすことと本質的に同じであるためです。"
    },
    {
      "indent": 0,
      "text": "F.1.3. Detecting Attacks against the Handshake Protocol",
      "section_title": true,
      "ja": "F.1.3. ハンドシェイクプロトコルに対する攻撃の検出"
    },
    {
      "indent": 3,
      "text": "An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally chooses.",
      "ja": "攻撃者は、ハンドシェイク交換に影響を与えて、パーティが通常よりも異なる暗号化アルゴリズムを選択するようにする可能性があります。"
    },
    {
      "indent": 3,
      "text": "For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others' finished messages. Without the master_secret, the attacker cannot repair the finished messages, so the attack will be discovered.",
      "ja": "この攻撃では、攻撃者は1つ以上のハンドシェイクメッセージを積極的に変更する必要があります。これが発生した場合、クライアントとサーバーは、ハンドシェイクメッセージハッシュの異なる値を計算します。その結果、当事者はお互いの完成したメッセージを受け入れません。 master_secretがないと、攻撃者は完了したメッセージを修復できないため、攻撃が発見されます。"
    },
    {
      "indent": 0,
      "text": "F.1.4. Resuming Sessions",
      "section_title": true,
      "ja": "F.1.4. セッションの再開"
    },
    {
      "indent": 3,
      "text": "When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session's master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC secrets are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations (which use both SHA and MD5).",
      "ja": "セッションを再開して接続が確立されると、新しいClientHello.randomとServerHello.randomの値がセッションのmaster_secretでハッシュされます。 master_secretが危険にさらされておらず、暗号化キーとMACシークレットを生成するために使用される安全なハッシュ操作が安全であれば、接続は安全で、以前の接続から事実上独立している必要があります。攻撃者は、既知の暗号化キーまたはMACシークレットを使用して、安全なハッシュ操作（SHAとMD5の両方を使用）を壊さずにmaster_secretを危険にさらすことはできません。"
    },
    {
      "indent": 3,
      "text": "Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.",
      "ja": "クライアントとサーバーの両方が同意しない限り、セッションを再開することはできません。どちらかの当事者が、セッションが危険にさらされている可能性がある、または証明書が期限切れになっている、または取り消されている可能性があると疑う場合は、完全なハンドシェイクを強制する必要があります。 master_secretを取得した攻撃者は、対応するセッションIDが廃止されるまで、侵害されたパーティを偽装できる可能性があるため、セッションIDのライフタイムには24時間の上限をお勧めします。比較的安全でない環境で実行される可能性のあるアプリケーションは、セッションIDを安定したストレージに書き込むべきではありません。"
    },
    {
      "indent": 0,
      "text": "F.1.5. MD5 and SHA",
      "section_title": true,
      "ja": "F.1.5. MD5 and SHA"
    },
    {
      "indent": 3,
      "text": "TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol.",
      "ja": "TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol."
    },
    {
      "indent": 0,
      "text": "F.2. Protecting Application Data",
      "section_title": true,
      "ja": "F.2. アプリケーションデータの保護"
    },
    {
      "indent": 3,
      "text": "The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.",
      "ja": "master_secretはClientHello.randomとServerHello.randomでハッシュされ、接続ごとに一意のデータ暗号化キーとMACシークレットが生成されます。"
    },
    {
      "indent": 3,
      "text": "Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC secret, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS Record Layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow. Messages from one party cannot be inserted into the other's output, since they use independent MAC secrets. Similarly, the server-write and client-write keys are independent, so stream cipher keys are used only once.",
      "ja": "送信データは、送信前にMACで保護されます。メッセージの再生または変更攻撃を防ぐために、MACシークレット、シーケンス番号、メッセージの長さ、メッセージの内容、および2つの固定文字列からMACが計算されます。メッセージタイプフィールドは、1つのTLSレコードレイヤクライアント宛のメッセージが別のクライアントにリダイレクトされないようにするために必要です。シーケンス番号により、メッセージの削除または並べ替えの試行が確実に検出されます。シーケンス番号は64ビット長であるため、オーバーフローすることはありません。あるパーティからのメッセージは、独立したMACシークレットを使用するため、他のパーティの出力には挿入できません。同様に、サーバー書き込みキーとクライアント書き込みキーは独立しているため、ストリーム暗号キーは1回だけ使用されます。"
    },
    {
      "indent": 3,
      "text": "If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.",
      "ja": "攻撃者が暗号化キーを破った場合、それを使用して暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーが侵害されると、メッセージ変更攻撃が可能になります。 MACも暗号化されているため、メッセージ変更攻撃では通常、MACだけでなく暗号化アルゴリズムを破る必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: MAC secrets may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.",
      "ja": "注：MACシークレットは暗号化キーよりも大きい場合があるため、暗号化キーが壊れていてもメッセージは改ざんされないままです。"
    },
    {
      "indent": 0,
      "text": "F.3. Explicit IVs",
      "section_title": true,
      "ja": "F.3. 明示的なIV"
    },
    {
      "indent": 3,
      "text": "[CBCATT] describes a chosen plaintext attack on TLS that depends on knowing the IV for a record. Previous versions of TLS [TLS1.0] used the CBC residue of the previous record as the IV and therefore enabled this attack. This version uses an explicit IV in order to protect against this attack.",
      "ja": "[CBCATT]は、レコードのIVを知ることに依存する、TLSに対する選択された平文攻撃について説明しています。以前のバージョンのTLS [TLS1.0]では、以前のレコードのCBC残差をIVとして使用していたため、この攻撃が可能でした。このバージョンでは、この攻撃から保護するために明示的なIVを使用しています。"
    },
    {
      "indent": 0,
      "text": "F.4. Security of Composite Cipher Modes",
      "section_title": true,
      "ja": "F.4. 複合暗号モードのセキュリティ"
    },
    {
      "indent": 3,
      "text": "TLS secures transmitted application data via the use of symmetric encryption and authentication functions defined in the negotiated ciphersuite. The objective is to protect both the integrity and confidentiality of the transmitted data from malicious actions by active attackers in the network. It turns out that the order in which encryption and authentication functions are applied to the data plays an important role for achieving this goal [ENCAUTH].",
      "ja": "TLSは、ネゴシエートされた暗号スイートで定義された対称暗号化および認証機能を使用して、送信されたアプリケーションデータを保護します。目的は、ネットワーク内のアクティブな攻撃者による悪意のあるアクションから送信データの整合性と機密性の両方を保護することです。暗号化および認証機能がデータに適用される順序が、この目標を達成するために重要な役割を果たすことがわかります[ENCAUTH]。"
    },
    {
      "indent": 3,
      "text": "The most robust method, called encrypt-then-authenticate, first applies encryption to the data and then applies a MAC to the ciphertext. This method ensures that the integrity and confidentiality goals are obtained with ANY pair of encryption and MAC functions, provided that the former is secure against chosen plaintext attacks and that the MAC is secure against chosen-message attacks. TLS uses another method, called authenticate-then-encrypt, in which first a MAC is computed on the plaintext and then the concatenation of plaintext and MAC is encrypted. This method has been proven secure for CERTAIN combinations of encryption functions and MAC functions, but it is not guaranteed to be secure in general. In particular, it has been shown that there exist perfectly secure encryption functions (secure even in the information-theoretic sense) that combined with any secure MAC function, fail to provide the confidentiality goal against an active attack. Therefore, new ciphersuites and operation modes adopted into TLS need to be analyzed under the authenticate-then-encrypt method to verify that they achieve the stated integrity and confidentiality goals.",
      "ja": "暗号化してから認証と呼ばれる最も堅牢な方法は、最初にデータに暗号化を適用し、次に暗号文にMACを適用します。この方法では、暗号化とMAC機能の任意のペアを使用して整合性と機密性の目標を確実に達成できます。 TLSは、authenticate-then-encryptと呼ばれる別の方法を使用します。この方法では、最初に平文でMACが計算され、次に平文とMACの連結が暗号化されます。この方法は、暗号化関数とMAC関数のCERTAINの組み合わせに対して安全であることが証明されていますが、一般的に安全であるとは限りません。特に、安全なMAC機能と組み合わせると完全に安全な暗号化機能（情報理論的にも安全）が存在し、アクティブな攻撃に対する機密性の目標を提供できないことが示されています。したがって、TLSに採用された新しい暗号スイートと操作モードは、authenticate-then-encryptメソッドで分析して、指定された整合性と機密性の目標を達成していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Currently, the security of the authenticate-then-encrypt method has been proven for some important cases. One is the case of stream ciphers in which a computationally unpredictable pad of the length of the message, plus the length of the MAC tag, is produced using a pseudo-random generator and this pad is xor-ed with the concatenation of plaintext and MAC tag. The other is the case of CBC mode using a secure block cipher. In this case, security can be shown if one applies one CBC encryption pass to the concatenation of plaintext and MAC and uses a new, independent, and unpredictable IV for each new pair of plaintext and MAC. In previous versions of SSL, CBC mode was used properly EXCEPT that it used a predictable IV in the form of the last block of the previous ciphertext. This made TLS open to chosen plaintext attacks. This version of the protocol is immune to those attacks. For exact details in the encryption modes proven secure, see [ENCAUTH].",
      "ja": "現在、authenticate-then-encryptメソッドのセキュリティは、いくつかの重要なケースで証明されています。 1つは、ストリーム暗号の場合です。この場合、疑似ランダムジェネレーターを使用して、メッセージの長さとMACタグの長さの計算上予測できないパッドが生成され、このパッドはプレーンテキストとMACの連結とxorされます。鬼ごっこ。もう1つは、安全なブロック暗号を使用するCBCモードの場合です。この場合、プレーンテキストとMACの連結に1つのCBC暗号化パスを適用し、プレーンテキストとMACの新しいペアごとに新しい独立した予測不可能なIVを使用すると、セキュリティを示すことができます。以前のバージョンのSSLでは、以前の暗号文の最後のブロックの形式で予測可能なIVを使用することを除いて、CBCモードは適切に使用されていました。これにより、選択したプレーンテキスト攻撃に対してTLSが開かれました。このバージョンのプロトコルは、これらの攻撃の影響を受けません。安全であることが証明された暗号化モードの詳細については、[ENCAUTH]を参照してください。"
    },
    {
      "indent": 0,
      "text": "F.5. Denial of Service",
      "section_title": true,
      "ja": "F.5. サービス拒否"
    },
    {
      "indent": 3,
      "text": "TLS is susceptible to a number of denial of service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU doing RSA decryption. However, because TLS is generally used over TCP, it is difficult for the attacker to hide his point of origin if proper TCP SYN randomization is used [SEQNUM] by the TCP stack.",
      "ja": "TLSは、多数のサービス拒否（DoS）攻撃の影響を受けます。特に、攻撃者が多数のTCP接続を開始すると、RSA復号化を実行するサーバーが大量のCPUを消費する可能性があります。ただし、TLSは一般にTCPで使用されるため、TCPスタックで適切なTCP SYNランダム化[SEQNUM]が使用されている場合、攻撃者が攻撃元を隠すのは困難です。"
    },
    {
      "indent": 3,
      "text": "Because TLS runs over TCP, it is also susceptible to a number of denial of service attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH [AH-ESP] or ESP [AH-ESP].",
      "ja": "TLSはTCPで実行されるため、個々の接続で多数のサービス拒否攻撃の影響も受けやすくなります。特に、攻撃者はRSTを偽造して接続を終了するか、部分的なTLSレコードを偽造して接続を停止させる可能性があります。これらの攻撃は、一般に、TCPを使用するプロトコルでは防御できません。このクラスの攻撃に関心がある実装者またはユーザーは、IPsec AH [AH-ESP]またはESP [AH-ESP]を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "F.6. Final Notes",
      "section_title": true,
      "ja": "F.6. 最終メモ"
    },
    {
      "indent": 3,
      "text": "For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.",
      "ja": "TLSが安全な接続を提供できるようにするには、クライアントとサーバーの両方のシステム、キー、およびアプリケーションが安全である必要があります。さらに、実装にはセキュリティエラーがないことが必要です。"
    },
    {
      "indent": 3,
      "text": "The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys, 40-bit bulk encryption keys, and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.",
      "ja": "このシステムは、サポートされている最も弱い鍵交換および認証アルゴリズムと同じくらい強力であり、信頼できる暗号化機能のみを使用する必要があります。短い公開鍵、40ビットのバルク暗号化鍵、および匿名サーバーの使用には十分な注意が必要です。実装とユーザーは、どの証明書と認証局が許容できるかを決定するときに注意する必要があります。不正な認証局は多大な損害を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用文献"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Specification for the Advanced Encryption Standard (AES)\" FIPS 197. November 26, 2001.",
      "ja": "[AES]米国国立標準技術研究所、「Advanced Encryption Standard（AES）の仕様」FIPS197。2001年11月26日。"
    },
    {
      "indent": 3,
      "text": "[3DES] W. Tuchman, \"Hellman Presents No Shortcut Solutions To DES,\" IEEE Spectrum, v. 16, n. 7, July 1979, pp. 40-41.",
      "ja": "[3DES] W.タチマン、「ヘルマンはDESにショートカットソリューションを提供しない」、IEEE Spectrum、v。16、n。 1979年7月7日、40-41ページ。"
    },
    {
      "indent": 3,
      "text": "[DES] ANSI X3.106, \"American National Standard for Information Systems-Data Link Encryption,\" American National Standards Institute, 1983.",
      "ja": "[DES] ANSI X3.106、「American National Standard for Information Systems-Data Link Encryption」、American National Standards Institute、1983年。"
    },
    {
      "indent": 3,
      "text": "[DSS] NIST FIPS PUB 186-2, \"Digital Signature Standard,\" National Institute of Standards and Technology, U.S. Department of Commerce, 2000.",
      "ja": "[DSS] NIST FIPS PUB 186-2、「Digital Signature Standard」、米国連邦情報・技術研究所、米国商務省、2000年。"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[IDEA] X. Lai, \"On the Design and Security of Block Ciphers,\" ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.",
      "ja": "[アイデア] X. Lai、「ブロック暗号の設計とセキュリティについて」、情報処理のETHシリーズ、v。1、コンスタンツ：Hartung-Gorre Verlag、1992年。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm \", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest、R。、「MD5 Message-Digest Algorithm」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[PKCS1A] B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 1.5\", RFC 2313, March 1998.",
      "ja": "[PKCS1A] B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 1.5\", RFC 2313, March 1998."
    },
    {
      "indent": 3,
      "text": "[PKCS1B] J. Jonsson, B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[PKCS1B] J. Jonsson、B。Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[PKIX] Housley、R.、Polk、W.、Ford、W。、およびD. Solo、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile」、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RC2] Rivest, R., \"A Description of the RC2(r) Encryption Algorithm\", RFC 2268, March 1998.",
      "ja": "[RC2] Rivest、R。、「RC2（r）暗号化アルゴリズムの説明」、RFC 2268、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[SCH] B. Schneier. \"Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2ed\", Published by John Wiley & Sons, Inc. 1996.",
      "ja": "[SCH] B.シュナイアー。 「Applied Cryptography：Protocols、Algorithms、and Source Code in C、2ed」、John Wiley＆Sons、Inc. 1996年発行。"
    },
    {
      "indent": 3,
      "text": "[SHA] NIST FIPS PUB 180-2, \"Secure Hash Standard,\" National Institute of Standards and Technology, U.S. Department of Commerce., August 2001.",
      "ja": "[SHA] NIST FIPS PUB 180-2、「Secure Hash Standard」、米国連邦情報・技術局、米国商務省、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[REQ] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[REQ] Bradner、S。、「RFCで使用して要件レベルを示すためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998."
    },
    {
      "indent": 3,
      "text": "[TLSAES] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "[TLSAES] Chown、P。、「Advanced Encryption Standard（AES）Ciphersuites for Transport Layer Security（TLS）」、RFC 3268、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[TLSEXT] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 3546, June 2003.",
      "ja": "[TLSEXT] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J。、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 3546、2003年6月。"
    },
    {
      "indent": 3,
      "text": "[TLSKRB] Medvinsky, A. and M. Hur, \"Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)\", RFC 2712, October 1999.",
      "ja": "[TLSKRB] Medvinsky、A。およびM. Hur、「トランスポート層セキュリティ（TLS）へのKerberos暗号スイートの追加」、RFC 2712、1999年10月。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[AH-ESP] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[AH-ESP]ケント、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。"
    },
    {
      "indent": 14,
      "text": "Eastlake 3rd, D., \"Cryptographic Algorithm Implementation Requirements for Encapsulating Security Payload (ESP) and Authentication Header (AH)\", RFC 4305, December 2005.",
      "ja": "Eastlake 3rd、D。、「カプセル化セキュリティペイロード（ESP）および認証ヘッダー（AH）の暗号化アルゴリズム実装要件」、RFC 4305、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[BLEI] Bleichenbacher D., \"Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1\" in Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, pages: 1-12, 1998.",
      "ja": "[BLEI] Bleichenbacher D。、「Advance in Cryptology-CRYPTO'98、LNCS vol。のRSA暗号化標準PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃」 1462、ページ：1-12、1998。"
    },
    {
      "indent": 3,
      "text": "[CBCATT] Moeller, B., \"Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures\", http://www.openssl.org/~bodo/tls-cbc.txt.",
      "ja": "[CBCATT] Moeller、B。、「SSL / TLSにおけるCBC暗号スイートのセキュリティ：問題と対策」、http：//www.openssl.org/~bodo/tls-cbc.txt。"
    },
    {
      "indent": 3,
      "text": "[CBCTIME] Canvel, B., \"Password Interception in a SSL/TLS Channel\", http://lasecwww.epfl.ch/memo_ssl.shtml, 2003.",
      "ja": "[CBCTIME] Canvel、B。、「SSL / TLSチャネルでのパスワード傍受」、http：//lasecwww.epfl.ch/memo_ssl.shtml、2003年。"
    },
    {
      "indent": 3,
      "text": "[ENCAUTH] Krawczyk, H., \"The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)\", Crypto 2001.",
      "ja": "[ENCAUTH] Krawczyk、H。、「通信を保護するための暗号化と認証の順序（または、SSLの安全性は？）」、Crypto 2001。"
    },
    {
      "indent": 3,
      "text": "[KPR03] Klima, V., Pokorny, O., Rosa, T., \"Attacking RSA-based Sessions in SSL/TLS\", http://eprint.iacr.org/2003/052/, March 2003.",
      "ja": "[KPR03] Klima、V.、Pokorny、O.、Rosa、T。、「SSL / TLSでのRSAベースのセッションへの攻撃」、http：//eprint.iacr.org/2003/052/、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[PKCS6] RSA Laboratories, \"PKCS #6: RSA Extended Certificate Syntax Standard,\" version 1.5, November 1993.",
      "ja": "[PKCS6] RSA Laboratories、「PKCS＃6：RSA Extended Certificate Syntax Standard」、バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS7] RSA Laboratories, \"PKCS #7: RSA Cryptographic Message Syntax Standard,\" version 1.5, November 1993.",
      "ja": "[PKCS7] RSA Laboratories、「PKCS＃7：RSA Cryptographic Message Syntax Standard」、バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[ランダム] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RSA] R. Rivest, A. Shamir, and L. M. Adleman, \"A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,\" Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-126.",
      "ja": "[RSA] R.リヴェスト、A。シャミール、およびL. M.アドルマン、「デジタル署名および公開鍵暗号システムを取得する方法」、ACMの通信、v。21、n。 1978年2月2日、120-126ページ。"
    },
    {
      "indent": 3,
      "text": "[SEQNUM] Bellovin, S., \"Defending Against Sequence Number Attacks\", RFC 1948, May 1996.",
      "ja": "[SEQNUM] Bellovin、S.、「シーケンス番号攻撃に対する防御」、RFC 1948、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[SSL2] Hickman, Kipp, \"The SSL Protocol\", Netscape Communications Corp., Feb 9, 1995.",
      "ja": "[SSL2] Hickman、Kipp、「The SSL Protocol」、Netscape Communications Corp.、1995年2月9日。"
    },
    {
      "indent": 3,
      "text": "[SSL3] A. Frier, P. Karlton, and P. Kocher, \"The SSL 3.0 Protocol\", Netscape Communications Corp., Nov 18, 1996.",
      "ja": "[SSL3] A. Frier、P。Karlton、およびP. Kocher、「The SSL 3.0 Protocol」、Netscape Communications Corp.、1996年11月18日。"
    },
    {
      "indent": 3,
      "text": "[SUBGROUP] Zuccherato, R., \"Methods for Avoiding the \"Small-Subgroup\" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME\", RFC 2785, March 2000.",
      "ja": "[サブグループ] Zuccherato、R。、「S / MIMEのDiffie-Hellman鍵合意方法に対する「小サブグループ」攻撃を回避する方法」、RFC 2785、2000年3月。"
    },
    {
      "indent": 3,
      "text": "[TCP] Hellstrom, G. and P. Jones, \"RTP Payload for Text Conversation\", RFC 4103, June 2005.",
      "ja": "[TCP] Hellstrom、G。およびP. Jones、「RTP Payload for Text Conversation」、RFC 4103、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[TIMING] Boneh, D., Brumley, D., \"Remote timing attacks are practical\", USENIX Security Symposium 2003.",
      "ja": "[タイミング] Boneh、D.、Brumley、D。、「リモートタイミング攻撃は実用的」、USENIXセキュリティシンポジウム2003。"
    },
    {
      "indent": 3,
      "text": "[TLS1.0] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS1.0] Dierks、T。およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[X501] ITU-T Recommendation X.501: Information Technology - Open Systems Interconnection - The Directory: Models, 1993.",
      "ja": "[X501] ITU-T勧告X.501：情報技術-オープンシステム相互接続-ディレクトリ：モデル、1993。"
    },
    {
      "indent": 3,
      "text": "[X509] ITU-T Recommendation X.509 (1997 E): Information Technology - Open Systems Interconnection - \"The Directory - Authentication Framework\". 1988.",
      "ja": "[X509] ITU-T勧告X.509（1997 E）：情報技術-オープンシステム相互接続-「ディレクトリ-認証フレームワーク」。 1988。"
    },
    {
      "indent": 3,
      "text": "[XDR] Srinivasan, R., \"XDR: External Data Representation Standard\", RFC 1832, August 1995.",
      "ja": "[XDR] Srinivasan、R。、「XDR：外部データ表現標準」、RFC 1832、1995年8月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Working Group Chairs",
      "ja": "ワーキンググループチェア"
    },
    {
      "indent": 3,
      "text": "Win Treese",
      "ja": "勝利Treese"
    },
    {
      "indent": 3,
      "text": "EMail: treese@acm.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eric Rescorla",
      "ja": "Eric Rescorla"
    },
    {
      "indent": 3,
      "text": "EMail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Editors",
      "ja": "編集者"
    },
    {
      "indent": 3,
      "text": "Tim Dierks Independent",
      "ja": "ティム・ディークス独立"
    },
    {
      "indent": 3,
      "text": "EMail: tim@dierks.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc.",
      "ja": "Eric Rescorla RTFM、Inc."
    },
    {
      "indent": 3,
      "text": "EMail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Other Contributors",
      "ja": "その他の貢献者"
    },
    {
      "indent": 3,
      "text": "Christopher Allen (co-editor of TLS 1.0) Alacrity Ventures EMail: ChristopherA@AlacrityManagement.com",
      "ja": "Christopher Allen（TLS 1.0の共同編集者）Alacrity Ventures Eメール：ChristopherA@AlacrityManagement.com"
    },
    {
      "indent": 3,
      "text": "Martin Abadi University of California, Santa Cruz EMail: abadi@cs.ucsc.edu",
      "ja": "カリフォルニア州マーティンアバディ大学、サンタクルーズEメール：abadi@cs.ucsc.edu"
    },
    {
      "indent": 3,
      "text": "Ran Canetti IBM EMail: canetti@watson.ibm.com Taher Elgamal Securify EMail: taher@securify.com",
      "ja": "Ran Canetti IBM Eメール：canetti@watson.ibm.com Taher Elgamal Securify Eメール：taher@s​​ecurify.com"
    },
    {
      "indent": 3,
      "text": "Anil Gangolli EMail: anil@busybuddha.org",
      "ja": "Anil Gangolickiメール：anil@bussybuddha.org"
    },
    {
      "indent": 3,
      "text": "Kipp Hickman",
      "ja": "キップ・ヒックマン"
    },
    {
      "indent": 3,
      "text": "Phil Karlton (co-author of SSLv3)",
      "ja": "Phil Karlton（SSLv3の共著者）"
    },
    {
      "indent": 3,
      "text": "Paul Kocher (co-author of SSLv3) Cryptography Research EMail: paul@cryptography.com",
      "ja": "Paul Kocher（SSLv3の共著者）暗号研究Eメール：paul@cryptography.com"
    },
    {
      "indent": 3,
      "text": "Hugo Krawczyk Technion Israel Institute of Technology EMail: hugo@ee.technion.ac.il",
      "ja": "Hugo Krawczyk Technion Israel Institute of Technologyメール：hugo@ee.technion.ac.il"
    },
    {
      "indent": 3,
      "text": "Robert Relyea Netscape Communications EMail: relyea@netscape.com",
      "ja": "Robert Relyea Netscape Communications EMail：relyea@netscape.com"
    },
    {
      "indent": 3,
      "text": "Jim Roskind Netscape Communications EMail: jar@netscape.com",
      "ja": "Jim Roskind Netscape Communications Eメール：jar@netscape.com"
    },
    {
      "indent": 3,
      "text": "Michael Sabin",
      "ja": "マイケル・サビン"
    },
    {
      "indent": 3,
      "text": "Dan Simon Microsoft, Inc. EMail: dansimon@microsoft.com",
      "ja": "そしてサイモンマイクロソフト社メール：dansimon@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Tom Weinstein",
      "ja": "トム・ワインスタイン"
    },
    {
      "indent": 0,
      "text": "Comments",
      "ja": "コメント"
    },
    {
      "indent": 3,
      "text": "The discussion list for the IETF TLS working group is located at the e-mail address <ietf-tls@lists.consensus.com>. Information on the group and information on how to subscribe to the list is at <http://lists.consensus.com/>.",
      "ja": "IETF TLSワーキンググループのディスカッションリストは、電子メールアドレス<ietf-tls@lists.consensus.com>にあります。グループに関する情報とリストの購読方法に関する情報は、<http://lists.consensus.com/>にあります。"
    },
    {
      "indent": 3,
      "text": "Archives of the list can be found at:\n    <http://www.imc.org/ietf-tls/mail-archive/> Full Copyright Statement",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースは、すべての保証を明示的または明示的に提供します。ここに含まれる情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、または一般ライセンスを取得しようとした試み、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得した結果を取得できます。 http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}