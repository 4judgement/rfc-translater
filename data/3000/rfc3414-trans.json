{
  "title": {
    "text": "RFC 3414 - User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)",
    "ja": "RFC 3414 - Simple Network Management Protocol（SNMPv3）バージョン3のユーザーベースのセキュリティモデル（USM）"
  },
  "number": 3414,
  "created_at": "2020-08-15 12:18:03.428363+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      U. Blumenthal\nRequest for Comments: 3414                                     B. Wijnen\nSTD: 62                                              Lucent Technologies\nObsoletes: 2574                                            December 2002\nCategory: Standards Track",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)",
      "ja": "Simple Network Management Protocol（SNMPv3）バージョン3のユーザーベースのセキュリティモデル（USM）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（2002）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the User-based Security Model (USM) for Simple Network Management Protocol (SNMP) version 3 for use in the SNMP architecture. It defines the Elements of Procedure for providing SNMP message level security. This document also includes a Management Information Base (MIB) for remotely monitoring/managing the configuration parameters for this Security Model. This document obsoletes RFC 2574.",
      "ja": "このドキュメントでは、SNMPアーキテクチャで使用する簡易ネットワーク管理プロトコル（SNMP）バージョン3のユーザーベースのセキュリティモデル（USM）について説明します。 SNMPメッセージレベルのセキュリティを提供するための手順の要素を定義します。このドキュメントには、このセキュリティモデルの構成パラメータをリモートで監視/管理するための管理情報ベース（MIB）も含まれています。このドキュメントはRFC 2574を廃止します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.        Introduction..........................................  4\n1.1.      Threats...............................................  4\n1.2.      Goals and Constraints.................................  6\n1.3.      Security Services.....................................  6\n1.4.      Module Organization...................................  7\n1.4.1.    Timeliness Module.....................................  8\n1.4.2.    Authentication Protocol...............................  8\n1.4.3.    Privacy Protocol......................................  8\n1.5.      Protection against Message Replay, Delay\n          and Redirection.......................................  9\n1.5.1.    Authoritative SNMP engine.............................  9\n1.5.2.    Mechanisms............................................  9\n1.6.      Abstract Service Interfaces........................... 11",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "1.6.1.    User-based Security Model Primitives\n          for Authentication.................................... 11\n1.6.2.    User-based Security Model Primitives\n          for Privacy........................................... 12\n2.        Elements of the Model................................. 12\n2.1.      User-based Security Model Users....................... 12\n2.2.      Replay Protection..................................... 13\n2.2.1.    msgAuthoritativeEngineID.............................. 14\n2.2.2.    msgAuthoritativeEngineBoots and\n          msgAuthoritativeEngineTime............................ 14\n2.2.3.    Time Window........................................... 15\n2.3.      Time Synchronization.................................. 15\n2.4.      SNMP Messages Using this Security Model............... 16\n2.5.      Services provided by the User-based Security Model.... 17\n2.5.1.    Services for Generating an Outgoing SNMP Message...... 17\n2.5.2.    Services for Processing an Incoming SNMP Message...... 20\n2.6.      Key Localization Algorithm............................ 22\n3.        Elements of Procedure................................. 22\n3.1.      Generating an Outgoing SNMP Message................... 22\n3.2.      Processing an Incoming SNMP Message................... 26\n4.        Discovery............................................. 31\n5.        Definitions........................................... 32\n6.        HMAC-MD5-96 Authentication Protocol................... 51\n6.1.      Mechanisms............................................ 51\n6.1.1.    Digest Authentication Mechanism....................... 51\n6.2.      Elements of the Digest Authentication Protocol........ 52\n6.2.1.    Users................................................. 52\n6.2.2.    msgAuthoritativeEngineID.............................. 53\n6.2.3.    SNMP Messages Using this Authentication Protocol...... 53\n6.2.4.    Services provided by the HMAC-MD5-96\n          Authentication Module................................. 53\n6.2.4.1.  Services for Generating an Outgoing SNMP Message...... 53\n6.2.4.2.  Services for Processing an Incoming SNMP Message...... 54\n6.3.      Elements of Procedure................................. 55\n6.3.1.    Processing an Outgoing Message........................ 55\n6.3.2.    Processing an Incoming Message........................ 56\n7.        HMAC-SHA-96 Authentication Protocol................... 57\n7.1.      Mechanisms............................................ 57\n7.1.1.    Digest Authentication Mechanism....................... 57\n7.2.      Elements of the HMAC-SHA-96 Authentication Protocol... 58\n7.2.1.    Users................................................. 58\n7.2.2.    msgAuthoritativeEngineID.............................. 58\n7.2.3.    SNMP Messages Using this Authentication Protocol...... 59\n7.2.4.    Services provided by the HMAC-SHA-96\n          Authentication Module................................. 59\n7.2.4.1.  Services for Generating an Outgoing SNMP Message...... 59\n7.2.4.2.  Services for Processing an Incoming SNMP Message...... 60\n7.3.      Elements of Procedure................................. 61",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "7.3.1.    Processing an Outgoing Message........................ 61\n7.3.2.    Processing an Incoming Message........................ 61\n8.        CBC-DES Symmetric Encryption Protocol................. 63\n8.1.      Mechanisms............................................ 63\n8.1.1.    Symmetric Encryption Protocol......................... 63\n8.1.1.1.  DES key and Initialization Vector..................... 64\n8.1.1.2.  Data Encryption....................................... 65\n8.1.1.3.  Data Decryption....................................... 65\n8.2.      Elements of the DES Privacy Protocol.................. 65\n8.2.1.    Users................................................. 65\n8.2.2.    msgAuthoritativeEngineID.............................. 66\n8.2.3.    SNMP Messages Using this Privacy Protocol............. 66\n8.2.4.    Services provided by the DES Privacy Module........... 66\n8.2.4.1.  Services for Encrypting Outgoing Data................. 66\n8.2.4.2.  Services for Decrypting Incoming Data................. 67\n8.3.      Elements of Procedure................................. 68\n8.3.1.    Processing an Outgoing Message........................ 68\n8.3.2.    Processing an Incoming Message........................ 69\n9.        Intellectual Property................................. 69\n10.       Acknowledgements...................................... 70\n11.       Security Considerations............................... 71\n11.1.     Recommended Practices................................. 71\n11.2.     Defining Users........................................ 73\n11.3.     Conformance........................................... 74\n11.4.     Use of Reports........................................ 75\n11.5.     Access to the SNMP-USER-BASED-SM-MIB.................. 75\n12.       References............................................ 75\nA.1.      SNMP engine Installation Parameters................... 78\nA.2.      Password to Key Algorithm............................. 80\nA.2.1.    Password to Key Sample Code for MD5................... 81\nA.2.2.    Password to Key Sample Code for SHA................... 82\nA.3.      Password to Key Sample Results........................ 83\nA.3.1.    Password to Key Sample Results using MD5.............. 83\nA.3.2.    Password to Key Sample Results using SHA.............. 83\nA.4.      Sample encoding of msgSecurityParameters.............. 83\nA.5.      Sample keyChange Results.............................. 84\nA.5.1.    Sample keyChange Results using MD5.................... 84\nA.5.2.    Sample keyChange Results using SHA.................... 85\nB.        Change Log............................................ 86\n          Editors' Addresses.................................... 87\n          Full Copyright Statement.............................. 88",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Architecture for describing Internet Management Frameworks [RFC3411] describes that an SNMP engine is composed of:",
      "ja": "インターネット管理フレームワークを記述するためのアーキテクチャ[RFC3411]は、SNMPエンジンは以下で構成されていると記述しています。"
    },
    {
      "indent": 3,
      "text": "1) a Dispatcher, 2) a Message Processing Subsystem, 3) a Security Subsystem, and 4) an Access Control Subsystem.",
      "ja": "1）ディスパッチャー、2）メッセージ処理サブシステム、3）セキュリティサブシステム、4）アクセス制御サブシステム。"
    },
    {
      "indent": 3,
      "text": "Applications make use of the services of these subsystems.",
      "ja": "アプリケーションは、これらのサブシステムのサービスを利用します。"
    },
    {
      "indent": 3,
      "text": "It is important to understand the SNMP architecture and the terminology of the architecture to understand where the Security Model described in this document fits into the architecture and interacts with other subsystems within the architecture. The reader is expected to have read and understood the description of the SNMP architecture, as defined in [RFC3411].",
      "ja": "このドキュメントで説明されているセキュリティモデルがアーキテクチャに適合し、アーキテクチャ内の他のサブシステムと相互作用する場所を理解するには、SNMPアーキテクチャとアーキテクチャの用語を理解することが重要です。読者は、[RFC3411]で定義されているように、SNMPアーキテクチャの説明を読んで理解していることが期待されます。"
    },
    {
      "indent": 3,
      "text": "This memo describes the User-based Security Model as it is used within the SNMP Architecture. The main idea is that we use the traditional concept of a user (identified by a userName) with which to associate security information.",
      "ja": "このメモは、SNMPアーキテクチャ内で使用されるユーザーベースのセキュリティモデルについて説明しています。主なアイデアは、セキュリティ情報を関連付けるために、ユーザー（userNameで識別される）の従来の概念を使用することです。"
    },
    {
      "indent": 3,
      "text": "This memo describes the use of HMAC-MD5-96 and HMAC-SHA-96 as the authentication protocols and the use of CBC-DES as the privacy protocol. The User-based Security Model however allows for other such protocols to be used instead of or concurrent with these protocols. Therefore, the description of HMAC-MD5-96, HMAC-SHA-96 and CBC-DES are in separate sections to reflect their self-contained nature and to indicate that they can be replaced or supplemented in the future.",
      "ja": "このメモは、認証プロトコルとしてのHMAC-MD5-96およびHMAC-SHA-96の使用と、プライバシープロトコルとしてのCBC-DESの使用について説明しています。ただし、ユーザーベースのセキュリティモデルでは、これらのプロトコルの代わりに、または同時に使用できる他のプロトコルを使用できます。したがって、HMAC-MD5-96、HMAC-SHA-96、およびCBC-DESの説明は、独立した性質を反映し、将来、それらを交換または補足できることを示すために、別々のセクションにあります。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Threats",
      "section_title": true,
      "ja": "1.1. 脅威"
    },
    {
      "indent": 3,
      "text": "Several of the classical threats to network protocols are applicable to the network management problem and therefore would be applicable to any SNMP Security Model. Other threats are not applicable to the network management problem. This section discusses principal threats, secondary threats, and threats which are of lesser importance.",
      "ja": "ネットワークプロトコルに対する従来の脅威のいくつかは、ネットワーク管理の問題に適用できるため、SNMPセキュリティモデルに適用できます。その他の脅威は、ネットワーク管理の問題には適用されません。このセクションでは、主要な脅威、二次的な脅威、およびそれほど重要ではない脅威について説明します。"
    },
    {
      "indent": 3,
      "text": "The principal threats against which this SNMP Security Model should provide protection are:",
      "ja": "このSNMPセキュリティモデルが保護を提供する主な脅威は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- Modification of Information The modification threat is the danger that some unauthorized entity may alter in-transit SNMP messages generated on behalf of an authorized principal in such a way as to effect unauthorized management operations, including falsifying the value of an object.",
      "ja": "- 情報の変更変更の脅威とは、許可されていないエンティティが、権限のあるプリンシパルに代わって生成された送信中のSNMPメッセージを、オブジェクトの値の改ざんなど、許可されていない管理操作を実行するように変更する可能性があることです。"
    },
    {
      "indent": 3,
      "text": "- Masquerade The masquerade threat is the danger that management operations not authorized for some user may be attempted by assuming the identity of another user that has the appropriate authorizations.",
      "ja": "- マスカレードマスカレードの脅威とは、特定のユーザーに許可されていない管理操作が、適切な許可を持つ別のユーザーのIDを装うことによって試行される可能性があるという危険です。"
    },
    {
      "indent": 3,
      "text": "Two secondary threats are also identified. The Security Model defined in this memo provides limited protection against:",
      "ja": "2つの二次的な脅威も特定されています。このメモで定義されているセキュリティモデルは、以下に対する限定的な保護を提供します。"
    },
    {
      "indent": 3,
      "text": "- Disclosure The disclosure threat is the danger of eavesdropping on the exchanges between managed agents and a management station. Protecting against this threat may be required as a matter of local policy.",
      "ja": "- 開示開示の脅威は、管理対象エージェントと管理ステーション間のやり取りを盗聴する危険性です。この脅威からの保護は、ローカルポリシーの問題として必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "- Message Stream Modification The SNMP protocol is typically based upon a connection-less transport service which may operate over any sub-network service. The re-ordering, delay or replay of messages can and does occur through the natural operation of many such sub-network services. The message stream modification threat is the danger that messages may be maliciously re-ordered, delayed or replayed to an extent which is greater than can occur through the natural operation of a sub-network service, in order to effect unauthorized management operations.",
      "ja": "- メッセージストリームの変更SNMPプロトコルは通常、任意のサブネットワークサービスで動作するコネクションレス型トランスポートサービスに基づいています。メッセージの並べ替え、遅延、または再生は、このような多くのサブネットワークサービスの自然な動作を通じて発生する可能性があります。メッセージストリーム変更の脅威とは、不正な管理操作を実行するために、メッセージが悪意を持って再順序付け、遅延、またはサブネットワークサービスの自然な操作を通じて発生する可能性がある範囲よりも大きく再生される危険性です。"
    },
    {
      "indent": 3,
      "text": "There are at least two threats that an SNMP Security Model need not protect against. The security protocols defined in this memo do not provide protection against:",
      "ja": "SNMPセキュリティモデルが防御する必要のない脅威が少なくとも2つあります。このメモで定義されているセキュリティプロトコルは、以下に対する保護を提供しません。"
    },
    {
      "indent": 3,
      "text": "- Denial of Service This SNMP Security Model does not attempt to address the broad range of attacks by which service on behalf of authorized users is denied. Indeed, such denial-of-service attacks are in many cases indistinguishable from the type of network failures with which any viable network management protocol must cope as a matter of course.",
      "ja": "- サービス拒否このSNMPセキュリティモデルは、許可されたユーザーに代わってサービスが拒否される広範な攻撃に対処することを試みません。実際、このようなサービス拒否攻撃は、多くの場合、実行可能なネットワーク管理プロトコルが対処しなければならないネットワーク障害のタイプと区別がつきません。"
    },
    {
      "indent": 3,
      "text": "- Traffic Analysis This SNMP Security Model does not attempt to address traffic analysis attacks. Indeed, many traffic patterns are predictable - devices may be managed on a regular basis by a relatively small number of management applications - and therefore there is no significant advantage afforded by protecting against traffic analysis.",
      "ja": "- トラフィック分析このSNMPセキュリティモデルは、トラフィック分析攻撃への対処を試みていません。実際、多くのトラフィックパターンは予測可能です。デバイスは比較的少数の管理アプリケーションによって定期的に管理される可能性があるため、トラフィック分析から保護することによる大きなメリットはありません。"
    },
    {
      "indent": 0,
      "text": "1.2. Goals and Constraints",
      "section_title": true,
      "ja": "1.2. 目標と制約"
    },
    {
      "indent": 3,
      "text": "Based on the foregoing account of threats in the SNMP network management environment, the goals of this SNMP Security Model are as follows.",
      "ja": "前述のSNMPネットワーク管理環境における脅威の説明に基づいて、このSNMPセキュリティモデルの目標は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1) Provide for verification that each received SNMP message has not been modified during its transmission through the network.",
      "ja": "1）ネットワークを介した送信中に、受信した各SNMPメッセージが変更されていないことを確認します。"
    },
    {
      "indent": 3,
      "text": "2) Provide for verification of the identity of the user on whose behalf a received SNMP message claims to have been generated.",
      "ja": "2）受信したSNMPメッセージが生成されたと主張するユーザーに代わって、ユーザーのIDの検証を提供します。"
    },
    {
      "indent": 3,
      "text": "3) Provide for detection of received SNMP messages, which request or contain management information, whose time of generation was not recent.",
      "ja": "3）管理情報を要求または含む、生成時刻が最近ではない受信SNMPメッセージの検出を提供します。"
    },
    {
      "indent": 3,
      "text": "4) Provide, when necessary, that the contents of each received SNMP message are protected from disclosure.",
      "ja": "4）必要に応じて、受信した各SNMPメッセージの内容が開示されないように保護します。"
    },
    {
      "indent": 3,
      "text": "In addition to the principal goal of supporting secure network management, the design of this SNMP Security Model is also influenced by the following constraints:",
      "ja": "安全なネットワーク管理をサポートするという主な目標に加えて、このSNMPセキュリティモデルの設計は、次の制約にも影響を受けます。"
    },
    {
      "indent": 3,
      "text": "1) When the requirements of effective management in times of network stress are inconsistent with those of security, the design of USM has given preference to the former.",
      "ja": "1）ネットワークストレス時の効果的な管理の要件がセキュリティの要件と一致しない場合、USMの設計は前者を優先しました。"
    },
    {
      "indent": 3,
      "text": "2) Neither the security protocol nor its underlying security mechanisms should depend upon the ready availability of other network services (e.g., Network Time Protocol (NTP) or key management protocols).",
      "ja": "2）セキュリティプロトコルも、その基盤となるセキュリティメカニズムも、他のネットワークサービス（ネットワークタイムプロトコル（NTP）やキー管理プロトコルなど）の可用性に依存してはなりません。"
    },
    {
      "indent": 3,
      "text": "3) A security mechanism should entail no changes to the basic SNMP network management philosophy.",
      "ja": "3）セキュリティメカニズムは、基本的なSNMPネットワーク管理の考え方に変更を加えてはなりません。"
    },
    {
      "indent": 0,
      "text": "1.3. Security Services",
      "section_title": true,
      "ja": "1.3. セキュリティサービス"
    },
    {
      "indent": 3,
      "text": "The security services necessary to support the goals of this SNMP Security Model are as follows:",
      "ja": "このSNMPセキュリティモデルの目標をサポートするために必要なセキュリティサービスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- Data Integrity is the provision of the property that data has not been altered or destroyed in an unauthorized manner, nor have data sequences been altered to an extent greater than can occur non-maliciously.",
      "ja": "- データの整合性とは、データが不正に変更または破壊されておらず、データシーケンスが悪意なく発生する可能性のある範囲を超えて変更されていないという特性の規定です。"
    },
    {
      "indent": 3,
      "text": "- Data Origin Authentication is the provision of the property that the claimed identity of the user on whose behalf received data was originated is corroborated.",
      "ja": "- データ発信元認証は、受信したデータの発信者であるユーザーの主張されたIDが裏付けられる特性の規定です。"
    },
    {
      "indent": 3,
      "text": "- Data Confidentiality is the provision of the property that information is not made available or disclosed to unauthorized individuals, entities, or processes.",
      "ja": "- データの機密性は、権限のない個人、エンティティ、またはプロセスに対して情報が利用可能にされたり、開示されたりしないという性質の規定です。"
    },
    {
      "indent": 3,
      "text": "- Message timeliness and limited replay protection is the provision of the property that a message whose generation time is outside of a specified time window is not accepted. Note that message reordering is not dealt with and can occur in normal conditions too.",
      "ja": "- メッセージの適時性と制限された再生保護は、生成時間が指定された時間枠の外にあるメッセージが受け入れられないというプロパティの提供です。メッセージの並べ替えは処理されず、通常の状態でも発生する可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For the protocols specified in this memo, it is not possible to assure the specific originator of a received SNMP message; rather, it is the user on whose behalf the message was originated that is authenticated.",
      "ja": "このメモで指定されたプロトコルの場合、受信したSNMPメッセージの特定の発信者を保証することはできません。むしろ、認証されるのは、メッセージが発信されたユーザーです。"
    },
    {
      "indent": 3,
      "text": "For these protocols, it not possible to obtain data integrity without data origin authentication, nor is it possible to obtain data origin authentication without data integrity. Further, there is no provision for data confidentiality without both data integrity and data origin authentication.",
      "ja": "これらのプロトコルの場合、データの起点認証なしにデータの整合性を取得することはできません。また、データの整合性なしにデータの起点認証を取得することもできません。さらに、データの完全性とデータの発信元の認証の両方がなければ、データの機密性は提供されません。"
    },
    {
      "indent": 3,
      "text": "The security protocols used in this memo are considered acceptably secure at the time of writing. However, the procedures allow for new authentication and privacy methods to be specified at a future time if the need arises.",
      "ja": "このメモで使用されているセキュリティプロトコルは、執筆時点では許容範囲内で安全であると見なされています。ただし、この手順では、必要に応じて、将来、新しい認証とプライバシーの方法を指定できます。"
    },
    {
      "indent": 0,
      "text": "1.4. Module Organization",
      "section_title": true,
      "ja": "1.4. モジュール構成"
    },
    {
      "indent": 3,
      "text": "The security protocols defined in this memo are split in three different modules and each has its specific responsibilities such that together they realize the goals and security services described above:",
      "ja": "このメモで定義されているセキュリティプロトコルは、3つの異なるモジュールに分割されており、それぞれに特定の責任があり、一緒になって上記の目標とセキュリティサービスを実現します。"
    },
    {
      "indent": 3,
      "text": "- The authentication module MUST provide for:",
      "ja": "- 認証モジュールは以下を提供しなければなりません："
    },
    {
      "indent": 5,
      "text": "- Data Integrity,",
      "ja": "- データの整合性、"
    },
    {
      "indent": 5,
      "text": "- Data Origin Authentication,",
      "ja": "- データ発信元認証、"
    },
    {
      "indent": 3,
      "text": "- The timeliness module MUST provide for:",
      "ja": "- 適時性モジュールは以下を提供しなければなりません："
    },
    {
      "indent": 5,
      "text": "- Protection against message delay or replay (to an extent greater than can occur through normal operation).",
      "ja": "- メッセージの遅延または応答に対する保護（通常の操作で発生する可能性がある範囲よりも大きい）。"
    },
    {
      "indent": 3,
      "text": "- The privacy module MUST provide for",
      "ja": "- プライバシーモジュールは、"
    },
    {
      "indent": 5,
      "text": "- Protection against disclosure of the message payload.",
      "ja": "- メッセージペイロードの開示に対する保護。"
    },
    {
      "indent": 3,
      "text": "The timeliness module is fixed for the User-based Security Model while there is provision for multiple authentication and/or privacy modules, each of which implements a specific authentication or privacy protocol respectively.",
      "ja": "適時性モジュールはユーザーベースのセキュリティモデル用に固定されていますが、複数の認証モジュールやプライバシーモジュールが用意されており、それぞれが特定の認証またはプライバシープロトコルを実装しています。"
    },
    {
      "indent": 0,
      "text": "1.4.1. Timeliness Module",
      "section_title": true,
      "ja": "1.4.1. 適時性モジュール"
    },
    {
      "indent": 3,
      "text": "Section 3 (Elements of Procedure) uses the timeliness values in an SNMP message to do timeliness checking. The timeliness check is only performed if authentication is applied to the message. Since the complete message is checked for integrity, we can assume that the timeliness values in a message that passes the authentication module are trustworthy.",
      "ja": "セクション3（手順の要素）では、SNMPメッセージの適時性の値を使用して適時性チェックを行います。適時性チェックは、認証がメッセージに適用されている場合にのみ実行されます。メッセージ全体の整合性がチェックされるため、認証モジュールを通過するメッセージの適時性の値は信頼できると見なすことができます。"
    },
    {
      "indent": 0,
      "text": "1.4.2. Authentication Protocol",
      "section_title": true,
      "ja": "1.4.2. 認証プロトコル"
    },
    {
      "indent": 3,
      "text": "Section 6 describes the HMAC-MD5-96 authentication protocol which is the first authentication protocol that MUST be supported with the User-based Security Model. Section 7 describes the HMAC-SHA-96 authentication protocol which is another authentication protocol that SHOULD be supported with the User-based Security Model. In the future additional or replacement authentication protocols may be defined as new needs arise.",
      "ja": "セクション6では、ユーザーベースのセキュリティモデルでサポートする必要がある最初の認証プロトコルであるHMAC-MD5-96認証プロトコルについて説明します。セクション7では、HMAC-SHA-96認証プロトコルについて説明します。これは、ユーザーベースのセキュリティモデルでサポートされる必要があるもう1つの認証プロトコルです。将来、新しいニーズが発生したときに、追加または代替の認証プロトコルが定義される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model prescribes that, if authentication is used, then the complete message is checked for integrity in the authentication module.",
      "ja": "ユーザーベースのセキュリティモデルでは、認証が使用されている場合、認証モジュールでメッセージ全体の整合性がチェックされることが規定されています。"
    },
    {
      "indent": 3,
      "text": "For a message to be authenticated, it needs to pass authentication check by the authentication module and the timeliness check which is a fixed part of this User-based Security model.",
      "ja": "メッセージが認証されるためには、認証モジュールによる認証チェックと、このユーザーベースのセキュリティモデルの固定部分である適時性チェックに合格する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.4.3. Privacy Protocol",
      "section_title": true,
      "ja": "1.4.3. プライバシープロトコル"
    },
    {
      "indent": 3,
      "text": "Section 8 describes the CBC-DES Symmetric Encryption Protocol which is the first privacy protocol to be used with the User-based Security Model. In the future additional or replacement privacy protocols may be defined as new needs arise.",
      "ja": "セクション8では、ユーザーベースのセキュリティモデルで使用される最初のプライバシープロトコルであるCBC-DES対称暗号化プロトコルについて説明します。将来的には、新しいニーズが発生したときに、プライバシープロトコルの追加または置き換えが定義される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model prescribes that the scopedPDU is protected from disclosure when a message is sent with privacy.",
      "ja": "ユーザーベースのセキュリティモデルでは、メッセージがプライバシーで送信される場合、scopedPDUが開示されないように保護されています。"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model also prescribes that a message needs to be authenticated if privacy is in use.",
      "ja": "ユーザーベースのセキュリティモデルでは、プライバシーが使用されている場合はメッセージを認証する必要があることも規定しています。"
    },
    {
      "indent": 0,
      "text": "1.5. Protection against Message Replay, Delay and Redirection",
      "section_title": true,
      "ja": "1.5. メッセージの再生、遅延、リダイレクトに対する保護"
    },
    {
      "indent": 0,
      "text": "1.5.1. Authoritative SNMP Engine",
      "section_title": true,
      "ja": "1.5.1. 信頼できるSNMPエンジン"
    },
    {
      "indent": 3,
      "text": "In order to protect against message replay, delay and redirection, one of the SNMP engines involved in each communication is designated to be the authoritative SNMP engine. When an SNMP message contains a payload which expects a response (those messages that contain a Confirmed Class PDU [RFC3411]), then the receiver of such messages is authoritative. When an SNMP message contains a payload which does not expect a response (those messages that contain an Unconfirmed Class PDU [RFC3411]), then the sender of such a message is authoritative.",
      "ja": "メッセージの再生、遅延、リダイレクトから保護するために、各通信に関与するSNMPエンジンの1つが信頼できるSNMPエンジンに指定されています。 SNMPメッセージに応答を期待するペイロード（確認済みクラスPDU [RFC3411]を含むメッセージ）が含まれている場合、そのようなメッセージの受信者は信頼できます。 SNMPメッセージに応答を期待しないペイロード（Unconfirmed Class PDU [RFC3411]を含むメッセージ）が含まれている場合、そのようなメッセージの送信者は信頼できます。"
    },
    {
      "indent": 0,
      "text": "1.5.2. Mechanisms",
      "section_title": true,
      "ja": "1.5.2. メカニズム"
    },
    {
      "indent": 3,
      "text": "The following mechanisms are used:",
      "ja": "次のメカニズムが使用されます。"
    },
    {
      "indent": 3,
      "text": "1) To protect against the threat of message delay or replay (to an extent greater than can occur through normal operation), a set of timeliness indicators (for the authoritative SNMP engine) are included in each message generated. An SNMP engine evaluates the timeliness indicators to determine if a received message is recent. An SNMP engine may evaluate the timeliness indicators to ensure that a received message is at least as recent as the last message it received from the same source. A non-authoritative SNMP engine uses received authentic messages to advance its notion of the timeliness indicators at the remote authoritative source.",
      "ja": "1）メッセージの遅延または再生の脅威から保護するため（通常の操作で発生する可能性がある範囲よりも大きい）、生成された各メッセージには、（信頼できるSNMPエンジンの）適時性インジケーターのセットが含まれています。 SNMPエンジンは、適時性インジケータを評価して、受信したメッセージが最近のものかどうかを判断します。 SNMPエンジンは、適時性インジケータを評価して、受信したメッセージが少なくとも同じソースから受信した最後のメッセージと同じくらい新しいことを確認します。権限のないSNMPエンジンは、受信した認証メッセージを使用して、リモートの信頼できるソースでの適時性インジケーターの概念を進めます。"
    },
    {
      "indent": 6,
      "text": "An SNMP engine MUST also use a mechanism to match incoming Responses to outstanding Requests and it MUST drop any Responses that do not match an outstanding request. For example, a msgID can be inserted in every message to cater for this functionality.",
      "ja": "SNMPエンジンは、着信応答を未処理の要求と照合するメカニズムも使用する必要があり、未処理の要求と一致しない応答はすべてドロップする必要があります。たとえば、この機能に対応するために、すべてのメッセージにmsgIDを挿入できます。"
    },
    {
      "indent": 6,
      "text": "These mechanisms provide for the detection of authenticated messages whose time of generation was not recent.",
      "ja": "これらのメカニズムは、生成時刻が最近ではない認証済みメッセージの検出を提供します。"
    },
    {
      "indent": 6,
      "text": "This protection against the threat of message delay or replay does not imply nor provide any protection against unauthorized deletion or suppression of messages. Also, an SNMP engine may not be able to detect message reordering if all the messages involved are sent within the Time Window interval. Other mechanisms defined independently of the security protocol can also be used to detect the re-ordering replay, deletion, or suppression of messages containing Set operations (e.g., the MIB variable snmpSetSerialNo [RFC3418]).",
      "ja": "メッセージの遅延または再生の脅威に対するこの保護は、メッセージの不正な削除または抑制に対する保護を示唆または提供するものではありません。また、関係するすべてのメッセージがタイムウィンドウ間隔内に送信された場合、SNMPエンジンはメッセージの並べ替えを検出できない場合があります。セキュリティプロトコルとは別に定義された他のメカニズムを使用して、Set操作を含むメッセージの並べ替えの再生、削除、抑制を検出することもできます（MIB変数snmpSetSerialNo [RFC3418]など）。"
    },
    {
      "indent": 3,
      "text": "2) Verification that a message sent to/from one authoritative SNMP engine cannot be replayed to/as-if-from another authoritative SNMP engine.",
      "ja": "2）ある信頼できるSNMPエンジンとの間で送受信されたメッセージを、別の信頼できるSNMPエンジンとの間で再生することはできません。"
    },
    {
      "indent": 6,
      "text": "Included in each message is an identifier unique to the authoritative SNMP engine associated with the sender or intended recipient of the message.",
      "ja": "各メッセージには、メッセージの送信者または目的の受信者に関連付けられた信頼できるSNMPエンジンに固有の識別子が含まれています。"
    },
    {
      "indent": 6,
      "text": "A message containing an Unconfirmed Class PDU sent by an authoritative SNMP engine to one non-authoritative SNMP engine can potentially be replayed to another non-authoritative SNMP engine. The latter non-authoritative SNMP engine might (if it knows about the same userName with the same secrets at the authoritative SNMP engine) as a result update its notion of timeliness indicators of the authoritative SNMP engine, but that is not considered a threat. In this case, A Report or Response message will be discarded by the Message Processing Model, because there should not be an outstanding Request message. A Trap will possibly be accepted. Again, that is not considered a threat, because the communication was authenticated and timely. It is as if the authoritative SNMP engine was configured to start sending Traps to the second SNMP engine, which theoretically can happen without the knowledge of the second SNMP engine anyway. Anyway, the second SNMP engine may not expect to receive this Trap, but is allowed to see the management information contained in it.",
      "ja": "権限のあるSNMPエンジンから1つの権限のないSNMPエンジンに送信された未確認のクラスPDUを含むメッセージは、別の権限のないSNMPエンジンに再生される可能性があります。後者の非権威SNMPエンジンは、結果として（権威SNMPエンジンで同じシークレットを持つ同じuserNameを知っている場合）、権威SNMPエンジンの適時性インジケーターの概念を更新する可能性がありますが、これは脅威とは見なされません。この場合、未処理の要求メッセージはないはずなので、レポートまたは応答メッセージはメッセージ処理モデルによって破棄されます。トラップはおそらく受け入れられます。繰り返しになりますが、通信は認証され、タイムリーであるため、脅威とは見なされません。これは、信頼できるSNMPエンジンが2番目のSNMPエンジンへのトラップの送信を開始するように構成されているかのようで、理論的には2番目のSNMPエンジンの知識がなくても発生します。とにかく、2番目のSNMPエンジンはこのトラップを受信することを予期していない可能性がありますが、それに含まれる管理情報を表示することは許可されています。"
    },
    {
      "indent": 3,
      "text": "3) Detection of messages which were not recently generated.",
      "ja": "3）最近生成されていないメッセージの検出。"
    },
    {
      "indent": 6,
      "text": "A set of time indicators are included in the message, indicating the time of generation. Messages without recent time indicators are not considered authentic. In addition, an SNMP engine MUST drop any Responses that do not match an outstanding request. This however is the responsibility of the Message Processing Model.",
      "ja": "メッセージには一連の時間インジケータが含まれ、生成時間を示します。最近の時間インジケータのないメッセージは、本物とは見なされません。さらに、SNMPエンジンは、未解決の要求と一致しない応答をすべてドロップする必要があります。ただし、これはメッセージ処理モデルの責任です。"
    },
    {
      "indent": 3,
      "text": "This memo allows the same user to be defined on multiple SNMP engines. Each SNMP engine maintains a value, snmpEngineID, which uniquely identifies the SNMP engine. This value is included in each message sent to/from the SNMP engine that is authoritative (see section 1.5.1). On receipt of a message, an authoritative SNMP engine checks the value to ensure that it is the intended recipient, and a non-authoritative SNMP engine uses the value to ensure that the message is processed using the correct state information.",
      "ja": "このメモでは、同じユーザーを複数のSNMPエンジンで定義できます。各SNMPエンジンは、SNMPエンジンを一意に識別する値snmpEngineIDを維持します。この値は、信頼できるSNMPエンジンとの間で送受信される各メッセージに含まれています（セクション1.5.1を参照）。メッセージを受信すると、権限のあるSNMPエンジンが値をチェックして、目的の受信者であることを確認します。権限のないSNMPエンジンは、値を使用して、メッセージが正しい状態情報を使用して処理されることを確認します。"
    },
    {
      "indent": 3,
      "text": "Each SNMP engine maintains two values, snmpEngineBoots and snmpEngineTime, which taken together provide an indication of time at that SNMP engine. Both of these values are included in an authenticated message sent to/received from that SNMP engine. On receipt, the values are checked to ensure that the indicated timeliness value is within a Time Window of the current time. The Time Window represents an administrative upper bound on acceptable delivery delay for protocol messages.",
      "ja": "各SNMPエンジンは、snmpEngineBootsとsnmpEngineTimeの2つの値を保持します。これらの値を組み合わせることで、そのSNMPエンジンの時刻を示します。これらの値は両方とも、そのSNMPエンジンとの間で送受信される認証済みメッセージに含まれています。受信すると、値がチェックされ、示された適時性の値が現在の時間のタイムウィンドウ内にあることが確認されます。時間ウィンドウは、プロトコルメッセージの許容可能な配信遅延の管理上の上限を表します。"
    },
    {
      "indent": 3,
      "text": "For an SNMP engine to generate a message which an authoritative SNMP engine will accept as authentic, and to verify that a message received from that authoritative SNMP engine is authentic, such an SNMP engine must first achieve timeliness synchronization with the authoritative SNMP engine. See section 2.3.",
      "ja": "SNMPエンジンが信頼できるSNMPエンジンが本物として受け入れるメッセージを生成し、その信頼できるSNMPエンジンから受信したメッセージが本物であることを確認するには、そのようなSNMPエンジンは、最初に信頼できるSNMPエンジンとの適時な同期を達成する必要があります。セクション2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.6. Abstract Service Interfaces",
      "section_title": true,
      "ja": "1.6. 抽象サービスインターフェイス"
    },
    {
      "indent": 3,
      "text": "Abstract service interfaces have been defined to describe the conceptual interfaces between the various subsystems within an SNMP entity. Similarly a set of abstract service interfaces have been defined within the User-based Security Model (USM) to describe the conceptual interfaces between the generic USM services and the self-contained authentication and privacy services.",
      "ja": "抽象サービスインターフェイスは、SNMPエンティティ内のさまざまなサブシステム間の概念的なインターフェイスを記述するために定義されています。同様に、一連の抽象サービスインターフェースがユーザーベースのセキュリティモデル（USM）内で定義されており、一般的なUSMサービスと自己完結型の認証およびプライバシーサービスの間の概念的なインターフェースを記述しています。"
    },
    {
      "indent": 3,
      "text": "These abstract service interfaces are defined by a set of primitives that define the services provided and the abstract data elements that must be passed when the services are invoked. This section lists the primitives that have been defined for the User-based Security Model.",
      "ja": "これらの抽象サービスインターフェイスは、提供されるサービスを定義する一連のプリミティブと、サービスの呼び出し時に渡す必要がある抽象データ要素によって定義されます。このセクションでは、ユーザーベースのセキュリティモデルに定義されているプリミティブをリストします。"
    },
    {
      "indent": 0,
      "text": "1.6.1. User-based Security Model Primitives for Authentication",
      "section_title": true,
      "ja": "1.6.1. 認証のためのユーザーベースのセキュリティモデルプリミティブ"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model provides the following internal primitives to pass data back and forth between the Security Model itself and the authentication service:",
      "ja": "ユーザーベースのセキュリティモデルは、セキュリティモデル自体と認証サービスの間でデータをやり取りするために、次の内部プリミティブを提供します。"
    },
    {
      "indent": 3,
      "text": "statusInformation = authenticateOutgoingMsg( IN authKey -- secret key for authentication IN wholeMsg -- unauthenticated complete message OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation = authenticateOutgoingMsg（IN authKey-認証用の秘密鍵IN wholeMsg-認証されていない完全なメッセージOUT authenticationWholeMsg-完全に認証されたメッセージ）"
    },
    {
      "indent": 3,
      "text": "statusInformation = authenticateIncomingMsg( IN authKey -- secret key for authentication IN authParameters -- as received on the wire IN wholeMsg -- as received on the wire OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation = authenticateIncomingMsg（IN authKey-認証用の秘密鍵IN authParameters-ワイヤー上で受信されたとおりINholeMsg-ワイヤー上で受信された場合OUT authenticationWholeMsg-完全な認証済みメッセージ）"
    },
    {
      "indent": 0,
      "text": "1.6.2. User-based Security Model Primitives for Privacy",
      "section_title": true,
      "ja": "1.6.2. プライバシーのためのユーザーベースのセキュリティモデルプリミティブ"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model provides the following internal primitives to pass data back and forth between the Security Model itself and the privacy service:",
      "ja": "ユーザーベースのセキュリティモデルは、セキュリティモデル自体とプライバシーサービスの間でデータをやり取りするために、次の内部プリミティブを提供します。"
    },
    {
      "indent": 3,
      "text": "statusInformation = encryptData( IN encryptKey -- secret key for encryption IN dataToEncrypt -- data to encrypt (scopedPDU) OUT encryptedData -- encrypted data (encryptedPDU) OUT privParameters -- filled in by service provider )",
      "ja": "statusInformation = encryptData（IN encryptKey-暗号化の秘密鍵IN dataToEncrypt-暗号化するデータ（scopedPDU）OUT encryptedData-暗号化されたデータ（encryptedPDU）OUT privParameters-サービスプロバイダーが入力）"
    },
    {
      "indent": 3,
      "text": "statusInformation = decryptData( IN decryptKey -- secret key for decrypting IN privParameters -- as received on the wire IN encryptedData -- encrypted data (encryptedPDU) OUT decryptedData -- decrypted data (scopedPDU) )",
      "ja": "statusInformation = DecryptData（IN decodeKey-IN privParametersを復号化するための秘密鍵-回線で受信したとおりIN encryptedData-暗号化されたデータ（encryptedPDU）OUT decryptedData-復号化されたデータ（scopedPDU））"
    },
    {
      "indent": 0,
      "text": "2. Elements of the Model",
      "section_title": true,
      "ja": "2. モデルの要素"
    },
    {
      "indent": 3,
      "text": "This section contains definitions required to realize the security model defined by this memo.",
      "ja": "このセクションには、このメモによって定義されたセキュリティモデルを実現するために必要な定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.1. User-based Security Model Users",
      "section_title": true,
      "ja": "2.1. ユーザーベースのセキュリティモデルユーザー"
    },
    {
      "indent": 3,
      "text": "Management operations using this Security Model make use of a defined set of user identities. For any user on whose behalf management operations are authorized at a particular SNMP engine, that SNMP engine must have knowledge of that user. An SNMP engine that wishes to communicate with another SNMP engine must also have knowledge of a user known to that engine, including knowledge of the applicable attributes of that user.",
      "ja": "このセキュリティモデルを使用した管理操作は、定義されたユーザーIDのセットを利用します。特定のSNMPエンジンで管理操作が許可されているユーザーの場合、そのSNMPエンジンはそのユーザーの知識を持っている必要があります。別のSNMPエンジンと通信するSNMPエンジンは、そのエンジンに認識されているユーザーの知識（そのユーザーに適用可能な属性の知識を含む）も持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "A user and its attributes are defined as follows:",
      "ja": "ユーザーとその属性は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "userName A string representing the name of the user.",
      "ja": "userNameユーザーの名前を表す文字列。"
    },
    {
      "indent": 3,
      "text": "securityName A human-readable string representing the user in a format that is Security Model independent. There is a one-to-one relationship between userName and securityName.",
      "ja": "securityName人間が読める形式の文字列で、セキュリティモデルに依存しない形式でユーザーを表します。 userNameとsecurityNameの間には1対1の関係があります。"
    },
    {
      "indent": 3,
      "text": "authProtocol An indication of whether messages sent on behalf of this user can be authenticated, and if so, the type of authentication protocol which is used. Two such protocols are defined in this memo:",
      "ja": "authProtocolこのユーザーの代わりに送信されたメッセージを認証できるかどうか、および認証できる場合は、使用される認証プロトコルのタイプを示します。このメモでは、そのような2つのプロトコルが定義されています。"
    },
    {
      "indent": 6,
      "text": "- the HMAC-MD5-96 authentication protocol. - the HMAC-SHA-96 authentication protocol.",
      "ja": "- HMAC-MD5-96認証プロトコル。 -HMAC-SHA-96認証プロトコル。"
    },
    {
      "indent": 3,
      "text": "authKey If messages sent on behalf of this user can be authenticated, the (private) authentication key for use with the authentication protocol. Note that a user's authentication key will normally be different at different authoritative SNMP engines. The authKey is not accessible via SNMP. The length requirements of the authKey are defined by the authProtocol in use.",
      "ja": "authKeyこのユーザーの代わりに送信されたメッセージを認証できる場合、認証プロトコルで使用する（プライベート）認証キー。ユーザーの認証キーは通常、権限のあるSNMPエンジンによって異なります。 authKeyはSNMP経由でアクセスできません。 authKeyの長さの要件は、使用中のauthProtocolによって定義されます。"
    },
    {
      "indent": 3,
      "text": "authKeyChange and authOwnKeyChange The only way to remotely update the authentication key. Does that in a secure manner, so that the update can be completed without the need to employ privacy protection.",
      "ja": "authKeyChangeおよびauthOwnKeyChange認証キーをリモートで更新する唯一の方法。安全な方法でそれを行うので、プライバシー保護を採用する必要なく更新を完了できます。"
    },
    {
      "indent": 3,
      "text": "privProtocol An indication of whether messages sent on behalf of this user can be protected from disclosure, and if so, the type of privacy protocol which is used. One such protocol is defined in this memo: the CBC-DES Symmetric Encryption Protocol.",
      "ja": "privProtocolこのユーザーに代わって送信されたメッセージを開示から保護できるかどうか、およびそうである場合は、使用されるプライバシープロトコルのタイプを示します。このメモでは、そのようなプロトコルの1つであるCBC-DES対称暗号化プロトコルが定義されています。"
    },
    {
      "indent": 3,
      "text": "privKey If messages sent on behalf of this user can be en/decrypted, the (private) privacy key for use with the privacy protocol. Note that a user's privacy key will normally be different at different authoritative SNMP engines. The privKey is not accessible via SNMP. The length requirements of the privKey are defined by the privProtocol in use.",
      "ja": "privKeyこのユーザーに代わって送信されたメッセージを暗号化/復号化できる場合、プライバシープロトコルで使用する（プライベート）プライバシーキー。ユーザーのプライバシーキーは通常、権限のあるSNMPエンジンによって異なります。 privKeyはSNMP経由でアクセスできません。 privKeyの長さの要件は、使用中のprivProtocolによって定義されます。"
    },
    {
      "indent": 3,
      "text": "privKeyChange and privOwnKeyChange The only way to remotely update the encryption key. Does that in a secure manner, so that the update can be completed without the need to employ privacy protection.",
      "ja": "privKeyChangeおよびprivOwnKeyChange暗号化キーをリモートで更新する唯一の方法。安全な方法でそれを行うので、プライバシー保護を採用する必要なく更新を完了できます。"
    },
    {
      "indent": 0,
      "text": "2.2. Replay Protection",
      "section_title": true,
      "ja": "2.2. リプレイ保護"
    },
    {
      "indent": 3,
      "text": "Each SNMP engine maintains three objects:",
      "ja": "各SNMPエンジンは3つのオブジェクトを保持します。"
    },
    {
      "indent": 3,
      "text": "- snmpEngineID, which (at least within an administrative domain) uniquely and unambiguously identifies an SNMP engine.",
      "ja": "- snmpEngineID。これは（少なくとも管理ドメイン内で）SNMPエンジンを一意かつ明確に識別します。"
    },
    {
      "indent": 3,
      "text": "- snmpEngineBoots, which is a count of the number of times the SNMP engine has re-booted/re-initialized since snmpEngineID was last configured; and,",
      "ja": "- snmpEngineIDが最後に構成されてから、SNMPエンジンが再起動/再初期化された回数のカウントであるsnmpEngineBoots。そして、"
    },
    {
      "indent": 3,
      "text": "- snmpEngineTime, which is the number of seconds since the snmpEngineBoots counter was last incremented.",
      "ja": "- snmpEngineTimeは、snmpEngineBootsカウンターが最後にインクリメントされてからの秒数です。"
    },
    {
      "indent": 3,
      "text": "Each SNMP engine is always authoritative with respect to these objects in its own SNMP entity. It is the responsibility of a non-authoritative SNMP engine to synchronize with the authoritative SNMP engine, as appropriate.",
      "ja": "各SNMPエンジンは、独自のSNMPエンティティ内のこれらのオブジェクトに関して常に信頼できます。権限のあるSNMPエンジンと適切に同期するのは、権限のないSNMPエンジンの責任です。"
    },
    {
      "indent": 3,
      "text": "An authoritative SNMP engine is required to maintain the values of its snmpEngineID and snmpEngineBoots in non-volatile storage.",
      "ja": "snmpEngineIDおよびsnmpEngineBootsの値を不揮発性ストレージに維持するには、信頼できるSNMPエンジンが必要です。"
    },
    {
      "indent": 0,
      "text": "2.2.1. msgAuthoritativeEngineID",
      "section_title": true,
      "ja": "2.2.1. msgAuthoritativeEngineID"
    },
    {
      "indent": 3,
      "text": "The msgAuthoritativeEngineID value contained in an authenticated message is used to defeat attacks in which messages from one SNMP engine to another SNMP engine are replayed to a different SNMP engine. It represents the snmpEngineID at the authoritative SNMP engine involved in the exchange of the message.",
      "ja": "認証されたメッセージに含まれるmsgAuthoritativeEngineID値は、あるSNMPエンジンから別のSNMPエンジンへのメッセージが別のSNMPエンジンに再生される攻撃を阻止するために使用されます。これは、メッセージの交換に関与する信頼できるSNMPエンジンのsnmpEngineIDを表します。"
    },
    {
      "indent": 3,
      "text": "When an authoritative SNMP engine is first installed, it sets its local value of snmpEngineID according to a enterprise-specific algorithm (see the definition of the Textual Convention for SnmpEngineID in the SNMP Architecture document [RFC3411]).",
      "ja": "信頼できるSNMPエンジンが最初にインストールされると、エンタープライズ固有のアルゴリズムに従ってsnmpEngineIDのローカル値が設定されます（SNMPアーキテクチャドキュメント[RFC3411]のSnmpEngineIDのテキスト表記の定義を参照してください）。"
    },
    {
      "indent": 0,
      "text": "2.2.2. msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime",
      "section_title": true,
      "ja": "2.2.2. msgAuthoritativeEngineBootsおよびmsgAuthoritativeEngineTime"
    },
    {
      "indent": 3,
      "text": "The msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime values contained in an authenticated message are used to defeat attacks in which messages are replayed when they are no longer valid. They represent the snmpEngineBoots and snmpEngineTime values at the authoritative SNMP engine involved in the exchange of the message.",
      "ja": "認証されたメッセージに含まれるmsgAuthoritativeEngineBootsとmsgAuthoritativeEngineTimeの値は、メッセージが無効になったときにメッセージが再生される攻撃を無効にするために使用されます。これらは、メッセージの交換に関与する信頼できるSNMPエンジンでのsnmpEngineBootsおよびsnmpEngineTime値を表します。"
    },
    {
      "indent": 3,
      "text": "Through use of snmpEngineBoots and snmpEngineTime, there is no requirement for an SNMP engine to have a non-volatile clock which ticks (i.e., increases with the passage of time) even when the SNMP engine is powered off. Rather, each time an SNMP engine re-boots, it retrieves, increments, and then stores snmpEngineBoots in non-volatile storage, and resets snmpEngineTime to zero.",
      "ja": "snmpEngineBootsとsnmpEngineTimeを使用することにより、SNMPエンジンの電源がオフの場合でも、SNMPエンジンが刻々と変化する（つまり、時間の経過とともに増加する）不揮発性クロックを使用する必要はありません。むしろ、SNMPエンジンが再起動するたびに、snmpEngineBootsを取得してインクリメントし、不揮発性ストレージに格納して、snmpEngineTimeをゼロにリセットします。"
    },
    {
      "indent": 3,
      "text": "When an SNMP engine is first installed, it sets its local values of snmpEngineBoots and snmpEngineTime to zero. If snmpEngineTime ever reaches its maximum value (2147483647), then snmpEngineBoots is incremented as if the SNMP engine has re-booted and snmpEngineTime is reset to zero and starts incrementing again.",
      "ja": "SNMPエンジンが最初にインストールされると、snmpEngineBootsおよびsnmpEngineTimeのローカル値がゼロに設定されます。 snmpEngineTimeが最大値（2147483647）に達すると、snmpEngineBootsは、SNMPエンジンが再起動されたかのようにインクリメントされ、snmpEngineTimeはゼロにリセットされて、再度インクリメントを開始します。"
    },
    {
      "indent": 3,
      "text": "Each time an authoritative SNMP engine re-boots, any SNMP engines holding that authoritative SNMP engine's values of snmpEngineBoots and snmpEngineTime need to re-synchronize prior to sending correctly authenticated messages to that authoritative SNMP engine (see Section 2.3 for (re-)synchronization procedures). Note, however, that the procedures do provide for a notification to be accepted as authentic by a receiving SNMP engine, when sent by an authoritative SNMP engine which has re-booted since the receiving SNMP engine last (re-)synchronized.",
      "ja": "信頼できるSNMPエンジンが再起動するたびに、その信頼できるSNMPエンジンのsnmpEngineBootsとsnmpEngineTimeの値を保持するすべてのSNMPエンジンは、正しく認証されたメッセージをその信頼できるSNMPエンジンに送信する前に再同期する必要があります（（再）同期手順については、セクション2.3を参照してください） ）。ただし、この手順では、受信側のSNMPエンジンが最後に（再）同期してから再起動した信頼できるSNMPエンジンによって送信された場合に、受信側のSNMPエンジンによって認証済みとして通知が受け入れられることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If an authoritative SNMP engine is ever unable to determine its latest snmpEngineBoots value, then it must set its snmpEngineBoots value to 2147483647.",
      "ja": "信頼できるSNMPエンジンが最新のsnmpEngineBoots値を判別できない場合は、snmpEngineBoots値を2147483647に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Whenever the local value of snmpEngineBoots has the value 2147483647 it latches at that value and an authenticated message always causes an notInTimeWindow authentication failure.",
      "ja": "snmpEngineBootsのローカル値の値が2147483647である場合は常に、その値でラッチされ、認証されたメッセージは常にnotInTimeWindow認証の失敗を引き起こします。"
    },
    {
      "indent": 3,
      "text": "In order to reset an SNMP engine whose snmpEngineBoots value has reached the value 2147483647, manual intervention is required. The engine must be physically visited and re-configured, either with a new snmpEngineID value, or with new secret values for the authentication and privacy protocols of all users known to that SNMP engine. Note that even if an SNMP engine re-boots once a second that it would still take approximately 68 years before the max value of 2147483647 would be reached.",
      "ja": "snmpEngineBoots値が値2147483647に達したSNMPエンジンをリセットするには、手動による介入が必要です。新しいsnmpEngineID値、またはそのSNMPエンジンが認識しているすべてのユーザーの認証およびプライバシープロトコルの新しいシークレット値を使用して、エンジンを物理的に訪問して再構成する必要があります。 SNMPエンジンが1秒に1回再起動しても、最大値の2147483647に達するまでに約68年かかることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Time Window",
      "section_title": true,
      "ja": "2.2.3. 時間枠"
    },
    {
      "indent": 3,
      "text": "The Time Window is a value that specifies the window of time in which a message generated on behalf of any user is valid. This memo specifies that the same value of the Time Window, 150 seconds, is used for all users.",
      "ja": "Time Windowは、ユーザーに代わって生成されたメッセージが有効である時間枠を指定する値です。このメモは、タイムウィンドウの同じ値である150秒がすべてのユーザーに使用されることを指定しています。"
    },
    {
      "indent": 0,
      "text": "2.3. Time Synchronization",
      "section_title": true,
      "ja": "2.3. 時間同期"
    },
    {
      "indent": 3,
      "text": "Time synchronization, required by a non-authoritative SNMP engine in order to proceed with authentic communications, has occurred when the non-authoritative SNMP engine has obtained a local notion of the authoritative SNMP engine's values of snmpEngineBoots and snmpEngineTime from the authoritative SNMP engine. These values must be (and remain) within the authoritative SNMP engine's Time Window. So the local notion of the authoritative SNMP engine's values must be kept loosely synchronized with the values stored at the authoritative SNMP engine. In addition to keeping a local copy of snmpEngineBoots and snmpEngineTime from the authoritative SNMP engine, a non-authoritative SNMP engine must also keep one local variable, latestReceivedEngineTime. This value records the highest value of snmpEngineTime that was received by the non-authoritative SNMP engine from the authoritative SNMP engine and is used to eliminate the possibility of replaying messages that would prevent the non-authoritative SNMP engine's notion of the snmpEngineTime from advancing.",
      "ja": "信頼できないSNMPエンジンが信頼できるSNMPエンジンからsnmpEngineBootsとsnmpEngineTimeの信頼できるSNMPエンジンの値のローカルの概念を信頼できるSNMPエンジンから取得したときに、信頼できないSNMPエンジンが必要とする時刻同期が発生しました。これらの値は、信頼できるSNMPエンジンのタイムウィンドウ内にある必要があります（そしてそのままです）。したがって、信頼できるSNMPエンジンの値のローカルな概念は、信頼できるSNMPエンジンに格納されている値と緩やかに同期させておく必要があります。権限のあるSNMPエンジンからのsnmpEngineBootsおよびsnmpEngineTimeのローカルコピーを保持することに加えて、権限のないSNMPエンジンは、1つのローカル変数latestReceivedEngineTimeも保持する必要があります。この値は、権限のないSNMPエンジンが権限のあるSNMPエンジンから受信したsnmpEngineTimeの最高値を記録し、権限のないSNMPエンジンによるsnmpEngineTimeの概念の進行を妨げるメッセージを再生する可能性を排除するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A non-authoritative SNMP engine must keep local notions of these values (snmpEngineBoots, snmpEngineTime and latestReceivedEngineTime) for each authoritative SNMP engine with which it wishes to communicate. Since each authoritative SNMP engine is uniquely and unambiguously identified by its value of snmpEngineID, the non-authoritative SNMP engine may use this value as a key in order to cache its local notions of these values.",
      "ja": "権限のないSNMPエンジンは、通信する権限のあるSNMPエンジンごとに、これらの値（snmpEngineBoots、snmpEngineTime、latestReceivedEngineTime）のローカルの概念を維持する必要があります。信頼できる各SNMPエンジンは、snmpEngineIDの値によって一意かつ明確に識別されるため、信頼できないSNMPエンジンは、これらの値のローカルの概念をキャッシュするために、この値をキーとして使用できます。"
    },
    {
      "indent": 3,
      "text": "Time synchronization occurs as part of the procedures of receiving an SNMP message (Section 3.2, step 7b). As such, no explicit time synchronization procedure is required by a non-authoritative SNMP engine. Note, that whenever the local value of snmpEngineID is changed (e.g., through discovery) or when secure communications are first established with an authoritative SNMP engine, the local values of snmpEngineBoots and latestReceivedEngineTime should be set to zero. This will cause the time synchronization to occur when the next authentic message is received.",
      "ja": "時間同期は、SNMPメッセージを受信する手順の一部として発生します（セクション3.2、ステップ7b）。そのため、権限のないSNMPエンジンでは、明示的な時刻同期手順は必要ありません。 snmpEngineIDのローカル値が変更されたとき（たとえば、検出によって）、または信頼できるSNMPエンジンと最初に安全な通信が確立されたときは常に、snmpEngineBootsおよびlatestReceivedEngineTimeのローカル値をゼロに設定する必要があります。これにより、次の認証メッセージが受信されたときに時刻同期が発生します。"
    },
    {
      "indent": 0,
      "text": "2.4. SNMP Messages Using this Security Model",
      "section_title": true,
      "ja": "2.4. このセキュリティモデルを使用したSNMPメッセージ"
    },
    {
      "indent": 3,
      "text": "The syntax of an SNMP message using this Security Model adheres to the message format defined in the version-specific Message Processing Model document (for example [RFC3412]).",
      "ja": "このセキュリティモデルを使用するSNMPメッセージの構文は、バージョン固有のメッセージ処理モデルドキュメント（たとえば[RFC3412]）で定義されているメッセージ形式に準拠しています。"
    },
    {
      "indent": 3,
      "text": "The field msgSecurityParameters in SNMPv3 messages has a data type of OCTET STRING. Its value is the BER serialization of the following ASN.1 sequence:",
      "ja": "SNMPv3メッセージのフィールドmsgSecurityParametersのデータタイプはOCTET STRINGです。その値は、次のASN.1シーケンスのBERシリアル化です。"
    },
    {
      "indent": 3,
      "text": "USMSecurityParametersSyntax DEFINITIONS IMPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "UsmSecurityParameters ::=\n    SEQUENCE {\n     -- global User-based security parameters\n        msgAuthoritativeEngineID     OCTET STRING,\n        msgAuthoritativeEngineBoots  INTEGER (0..2147483647),\n        msgAuthoritativeEngineTime   INTEGER (0..2147483647),\n        msgUserName                  OCTET STRING (SIZE(0..32)),\n     -- authentication protocol specific parameters\n        msgAuthenticationParameters  OCTET STRING,\n     -- privacy protocol specific parameters\n        msgPrivacyParameters         OCTET STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " } END",
      "ja": "} 終わり"
    },
    {
      "indent": 3,
      "text": "The fields of this sequence are:",
      "ja": "このシーケンスのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- The msgAuthoritativeEngineID specifies the snmpEngineID of the authoritative SNMP engine involved in the exchange of the message.",
      "ja": "- msgAuthoritativeEngineIDは、メッセージの交換に関与する信頼できるSNMPエンジンのsnmpEngineIDを指定します。"
    },
    {
      "indent": 3,
      "text": "- The msgAuthoritativeEngineBoots specifies the snmpEngineBoots value at the authoritative SNMP engine involved in the exchange of the message.",
      "ja": "- msgAuthoritativeEngineBootsは、メッセージの交換に関与する信頼できるSNMPエンジンでのsnmpEngineBoots値を指定します。"
    },
    {
      "indent": 3,
      "text": "- The msgAuthoritativeEngineTime specifies the snmpEngineTime value at the authoritative SNMP engine involved in the exchange of the message.",
      "ja": "- msgAuthoritativeEngineTimeは、メッセージの交換に関与する信頼できるSNMPエンジンでのsnmpEngineTime値を指定します。"
    },
    {
      "indent": 3,
      "text": "- The msgUserName specifies the user (principal) on whose behalf the message is being exchanged. Note that a zero-length userName will not match any user, but it can be used for snmpEngineID discovery.",
      "ja": "- msgUserNameは、メッセージが交換されるユーザー（プリンシパル）を指定します。長さがゼロのuserNameはどのユーザーとも一致しませんが、snmpEngineIDの検出に使用できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "- The msgAuthenticationParameters are defined by the authentication protocol in use for the message, as defined by the usmUserAuthProtocol column in the user's entry in the usmUserTable.",
      "ja": "- msgAuthenticationParametersは、メッセージに使用されている認証プロトコルによって定義されます。これは、usmUserTableのユーザーのエントリのusmUserAuthProtocol列で定義されています。"
    },
    {
      "indent": 3,
      "text": "- The msgPrivacyParameters are defined by the privacy protocol in use for the message, as defined by the usmUserPrivProtocol column in the user's entry in the usmUserTable).",
      "ja": "- msgPrivacyParametersは、メッセージに使用されているプラ​​イバシープロトコルによって定義されます。これは、usmUserTableのユーザーのエントリにあるusmUserPrivProtocol列で定義されています。"
    },
    {
      "indent": 3,
      "text": "See appendix A.4 for an example of the BER encoding of field msgSecurityParameters.",
      "ja": "フィールドmsgSecurityParametersのBERエンコードの例については、付録A.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.5. Services provided by the User-based Security Model",
      "section_title": true,
      "ja": "2.5. ユーザーベースのセキュリティモデルによって提供されるサービス"
    },
    {
      "indent": 3,
      "text": "This section describes the services provided by the User-based Security Model with their inputs and outputs.",
      "ja": "このセクションでは、ユーザーベースのセキュリティモデルによって提供されるサービスとその入力および出力について説明します。"
    },
    {
      "indent": 3,
      "text": "The services are described as primitives of an abstract service interface and the inputs and outputs are described as abstract data elements as they are passed in these abstract service primitives.",
      "ja": "サービスは抽象サービスインターフェイスのプリミティブとして記述され、入力と出力はこれらの抽象サービスプリミティブで渡されるため、抽象データ要素として記述されます。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Services for Generating an Outgoing SNMP Message",
      "section_title": true,
      "ja": "2.5.1. 発信SNMPメッセージを生成するためのサービス"
    },
    {
      "indent": 3,
      "text": "When the Message Processing (MP) Subsystem invokes the User-based Security module to secure an outgoing SNMP message, it must use the appropriate service as provided by the Security module. These two services are provided: 1) A service to generate a Request message. The abstract service primitive is:",
      "ja": "メッセージ処理（MP）サブシステムがユーザーベースのセキュリティモジュールを呼び出して発信SNMPメッセージを保護する場合、セキュリティモジュールが提供する適切なサービスを使用する必要があります。これらの2つのサービスが提供されます。1）要求メッセージを生成するサービス。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "statusInformation = -- success or errorIndication generateRequestMsg( IN messageProcessingModel -- typically, SNMP version IN globalData -- message header, admin data IN maxMessageSize -- of the sending SNMP entity IN securityModel -- for the outgoing message IN securityEngineID -- authoritative SNMP entity IN securityName -- on behalf of this principal IN securityLevel -- Level of Security requested IN scopedPDU -- message (plaintext) payload OUT securityParameters -- filled in by Security Module OUT wholeMsg -- complete generated message OUT wholeMsgLength -- length of generated message )",
      "ja": "statusInformation =-成功またはerrorIndication generateRequestMsg（IN messageProcessingModel-通常、SNMPバージョンIN globalData-メッセージヘッダー、管理データIN maxMessageSize-送信SNMPエンティティのIN securityModel-送信メッセージのIN securityEngineID-信頼できるSNMPエンティティIN securityName-このプリンシパルに代わってIN securityLevel-要求されたセキュリティのレベルIN scopedPDU-メッセージ（プレーンテキスト）ペイロードOUT securityParameters-セキュリティモジュールによって書き込まれますOUT wholeMsg-生成されたメッセージの全体OUT wholeMsgLength-生成されるメッセージの長さ）"
    },
    {
      "indent": 3,
      "text": "2) A service to generate a Response message. The abstract service primitive is:",
      "ja": "2）応答メッセージを生成するサービス。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "statusInformation = -- success or errorIndication generateResponseMsg( IN messageProcessingModel -- typically, SNMP version IN globalData -- message header, admin data IN maxMessageSize -- of the sending SNMP entity IN securityModel -- for the outgoing message IN securityEngineID -- authoritative SNMP entity IN securityName -- on behalf of this principal IN securityLevel -- Level of Security requested IN scopedPDU -- message (plaintext) payload IN securityStateReference -- reference to security state -- information from original -- request OUT securityParameters -- filled in by Security Module OUT wholeMsg -- complete generated message OUT wholeMsgLength -- length of generated message )",
      "ja": "statusInformation =-成功またはerrorIndication generateResponseMsg（IN messageProcessingModel-通常、SNMPバージョンIN globalData-メッセージヘッダー、管理データIN maxMessageSize-送信SNMPエンティティのIN securityModel-送信メッセージのIN securityEngineID-信頼できるSNMPエンティティIN securityName-このプリンシパルに代わってIN securityLevel-要求されたセキュリティのレベルIN scopedPDU-メッセージ（プレーンテキスト）ペイロードIN securityStateReference-セキュリティ状態への参照-オリジナルからの情報-要求OUT securityParameters-Securityによって入力モジュールOUT wholeMsg-生成されたメッセージの完全なOUT wholeMsgLength-生成されたメッセージの長さ）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements passed as parameters in the abstract service primitives are as follows:",
      "ja": "抽象サービスプリミティブのパラメーターとして渡される抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the encoding and securing of the message was successful. If not it is an indication of the problem.",
      "ja": "statusInformationメッセージのエンコードと保護が成功したかどうかを示します。そうでない場合は、問題の兆候です。"
    },
    {
      "indent": 3,
      "text": "messageProcessingModel The SNMP version number for the message to be generated. This data is not used by the User-based Security module.",
      "ja": "messageProcessingModel生成されるメッセージのSNMPバージョン番号。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "globalData The message header (i.e., its administrative information). This data is not used by the User-based Security module.",
      "ja": "globalDataメッセージヘッダー（管理情報など）。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "maxMessageSize The maximum message size as included in the message. This data is not used by the User-based Security module.",
      "ja": "maxMessageSizeメッセージに含まれる最大メッセージサイズ。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "securityParameters These are the security parameters. They will be filled in by the User-based Security module.",
      "ja": "securityParametersこれらはセキュリティパラメータです。これらは、ユーザーベースのセキュリティモジュールによって入力されます。"
    },
    {
      "indent": 3,
      "text": "securityModel The securityModel in use. Should be User-based Security Model. This data is not used by the User-based Security module.",
      "ja": "securityModel使用中のsecurityModel。ユーザーベースのセキュリティモデルである必要があります。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "securityName Together with the snmpEngineID it identifies a row in the usmUserTablethat is to be used for securing the message. The securityName has a format that is independent of the Security Model. In case of a response this parameter is ignored and the value from the cache is used.",
      "ja": "securityName snmpEngineIDとともに、メッセージの保護に使用されるusmUserTableの行を識別します。 securityNameの形式は、セキュリティモデルから独立しています。応答の場合、このパラメーターは無視され、キャッシュからの値が使用されます。"
    },
    {
      "indent": 3,
      "text": "securityLevel The Level of Security from which the User-based Security module determines if the message needs to be protected from disclosure and if the message needs to be authenticated.",
      "ja": "securityLevelユーザーベースのセキュリティモジュールがメッセージを開示から保護する必要があるかどうか、およびメッセージを認証する必要があるかどうかを決定するセキュリティのレベル。"
    },
    {
      "indent": 3,
      "text": "securityEngineID The snmpEngineID of the authoritative SNMP engine to which a dateRequest message is to be sent. In case of a response it is implied to be the processing SNMP engine's snmpEngineID and so if it is specified, then it is ignored.",
      "ja": "securityEngineID dateRequestメッセージの送信先となる信頼できるSNMPエンジンのsnmpEngineID。応答の場合、それは処理中のSNMPエンジンのsnmpEngineIDであることが暗黙に示されているため、指定されても無視されます。"
    },
    {
      "indent": 3,
      "text": "scopedPDU The message payload. The data is opaque as far as the User-based Security Model is concerned.",
      "ja": "scopedPDUメッセージのペイロード。ユーザーベースのセキュリティモデルに関する限り、データは不透明です。"
    },
    {
      "indent": 3,
      "text": "securityStateReference A handle/reference to cachedSecurityData to be used when securing an outgoing Response message. This is the exact same handle/reference as it was generated by the User-based Security module when processing the incoming Request message to which this is the Response message.",
      "ja": "securityStateReference発信応答メッセージを保護するときに使用されるcachedSecurityDataへのハンドル/参照。これは、これが応答メッセージである着信要求メッセージを処理するときにユーザーベースのセキュリティモジュールによって生成されたものとまったく同じハンドル/参照です。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The fully encoded and secured message ready for sending on the wire.",
      "ja": "wholeMsgネットワーク上で送信する準備ができている完全にエンコードされ、保護されたメッセージ。"
    },
    {
      "indent": 3,
      "text": "wholeMsgLength The length of the encoded and secured message (wholeMsg).",
      "ja": "wholeMsgLengthエンコードおよび保護されたメッセージ（wholeMsg）の長さ。"
    },
    {
      "indent": 3,
      "text": "Upon completion of the process, the User-based Security module returns statusInformation. If the process was successful, the completed message with privacy and authentication applied if such was requested by the specified securityLevel is returned. If the process was not successful, then an errorIndication is returned.",
      "ja": "プロセスが完了すると、ユーザーベースのセキュリティモジュールはstatusInformationを返します。プロセスが成功した場合、指定されたsecurityLevelによって要求された場合にプライバシーと認証が適用された、完了したメッセージが返されます。プロセスが成功しなかった場合は、errorIndicationが返されます。"
    },
    {
      "indent": 0,
      "text": "2.5.2. Services for Processing an Incoming SNMP Message",
      "section_title": true,
      "ja": "2.5.2. 着信SNMPメッセージを処理するためのサービス"
    },
    {
      "indent": 3,
      "text": "When the Message Processing (MP) Subsystem invokes the User-based Security module to verify proper security of an incoming message, it must use the service provided for an incoming message. The abstract service primitive is:",
      "ja": "メッセージ処理（MP）サブシステムがユーザーベースのセキュリティモジュールを呼び出して、着信メッセージの適切なセキュリティを確認する場合、着信メッセージ用に提供されているサービスを使用する必要があります。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation =             -- errorIndication or success\n                                -- error counter OID/value if error\n  processIncomingMsg(\n  IN   messageProcessingModel   -- typically, SNMP version\n  IN   maxMessageSize           -- of the sending SNMP entity\n  IN   securityParameters       -- for the received message\n  IN   securityModel            -- for the received message\n  IN   securityLevel            -- Level of Security\n  IN   wholeMsg                 -- as received on the wire\n  IN   wholeMsgLength           -- length as received on the wire\n  OUT  securityEngineID         -- authoritative SNMP entity\n  OUT  securityName             -- identification of the principal\n  OUT  scopedPDU,               -- message (plaintext) payload\n  OUT  maxSizeResponseScopedPDU -- maximum size of the Response PDU\n  OUT  securityStateReference   -- reference to security state\n       )                        -- information, needed for response",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The abstract data elements passed as parameters in the abstract service primitives are as follows:",
      "ja": "抽象サービスプリミティブのパラメーターとして渡される抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the process was successful or not. If not, then the statusInformation includes the OID and the value of the error counter that was incremented.",
      "ja": "statusInformationプロセスが成功したかどうかを示します。そうでない場合、statusInformationにはOIDおよびインクリメントされたエラーカウンタの値が含まれます。"
    },
    {
      "indent": 3,
      "text": "messageProcessingModel The SNMP version number as received in the message. This data is not used by the User-based Security module.",
      "ja": "messageProcessingModelメッセージで受信されたSNMPバージョン番号。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "maxMessageSize The maximum message size as included in the message. The User-bas User-based Security module uses this value to calculate the maxSizeResponseScopedPDU.",
      "ja": "maxMessageSizeメッセージに含まれる最大メッセージサイズ。ユーザーベースのユーザーベースのセキュリティモジュールは、この値を使用してmaxSizeResponseScopedPDUを計算します。"
    },
    {
      "indent": 3,
      "text": "securityParameters These are the security parameters as received in the message.",
      "ja": "securityParametersこれらは、メッセージで受信されたセキュリティパラメータです。"
    },
    {
      "indent": 3,
      "text": "securityModel The securityModel in use. Should be the User-based Security Model. This data is not used by the User-based Security module.",
      "ja": "securityModel使用中のsecurityModel。ユーザーベースのセキュリティモデルである必要があります。このデータは、ユーザーベースのセキュリティモジュールでは使用されません。"
    },
    {
      "indent": 3,
      "text": "securityLevel The Level of Security from which the User-based Security module determines if the message needs to be protected from disclosure and if the message needs to be authenticated.",
      "ja": "securityLevelユーザーベースのセキュリティモジュールがメッセージを開示から保護する必要があるかどうか、およびメッセージを認証する必要があるかどうかを決定するセキュリティのレベル。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The whole message as it was received.",
      "ja": "wholeMsg受信したメッセージ全体。"
    },
    {
      "indent": 3,
      "text": "wholeMsgLength The length of the message as it was received (wholeMsg).",
      "ja": "wholeMsgLength受信時のメッセージの長さ（wholeMsg）。"
    },
    {
      "indent": 3,
      "text": "securityEngineID The snmpEngineID that was extracted from the field msgAuthoritativeEngineID and that was used to lookup the secrets in the usmUserTable.",
      "ja": "securityEngineID msgAuthoritativeEngineIDフィールドから抽出され、usmUserTableのシークレットを検索するために使用されたsnmpEngineID。"
    },
    {
      "indent": 3,
      "text": "securityName The security name representing the user on whose behalf the message was received. The securityName has a format that is independent of the Security Model.",
      "ja": "securityNameメッセージを受信したユーザーのセキュリティ名。 securityNameの形式は、セキュリティモデルから独立しています。"
    },
    {
      "indent": 3,
      "text": "scopedPDU The message payload. The data is opaque as far as the User-based Security Model is concerned.",
      "ja": "scopedPDUメッセージのペイロード。ユーザーベースのセキュリティモデルに関する限り、データは不透明です。"
    },
    {
      "indent": 3,
      "text": "maxSizeResponseScopedPDU The maximum size of a scopedPDU to be included in a possible Response message. The User-based Security module calculates this size based on the msgMaxSize (as received in the message) and the space required for the message header (including the securityParameters) for such a Response message.",
      "ja": "maxSizeResponseScopedPDU可能な応答メッセージに含まれるscopedPDUの最大サイズ。ユーザーベースのセキュリティモジュールは、このサイズを、メッセージで受信したmsgMaxSizeと、そのような応答メッセージのメッセージヘッダー（securityParametersを含む）に必要なスペースに基づいて計算します。"
    },
    {
      "indent": 3,
      "text": "securityStateReference A handle/reference to cachedSecurityData to be used when securing an outgoing Response message. When the Message Processing Subsystem calls the User-based Security module to generate a response to this incoming message it must pass this handle/reference.",
      "ja": "securityStateReference発信応答メッセージを保護するときに使用されるcachedSecurityDataへのハンドル/参照。メッセージ処理サブシステムがユーザーベースのセキュリティモジュールを呼び出してこの着信メッセージへの応答を生成する場合、このハンドル/参照を渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon completion of the process, the User-based Security module returns statusInformation and, if the process was successful, the additional data elements for further processing of the message. If the process was not successful, then an errorIndication, possibly with a OID and value pair of an error counter that was incremented.",
      "ja": "プロセスが完了すると、ユーザーベースのセキュリティモジュールはstatusInformationを返し、プロセスが成功した場合は、メッセージをさらに処理するための追加のデータ要素を返します。プロセスが成功しなかった場合、errorIndication、おそらくインクリメントされたエラーカウンターのOIDと値のペア。"
    },
    {
      "indent": 0,
      "text": "2.6. Key Localization Algorithm.",
      "ja": "2.6. キーローカリゼーションアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "A localized key is a secret key shared between a user U and one authoritative SNMP engine E. Even though a user may have only one password and therefore one key for the whole network, the actual secrets shared between the user and each authoritative SNMP engine will be different. This is achieved by key localization [Localized-key].",
      "ja": "ローカライズされたキーは、ユーザーUと1つの信頼できるSNMPエンジンEの間で共有される秘密キーです。ユーザーは1つのパスワードしか持たないため、ネットワーク全体で1つのキーを使用できますが、ユーザーと各信頼できるSNMPエンジンの間で共有される実際の秘密は異なる。これは、キーのローカリゼーション[Localized-key]によって実現されます。"
    },
    {
      "indent": 3,
      "text": "First, if a user uses a password, then the user's password is converted into a key Ku using one of the two algorithms described in Appendices A.2.1 and A.2.2.",
      "ja": "まず、ユーザーがパスワードを使用する場合、ユーザーのパスワードは、付録A.2.1とA.2.2で説明されている2つのアルゴリズムのいずれかを使用してキーKuに変換されます。"
    },
    {
      "indent": 3,
      "text": "To convert key Ku into a localized key Kul of user U at the authoritative SNMP engine E, one appends the snmpEngineID of the authoritative SNMP engine to the key Ku and then appends the key Ku to the result, thus enveloping the snmpEngineID within the two copies of user's key Ku. Then one runs a secure hash function (which one depends on the authentication protocol defined for this user U at authoritative SNMP engine E; this document defines two authentication protocols with their associated algorithms based on MD5 and SHA). The output of the hash-function is the localized key Kul for user U at the authoritative SNMP engine E.",
      "ja": "権限のあるSNMPエンジンEでキーUをユーザーUのローカライズされたキーKulに変換するには、権限のあるSNMPエンジンのsnmpEngineIDをキーKuに追加し、結果にキーKuを追加して、2つのコピー内でsnmpEngineIDを囲みます。ユーザーのキーKuの。次に、安全なハッシュ関数を実行します（これは、信頼できるSNMPエンジンEでこのユーザーUに対して定義された認証プロトコルに依存します。このドキュメントでは、MD5とSHAに基づく関連アルゴリズムを使用して2つの認証プロトコルを定義します）。ハッシュ関数の出力は、信頼できるSNMPエンジンEのユーザーUのローカライズされたキーKulです。"
    },
    {
      "indent": 0,
      "text": "3. Elements of Procedure",
      "section_title": true,
      "ja": "3. 手順の要素"
    },
    {
      "indent": 3,
      "text": "This section describes the security related procedures followed by an SNMP engine when processing SNMP messages according to the User-based Security Model.",
      "ja": "このセクションでは、ユーザーベースのセキュリティモデルに従ってSNMPメッセージを処理するときにSNMPエンジンが実行するセキュリティ関連の手順について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Generating an Outgoing SNMP Message",
      "section_title": true,
      "ja": "3.1. 発信SNMPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it generates a message containing a management operation (like a request, a response, a notification, or a report) on behalf of a user, with a particular securityLevel.",
      "ja": "このセクションでは、特定のsecurityLevelを持つユーザーに代わって管理操作（要求、応答、通知、レポートなど）を含むメッセージを生成するときに、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) a) If any securityStateReference is passed (Response or Report message), then information concerning the user is extracted from the cachedSecurityData. The cachedSecurityData can now be discarded. The securityEngineID is set to the local snmpEngineID. The securityLevel is set to the value specified by the calling module.",
      "ja": "1）a）securityStateReferenceが渡された場合（応答またはレポートメッセージ）、ユーザーに関する情報がcachedSecurityDataから抽出されます。 cachedSecurityDataを破棄できるようになりました。 securityEngineIDはローカルのsnmpEngineIDに設定されます。 securityLevelは、呼び出しモジュールによって指定された値に設定されます。"
    },
    {
      "indent": 9,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 6,
      "text": "b) based on the securityName, information concerning the user at the destination snmpEngineID, specified by the securityEngineID, is extracted from the Local Configuration Datastore (LCD, usmUserTable). If information about the user is absent from the LCD, then an error indication (unknownSecurityName) is returned to the calling module.",
      "ja": "b) securityNameに基づいて、securityEngineIDで指定された宛先snmpEngineIDのユーザーに関する情報がローカル構成データストア（LCD、usmUserTable）から抽出されます。ユーザーに関する情報がLCDにない場合は、エラー表示（unknownSecurityName）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "2) If the securityLevel specifies that the message is to be protected from disclosure, but the user does not support both an authentication and a privacy protocol then the message cannot be sent. An error indication (unsupportedSecurityLevel) is returned to the calling module.",
      "ja": "2）securityLevelでメッセージを開示から保護するように指定されているが、ユーザーが認証プロトコルとプライバシープロトコルの両方をサポートしていない場合、メッセージを送信できません。エラー表示（unsupportedSecurityLevel）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "3) If the securityLevel specifies that the message is to be authenticated, but the user does not support an authentication protocol, then the message cannot be sent. An error indication (unsupportedSecurityLevel) is returned to the calling module.",
      "ja": "3）securityLevelでメッセージの認証が指定されているが、ユーザーが認証プロトコルをサポートしていない場合、メッセージを送信できません。エラー表示（unsupportedSecurityLevel）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "4) a) If the securityLevel specifies that the message is to be protected from disclosure, then the octet sequence representing the serialized scopedPDU is encrypted according to the user's privacy protocol. To do so a call is made to the privacy module that implements the user's privacy protocol according to the abstract primitive:",
      "ja": "4）a）securityLevelで、メッセージを開示から保護するように指定されている場合、シリアル化されたscopedPDUを表すオクテットシーケンスは、ユーザーのプライバシープロトコルに従って暗号化されます。これを行うには、抽象プリミティブに従ってユーザーのプライバシープロトコルを実装するプライバシーモジュールを呼び出します。"
    },
    {
      "indent": 9,
      "text": "statusInformation = -- success or failure encryptData( IN encryptKey -- user's localized privKey IN dataToEncrypt -- serialized scopedPDU OUT encryptedData -- serialized encryptedPDU OUT privParameters -- serialized privacy parameters )",
      "ja": "statusInformation =-成功または失敗encryptData（IN encryptKey-ユーザーのローカライズされたprivKey IN dataToEncrypt-シリアル化されたscopedPDU OUT encryptedData-シリアル化されたencryptedPDU OUT privParameters-シリアル化されたプライバシーパラメーター）"
    },
    {
      "indent": 9,
      "text": "statusInformation indicates if the encryption process was successful or not.",
      "ja": "statusInformationは、暗号化プロセスが成功したかどうかを示します。"
    },
    {
      "indent": 9,
      "text": "encryptKey the user's localized private privKey is the secret key that can be used by the encryption algorithm.",
      "ja": "ユーザーのローカライズされたプライベートprivKeyは、暗号化アルゴリズムで使用できる秘密鍵です。"
    },
    {
      "indent": 9,
      "text": "dataToEncrypt the serialized scopedPDU is the data to be encrypted.",
      "ja": "dataToEncryptは、シリアル化されたscopedPDUが暗号化されるデータです。"
    },
    {
      "indent": 9,
      "text": "encryptedData the encryptedPDU represents the encrypted scopedPDU, encoded as an OCTET STRING.",
      "ja": "encryptedData encryptedPDUは、OCTET STRINGとしてエンコードされた、暗号化されたscopedPDUを表します。"
    },
    {
      "indent": 9,
      "text": "privParameters the privacy parameters, encoded as an OCTET STRING.",
      "ja": "privParametersは、OCTET STRINGとしてエンコードされたプライバシーパラメータです。"
    },
    {
      "indent": 9,
      "text": "If the privacy module returns failure, then the message cannot be sent and an error indication (encryptionError) is returned to the calling module.",
      "ja": "プライバシーモジュールが失敗を返した場合、メッセージは送信できず、エラー表示（encryptionError）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 9,
      "text": "If the privacy module returns success, then the returned privParameters are put into the msgPrivacyParameters field of the securityParameters and the encryptedPDU serves as the payload of the message being prepared.",
      "ja": "プライバシーモジュールが成功を返す場合、返されたprivParametersはsecurityParametersのmsgPrivacyParametersフィールドに入れられ、encryptedPDUは準備中のメッセージのペイロードとして機能します。"
    },
    {
      "indent": 9,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 6,
      "text": "b) If the securityLevel specifies that the message is not to be be protected from disclosure, then a zero-length OCTET STRING is encoded into the msgPrivacyParameters field of the securityParameters and the plaintext scopedPDU serves as the payload of the message being prepared.",
      "ja": "b) securityLevelがメッセージを開示から保護しないことを指定している場合、長さがゼロのOCTET STRINGがsecurityParametersのmsgPrivacyParametersフィールドにエンコードされ、プレーンテキストのscopedPDUが準備中のメッセージのペイロードとして機能します。"
    },
    {
      "indent": 3,
      "text": "5) The securityEngineID is encoded as an OCTET STRING into the msgAuthoritativeEngineID field of the securityParameters. Note that an empty (zero length) securityEngineID is OK for a Request message, because that will cause the remote (authoritative) SNMP engine to return a Report PDU with the proper securityEngineID included in the msgAuthoritativeEngineID in the securityParameters of that returned Report PDU.",
      "ja": "5）securityEngineIDは、OCTET STRINGとしてsecurityParametersのmsgAuthoritativeEngineIDフィールドにエンコードされます。リモート（権限のある）SNMPエンジンが、返されたレポートPDUのsecurityParametersのmsgAuthoritativeEngineIDに含まれている適切なsecurityEngineIDを持つレポートPDUを返すため、空（長さがゼロ）のsecurityEngineIDは要求メッセージに対してOKであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "6) a) If the securityLevel specifies that the message is to be authenticated, then the current values of snmpEngineBoots and snmpEngineTime corresponding to the securityEngineID from the LCD are used.",
      "ja": "6）a）メッセージが認証されることをsecurityLevelが指定している場合、LCDのsecurityEngineIDに対応するsnmpEngineBootsおよびsnmpEngineTimeの現在の値が使用されます。"
    },
    {
      "indent": 9,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 6,
      "text": "b) If this is a Response or Report message, then the current value of snmpEngineBoots and snmpEngineTime corresponding to the local snmpEngineID from the LCD are used.",
      "ja": "b) これが応答またはレポートメッセージである場合、LCDからのローカルsnmpEngineIDに対応するsnmpEngineBootsおよびsnmpEngineTimeの現在の値が使用されます。"
    },
    {
      "indent": 9,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 6,
      "text": "c) If this is a Request message, then a zero value is used for both snmpEngineBoots and snmpEngineTime. This zero value gets used if snmpEngineID is empty.",
      "ja": "c) これが要求メッセージの場合、snmpEngineBootsとsnmpEngineTimeの両方にゼロの値が使用されます。このゼロ値は、snmpEngineIDが空の場合に使用されます。"
    },
    {
      "indent": 9,
      "text": "The values are encoded as INTEGER respectively into the msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime fields of the securityParameters.",
      "ja": "値は、それぞれINTEGERとしてエンコードされ、securityParametersのmsgAuthoritativeEngineBootsおよびmsgAuthoritativeEngineTimeフィールドに入力されます。"
    },
    {
      "indent": 3,
      "text": "7) The userName is encoded as an OCTET STRING into the msgUserName field of the securityParameters.",
      "ja": "7）userNameは、OCTET STRINGとしてsecurityParametersのmsgUserNameフィールドにエンコードされます。"
    },
    {
      "indent": 3,
      "text": "8) a) If the securityLevel specifies that the message is to be authenticated, the message is authenticated according to the user's authentication protocol. To do so a call is made to the authentication module that implements the user's authentication protocol according to the abstract service primitive:",
      "ja": "8）a）メッセージが認証されることをsecurityLevelが指定した場合、メッセージはユーザーの認証プロトコルに従って認証されます。これを行うには、抽象サービスプリミティブに従ってユーザーの認証プロトコルを実装する認証モジュールを呼び出します。"
    },
    {
      "indent": 9,
      "text": "statusInformation = authenticateOutgoingMsg( IN authKey -- the user's localized authKey IN wholeMsg -- unauthenticated message OUT authenticatedWholeMsg -- authenticated complete message )",
      "ja": "statusInformation = authenticateOutgoingMsg（IN authKey-ユーザーのローカライズされたauthKey IN wholeMsg-認証されていないメッセージOUT authenticationWholeMsg-認証された完全なメッセージ）"
    },
    {
      "indent": 9,
      "text": "statusInformation indicates if authentication was successful or not.",
      "ja": "statusInformationは、認証が成功したかどうかを示します。"
    },
    {
      "indent": 9,
      "text": "authKey the user's localized private authKey is the secret key that can be used by the authentication algorithm.",
      "ja": "authKeyユーザーのローカライズされたプライベートauthKeyは、認証アルゴリズムで使用できる秘密鍵です。"
    },
    {
      "indent": 9,
      "text": "wholeMsg the complete serialized message to be authenticated.",
      "ja": "wholeMsg認証される完全なシリアル化されたメッセージ。"
    },
    {
      "indent": 9,
      "text": "authenticatedWholeMsg the same as the input given to the authenticateOutgoingMsg service, but with msgAuthenticationParameters properly filled in.",
      "ja": "authenticationWholeMsgは、authenticateOutgoingMsgサービスへの入力と同じですが、msgAuthenticationParametersが適切に入力されています。"
    },
    {
      "indent": 9,
      "text": "If the authentication module returns failure, then the message cannot be sent and an error indication (authenticationFailure) is returned to the calling module.",
      "ja": "認証モジュールが失敗を返す場合、メッセージは送信できず、エラー表示（authenticationFailure）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 9,
      "text": "If the authentication module returns success, then the msgAuthenticationParameters field is put into the securityParameters and the authenticatedWholeMsg represents the serialization of the authenticated message being prepared.",
      "ja": "認証モジュールが成功を返すと、msgAuthenticationParametersフィールドがsecurityParametersに入れられ、authenticationWholeMsgは準備中の認証済みメッセージのシリアル化を表します。"
    },
    {
      "indent": 9,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 6,
      "text": "b) If the securityLevel specifies that the message is not to be authenticated then a zero-length OCTET STRING is encoded into the msgAuthenticationParameters field of the securityParameters. The wholeMsg is now serialized and then represents the unauthenticated message being prepared.",
      "ja": "b) メッセージが認証されないようにsecurityLevelで指定されている場合、長さがゼロのOCTET STRINGがsecurityParametersのmsgAuthenticationParametersフィールドにエンコードされます。 wholeMsgはシリアル化され、準備中の未認証メッセージを表します。"
    },
    {
      "indent": 3,
      "text": "9) The completed message with its length is returned to the calling module with the statusInformation set to success.",
      "ja": "9）完了したメッセージとその長さは、statusInformationが成功に設定された状態で呼び出しモジュールに返されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Processing an Incoming SNMP Message",
      "section_title": true,
      "ja": "3.2. 着信SNMPメッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it receives a message containing a management operation on behalf of a user, with a particular securityLevel.",
      "ja": "このセクションでは、特定のsecurityLevelを持つユーザーに代わって管理操作を含むメッセージを受信するたびに、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "To simplify the elements of procedure, the release of state information is not always explicitly specified. As a general rule, if state information is available when a message gets discarded, the state information should also be released. Also, an error indication can return an OID and value for an incremented counter and optionally a value for securityLevel, and values for contextEngineID or contextName for the counter. In addition, the securityStateReference data is returned if any such information is available at the point where the error is detected.",
      "ja": "手順の要素を簡略化するために、状態情報のリリースは常に明示的に指定されるとは限りません。原則として、メッセージが破棄されたときに状態情報が利用可能な場合は、状態情報も解放する必要があります。また、エラー表示は、インクリメントされたカウンターのOIDと値、およびオプションでsecurityLevelの値、およびカウンターのcontextEngineIDまたはcontextNameの値を返すことができます。また、エラーが検出された時点でそのような情報が利用可能な場合は、securityStateReferenceデータが返されます。"
    },
    {
      "indent": 3,
      "text": "1) If the received securityParameters is not the serialization (according to the conventions of [RFC3417]) of an OCTET STRING formatted according to the UsmSecurityParameters defined in section 2.4, then the snmpInASNParseErrs counter [RFC3418] is incremented, and an error indication (parseError) is returned to the calling module. Note that we return without the OID and value of the incremented counter, because in this case there is not enough information to generate a Report PDU.",
      "ja": "1）セクション2.4で定義されたUsmSecurityParametersに従ってフォーマットされたOCTET STRINGの（[RFC3417]の規則に従って）受信したsecurityParametersがシリアル化されていない場合、snmpInASNParseErrsカウンター[RFC3418]がインクリメントされ、エラー表示（parseError ）が呼び出しモジュールに返されます。この場合、レポートPDUを生成するための十分な情報がないため、インクリメントされたカウンターのOIDと値なしで戻ることに注意してください。"
    },
    {
      "indent": 3,
      "text": "2) The values of the security parameter fields are extracted from the securityParameters. The securityEngineID to be returned to the caller is the value of the msgAuthoritativeEngineID field. The cachedSecurityData is prepared and a securityStateReference is prepared to reference this data. Values to be cached are:",
      "ja": "2）セキュリティパラメータフィールドの値は、securityParametersから抽出されます。呼び出し元に返されるsecurityEngineIDは、msgAuthoritativeEngineIDフィールドの値です。 cachedSecurityDataが準備され、このデータを参照するためにsecurityStateReferenceが準備されます。キャッシュされる値は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "msgUserName",
      "ja": "msgUserName"
    },
    {
      "indent": 3,
      "text": "3) If the value of the msgAuthoritativeEngineID field in the securityParameters is unknown then:",
      "ja": "3）securityParametersのmsgAuthoritativeEngineIDフィールドの値が不明な場合："
    },
    {
      "indent": 7,
      "text": "a) a non-authoritative SNMP engine that performs discovery may optionally create a new entry in its Local Configuration Datastore (LCD) and continue processing;",
      "ja": "a) 検出を実行する権限のないSNMPエンジンは、オプションでローカル構成データストア（LCD）に新しいエントリを作成して処理を続行できます。"
    },
    {
      "indent": 10,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 7,
      "text": "b) the usmStatsUnknownEngineIDs counter is incremented, and an error indication (unknownEngineID) together with the OID and value of the incremented counter is returned to the calling module.",
      "ja": "b) usmStatsUnknownEngineIDsカウンターがインクリメントされ、インクリメントされたカウンターのOIDおよび値とともにエラー表示（unknownEngineID）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 7,
      "text": "Note in the event that a zero-length, or other illegally sized msgAuthoritativeEngineID is received, b) should be chosen to facilitate engineID discovery. Otherwise the choice between a) and b) is an implementation issue.",
      "ja": "長さがゼロまたはその他の不正なサイズのmsgAuthoritativeEngineIDが受信された場合は、b）engineIDの検出を容易にするために選択する必要があることに注意してください。それ以外の場合、a）とb）の間の選択は実装の問題です。"
    },
    {
      "indent": 3,
      "text": "4) Information about the value of the msgUserName and msgAuthoritativeEngineID fields is extracted from the Local Configuration Datastore (LCD, usmUserTable). If no information is available for the user, then the usmStatsUnknownUserNames counter is incremented and an error indication (unknownSecurityName) together with the OID and value of the incremented counter is returned to the calling module.",
      "ja": "4）msgUserNameおよびmsgAuthoritativeEngineIDフィールドの値に関する情報は、ローカル構成データストア（LCD、usmUserTable）から抽出されます。ユーザーが利用できる情報がない場合は、usmStatsUnknownUserNamesカウンターがインクリメントされ、インクリメントされたカウンターのOIDと値とともにエラー表示（unknownSecurityName）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "5) If the information about the user indicates that it does not support the securityLevel requested by the caller, then the usmStatsUnsupportedSecLevels counter is incremented and an error indication (unsupportedSecurityLevel) together with the OID and value of the incremented counter is returned to the calling module.",
      "ja": "5）ユーザーに関する情報が、呼び出し元によって要求されたsecurityLevelをサポートしていないことを示している場合、usmStatsUnsupportedSecLevelsカウンターがインクリメントされ、エラー表示（unsupportedSecurityLevel）とOIDおよびインクリメントされたカウンターの値が呼び出しモジュールに返されます。 。"
    },
    {
      "indent": 3,
      "text": "6) If the securityLevel specifies that the message is to be authenticated, then the message is authenticated according to the user's authentication protocol. To do so a call is made to the authentication module that implements the user's authentication protocol according to the abstract service primitive:",
      "ja": "6）securityLevelでメッセージの認証が指定されている場合、メッセージはユーザーの認証プロトコルに従って認証されます。これを行うには、抽象サービスプリミティブに従ってユーザーの認証プロトコルを実装する認証モジュールを呼び出します。"
    },
    {
      "indent": 7,
      "text": "statusInformation = -- success or failure authenticateIncomingMsg( IN authKey -- the user's localized authKey IN authParameters -- as received on the wire IN wholeMsg -- as received on the wire OUT authenticatedWholeMsg -- checked for authentication )",
      "ja": "statusInformation =-成功または失敗authenticateIncomingMsg（IN authKey-ユーザーのローカライズされたauthKey IN authParameters-ワイヤー上で受信されたとおりINholeMsg-ワイヤー上で受信された場合OUT authenticationWholeMsg-認証の確認）"
    },
    {
      "indent": 7,
      "text": "statusInformation indicates if authentication was successful or not.",
      "ja": "statusInformationは、認証が成功したかどうかを示します。"
    },
    {
      "indent": 7,
      "text": "authKey the user's localized private authKey is the secret key that can be used by the authentication algorithm.",
      "ja": "authKeyユーザーのローカライズされたプライベートauthKeyは、認証アルゴリズムで使用できる秘密鍵です。"
    },
    {
      "indent": 7,
      "text": "wholeMsg the complete serialized message to be authenticated.",
      "ja": "wholeMsg認証される完全なシリアル化されたメッセージ。"
    },
    {
      "indent": 7,
      "text": "authenticatedWholeMsg the same as the input given to the authenticateIncomingMsg service, but after authentication has been checked.",
      "ja": "authenticationWholeMsgは、authenticateIncomingMsgサービスへの入力と同じですが、認証がチェックされた後です。"
    },
    {
      "indent": 7,
      "text": "If the authentication module returns failure, then the message cannot be trusted, so the usmStatsWrongDigests counter is incremented and an error indication (authenticationFailure) together with the OID and value of the incremented counter is returned to the calling module.",
      "ja": "認証モジュールが失敗を返す場合、メッセージは信頼できないため、usmStatsWrongDigestsカウンターがインクリメントされ、インクリメントされたカウンターのOIDおよび値とともにエラー表示（authenticationFailure）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 7,
      "text": "If the authentication module returns success, then the message is authentic and can be trusted so processing continues.",
      "ja": "認証モジュールが成功を返す場合、メッセージは本物であり、信頼できるため、処理を続行します。"
    },
    {
      "indent": 3,
      "text": "7) If the securityLevel indicates an authenticated message, then the local values of snmpEngineBoots, snmpEngineTime and latestReceivedEngineTime corresponding to the value of the msgAuthoritativeEngineID field are extracted from the Local Configuration Datastore.",
      "ja": "7）securityLevelが認証済みメッセージを示す場合、msgAuthoritativeEngineIDフィールドの値に対応するsnmpEngineBoots、snmpEngineTime、latestReceivedEngineTimeのローカル値がローカル構成データストアから抽出されます。"
    },
    {
      "indent": 7,
      "text": "a) If the extracted value of msgAuthoritativeEngineID is the same as the value of snmpEngineID of the processing SNMP engine (meaning this is the authoritative SNMP engine), then if any of the following conditions is true, then the message is considered to be outside of the Time Window:",
      "ja": "a) 抽出されたmsgAuthoritativeEngineIDの値が、処理中のSNMPエンジンのsnmpEngineIDの値と同じである場合（つまり、これが信頼できるSNMPエンジンである場合）、次の条件のいずれかに該当する場合、メッセージは時間外と見なされます。窓："
    },
    {
      "indent": 10,
      "text": "- the local value of snmpEngineBoots is 2147483647;",
      "ja": "- snmpEngineBootsのローカル値は2147483647です。"
    },
    {
      "indent": 10,
      "text": "- the value of the msgAuthoritativeEngineBoots field differs from the local value of snmpEngineBoots; or,",
      "ja": "- msgAuthoritativeEngineBootsフィールドの値は、snmpEngineBootsのローカル値とは異なります。または、"
    },
    {
      "indent": 10,
      "text": "- the value of the msgAuthoritativeEngineTime field differs from the local notion of snmpEngineTime by more than +/- 150 seconds.",
      "ja": "- msgAuthoritativeEngineTimeフィールドの値は、ローカルのsnmpEngineTimeの概念と+/- 150秒以上異なります。"
    },
    {
      "indent": 10,
      "text": "If the message is considered to be outside of the Time Window then the usmStatsNotInTimeWindows counter is incremented and an error indication (notInTimeWindow) together with the OID, the value of the incremented counter, and an indication that the error must be reported with a securityLevel of authNoPriv, is returned to the calling module",
      "ja": "メッセージがタイムウィンドウの外側にあると見なされた場合、usmStatsNotInTimeWindowsカウンターがインクリメントされ、OID、インクリメントされたカウンターの値、およびエラーがsecurityLevelで報告される必要があることを示すエラー表示（notInTimeWindow） authNoPriv、呼び出しモジュールに返されます"
    },
    {
      "indent": 7,
      "text": "b) If the extracted value of msgAuthoritativeEngineID is not the same as the value snmpEngineID of the processing SNMP engine (meaning this is not the authoritative SNMP engine), then:",
      "ja": "b) 抽出されたmsgAuthoritativeEngineIDの値が、処理中のSNMPエンジンの値snmpEngineIDと同じでない場合（つまり、これは信頼できるSNMPエンジンではない）。"
    },
    {
      "indent": 10,
      "text": "1) if at least one of the following conditions is true:",
      "ja": "1）次の条件の少なくとも1つに該当する場合："
    },
    {
      "indent": 13,
      "text": "- the extracted value of the msgAuthoritativeEngineBoots field is greater than the local notion of the value of snmpEngineBoots; or,",
      "ja": "- msgAuthoritativeEngineBootsフィールドの抽出された値は、snmpEngineBootsの値のローカルの概念よりも大きいです。または、"
    },
    {
      "indent": 13,
      "text": "- the extracted value of the msgAuthoritativeEngineBoots field is equal to the local notion of the value of snmpEngineBoots, and the extracted value of msgAuthoritativeEngineTime field is greater than the value of latestReceivedEngineTime,",
      "ja": "- msgAuthoritativeEngineBootsフィールドの抽出された値は、snmpEngineBootsの値のローカル表記と等しく、msgAuthoritativeEngineTimeフィールドの抽出された値は、latestReceivedEngineTimeの値よりも大きいです。"
    },
    {
      "indent": 13,
      "text": "then the LCD entry corresponding to the extracted value of the msgAuthoritativeEngineID field is updated, by setting:",
      "ja": "次に、次の設定により、msgAuthoritativeEngineIDフィールドの抽出された値に対応するLCDエントリが更新されます。"
    },
    {
      "indent": 13,
      "text": "- the local notion of the value of snmpEngineBoots to the value of the msgAuthoritativeEngineBoots field,",
      "ja": "- snmpEngineBootsの値からmsgAuthoritativeEngineBootsフィールドの値へのローカルな概念、"
    },
    {
      "indent": 13,
      "text": "- the local notion of the value of snmpEngineTime to the value of the msgAuthoritativeEngineTime field, and",
      "ja": "- snmpEngineTimeの値からmsgAuthoritativeEngineTimeフィールドの値へのローカルな概念、および"
    },
    {
      "indent": 13,
      "text": "- the latestReceivedEngineTime to the value of the value of the msgAuthoritativeEngineTime field.",
      "ja": "- latestReceivedEngineTimeをmsgAuthoritativeEngineTimeフィールドの値の値に。"
    },
    {
      "indent": 10,
      "text": "2) if any of the following conditions is true, then the message is considered to be outside of the Time Window:",
      "ja": "2）次の条件のいずれかに該当する場合、メッセージはタイムウィンドウの外にあると見なされます。"
    },
    {
      "indent": 13,
      "text": "- the local notion of the value of snmpEngineBoots is 2147483647;",
      "ja": "- snmpEngineBootsの値のローカルな概念は2147483647です。"
    },
    {
      "indent": 13,
      "text": "- the value of the msgAuthoritativeEngineBoots field is less than the local notion of the value of snmpEngineBoots; or,",
      "ja": "- msgAuthoritativeEngineBootsフィールドの値が、snmpEngineBootsの値のローカルな概念よりも小さい。または、"
    },
    {
      "indent": 13,
      "text": "- the value of the msgAuthoritativeEngineBoots field is equal to the local notion of the value of snmpEngineBoots and the value of the msgAuthoritativeEngineTime field is more than 150 seconds less than the local notion of the value of snmpEngineTime.",
      "ja": "- msgAuthoritativeEngineBootsフィールドの値は、snmpEngineBootsの値のローカル表記に等しく、msgAuthoritativeEngineTimeフィールドの値は、snmpEngineTimeの値のローカル表記よりも150秒以上短くなります。"
    },
    {
      "indent": 13,
      "text": "If the message is considered to be outside of the Time Window then an error indication (notInTimeWindow) is returned to the calling module.",
      "ja": "メッセージがタイムウィンドウの外側にあると見なされた場合、エラー表示（notInTimeWindow）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 13,
      "text": "Note that this means that a too old (possibly replayed) message has been detected and is deemed unauthentic.",
      "ja": "これは、古すぎる（おそらく再生された）メッセージが検出され、認証されていないと見なされることを意味します。"
    },
    {
      "indent": 13,
      "text": "Note that this procedure allows for the value of msgAuthoritativeEngineBoots in the message to be greater than the local notion of the value of snmpEngineBoots to allow for received messages to be accepted as authentic when received from an authoritative SNMP engine that has re-booted since the receiving SNMP engine last (re-)synchronized.",
      "ja": "この手順では、メッセージ内のmsgAuthoritativeEngineBootsの値を、snmpEngineBootsの値のローカルの概念よりも大きくして、受信後に再起動した信頼できるSNMPエンジンから受信したときに、受信したメッセージを本物として受け入れることができることに注意してください。 SNMPエンジンは最後に（再）同期されました。"
    },
    {
      "indent": 3,
      "text": "8) a) If the securityLevel indicates that the message was protected from disclosure, then the OCTET STRING representing the encryptedPDU is decrypted according to the user's privacy protocol to obtain an unencrypted serialized scopedPDU value. To do so a call is made to the privacy module that implements the user's privacy protocol according to the abstract primitive:",
      "ja": "8）a）メッセージが開示から保護されたことをsecurityLevelが示す場合、encryptedPDUを表すOCTET STRINGはユーザーのプライバシープロトコルに従って復号化され、暗号化されていないシリアル化されたscopedPDU値が取得されます。これを行うには、抽象プリミティブに従ってユーザーのプライバシープロトコルを実装するプライバシーモジュールを呼び出します。"
    },
    {
      "indent": 10,
      "text": "statusInformation = -- success or failure decryptData( IN decryptKey -- the user's localized privKey IN privParameters -- as received on the wire IN encryptedData -- encryptedPDU as received OUT decryptedData -- serialized decrypted scopedPDU )",
      "ja": "statusInformation =-成功または失敗decodeData（IN decodeKey-ユーザーのローカライズされたprivKey IN privParameters-回線上で受信されたとおりIN encryptedData-受信されたままのencryptedPDU OUT decryptedData-シリアル化された復号化scopedPDU）"
    },
    {
      "indent": 10,
      "text": "statusInformation indicates if the decryption process was successful or not.",
      "ja": "statusInformationは、復号化プロセスが成功したかどうかを示します。"
    },
    {
      "indent": 10,
      "text": "decryptKey the user's localized private privKey is the secret key that can be used by the decryption algorithm.",
      "ja": "ユーザーのローカライズされたプライベートなprivKeyは、復号化アルゴリズムで使用できる秘密鍵です。"
    },
    {
      "indent": 10,
      "text": "privParameters the msgPrivacyParameters, encoded as an OCTET STRING.",
      "ja": "privParametersは、OCTET STRINGとしてエンコードされたmsgPrivacyParametersです。"
    },
    {
      "indent": 10,
      "text": "encryptedData the encryptedPDU represents the encrypted scopedPDU, encoded as an OCTET STRING.",
      "ja": "encryptedData encryptedPDUは、OCTET STRINGとしてエンコードされた、暗号化されたscopedPDUを表します。"
    },
    {
      "indent": 10,
      "text": "decryptedData the serialized scopedPDU if decryption is successful.",
      "ja": "解読が成功した場合は、decryptedDataシリアル化されたscopedPDU。"
    },
    {
      "indent": 10,
      "text": "If the privacy module returns failure, then the message can not be processed, so the usmStatsDecryptionErrors counter is incremented and an error indication (decryptionError) together with the OID and value of the incremented counter is returned to the calling module.",
      "ja": "プライバシーモジュールが失敗を返す場合、メッセージは処理できないため、usmStatsDecryptionErrorsカウンターがインクリメントされ、エラー表示（decryptionError）とOIDおよびインクリメントされたカウンターの値が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 10,
      "text": "If the privacy module returns success, then the decrypted scopedPDU is the message payload to be returned to the calling module.",
      "ja": "プライバシーモジュールが成功を返した場合、復号化されたscopedPDUは、呼び出しモジュールに返されるメッセージペイロードです。"
    },
    {
      "indent": 10,
      "text": "Otherwise,",
      "ja": "さもないと、"
    },
    {
      "indent": 7,
      "text": "b) The scopedPDU component is assumed to be in plain text and is the message payload to be returned to the calling module.",
      "ja": "b) scopedPDUコンポーネントはプレーンテキストであると想定されており、呼び出しモジュールに返されるメッセージペイロードです。"
    },
    {
      "indent": 3,
      "text": "9) The maxSizeResponseScopedPDU is calculated. This is the maximum size allowed for a scopedPDU for a possible Response message. Provision is made for a message header that allows the same securityLevel as the received Request.",
      "ja": "9）maxSizeResponseScopedPDUが計算されます。これは、可能なResponseメッセージのscopedPDUに許可される最大サイズです。受信したリクエストと同じセキュリティレベルを許可するメッセージヘッダーが提供されます。"
    },
    {
      "indent": 3,
      "text": "10) The securityName for the user is retrieved from the usmUserTable.",
      "ja": "10）ユーザーのsecurityNameは、usmUserTableから取得されます。"
    },
    {
      "indent": 3,
      "text": "11) The security data is cached as cachedSecurityData, so that a possible response to this message can and will use the same authentication and privacy secrets. Information to be saved/cached is as follows:",
      "ja": "11）セキュリティデータはcachedSecurityDataとしてキャッシュされるため、このメッセージへの可能な応答は同じ認証とプライバシーシークレットを使用できます。保存/キャッシュする情報は以下のとおりです。"
    },
    {
      "indent": 10,
      "text": "msgUserName, usmUserAuthProtocol, usmUserAuthKey usmUserPrivProtocol, usmUserPrivKey",
      "ja": "msgUserName、usmUserAuthProtocol、usmUserAuthKey usmUserPrivProtocol、usmUserPrivKey"
    },
    {
      "indent": 3,
      "text": "12) The statusInformation is set to success and a return is made to the calling module passing back the OUT parameters as specified in the processIncomingMsg primitive.",
      "ja": "12）statusInformationが成功に設定され、processIncomingMsgプリミティブで指定されたようにOUTパラメータを返す呼び出しモジュールに戻ります。"
    },
    {
      "indent": 0,
      "text": "4. Discovery",
      "section_title": true,
      "ja": "4. 発見"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model requires that a discovery process obtains sufficient information about other SNMP engines in order to communicate with them. Discovery requires an non-authoritative SNMP engine to learn the authoritative SNMP engine's snmpEngineID value before communication may proceed. This may be accomplished by generating a Request message with a securityLevel of noAuthNoPriv, a msgUserName of zero-length, a msgAuthoritativeEngineID value of zero length, and the varBindList left empty. The response to this message will be a Report message containing the snmpEngineID of the authoritative SNMP engine as the value of the msgAuthoritativeEngineID field within the msgSecurityParameters field. It contains a Report PDU with the usmStatsUnknownEngineIDs counter in the varBindList.",
      "ja": "ユーザーベースのセキュリティモデルでは、他のSNMPエンジンと通信するために、検出プロセスが他のSNMPエンジンに関する十分な情報を取得する必要があります。ディスカバリでは、通信を続行する前に、信頼できないSNMPエンジンが信頼できるSNMPエンジンのsnmpEngineID値を学習する必要があります。これは、noAuthNoPrivのsecurityLevel、長さ0のmsgUserName、長さ0のmsgAuthoritativeEngineID値、空のvarBindListを使用して、要求メッセージを生成することで実現できます。このメッセージへの応答は、msgSecurityParametersフィールド内のmsgAuthoritativeEngineIDフィールドの値として、信頼できるSNMPエンジンのsnmpEngineIDを含むレポートメッセージになります。これには、varBindListのusmStatsUnknownEngineIDsカウンターを持つReport PDUが含まれています。"
    },
    {
      "indent": 3,
      "text": "If authenticated communication is required, then the discovery process should also establish time synchronization with the authoritative SNMP engine. This may be accomplished by sending an authenticated Request message with the value of msgAuthoritativeEngineID set to the newly learned snmpEngineID and with the values of msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime set to zero. For an authenticated Request message, a valid userName must be used in the msgUserName field. The response to this authenticated message will be a Report message containing the up to date values of the authoritative SNMP engine's snmpEngineBoots and snmpEngineTime as the value of the msgAuthoritativeEngineBoots and msgAuthoritativeEngineTime fields respectively. It also contains the usmStatsNotInTimeWindows counter in the varBindList of the Report PDU. The time synchronization then happens automatically as part of the procedures in section 3.2 step 7b. See also section 2.3.",
      "ja": "認証された通信が必要な場合、検出プロセスでは、信頼できるSNMPエンジンとの時間同期も確立する必要があります。これは、msgAuthoritativeEngineIDの値を新しく学習したsnmpEngineIDに設定し、msgAuthoritativeEngineBootsとmsgAuthoritativeEngineTimeの値をゼロに設定して、認証済みの要求メッセージを送信することで実現できます。認証されたリクエストメッセージの場合、有効なuserNameをmsgUserNameフィールドで使用する必要があります。この認証されたメッセージへの応答は、信頼できるSNMPエンジンのsnmpEngineBootsおよびsnmpEngineTimeの最新の値をそれぞれmsgAuthoritativeEngineBootsおよびmsgAuthoritativeEngineTimeフィールドの値として含むレポートメッセージになります。また、レポートPDUのvarBindListにusmStatsNotInTimeWindowsカウンターが含まれています。時間の同期は、セクション3.2の手順7bの手順の一部として自動的に行われます。セクション2.3も参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Definitions",
      "section_title": true,
      "ja": "5. 定義"
    },
    {
      "indent": 0,
      "text": "SNMP-USER-BASED-SM-MIB DEFINITIONS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "IMPORTS MODULE-IDENTITY, OBJECT-TYPE, OBJECT-IDENTITY, snmpModules, Counter32 FROM SNMPv2-SMI TEXTUAL-CONVENTION, TestAndIncr, RowStatus, RowPointer, StorageType, AutonomousType FROM SNMPv2-TC MODULE-COMPLIANCE, OBJECT-GROUP FROM SNMPv2-CONF SnmpAdminString, SnmpEngineID, snmpAuthProtocols, snmpPrivProtocols FROM SNMP-FRAMEWORK-MIB;",
      "ja": "IMPORTS MODULE-IDENTITY、OBJECT-TYPE、OBJECT-IDENTITY、snmpModules、Counter32 FROM SNMPv2-SMI TEXTUAL-CONVENTION、TestAndIncr、RowStatus、RowPointer、StorageType、AutonomousType FROM SNMPv2-TC MODULE-COMPLIANCE、OBJECT-GROUP FROM SNMPv2-CONF SnmpAdminString SnmpEngineID、snmpAuthProtocols、snmpPrivProtocols FROM SNMP-FRAMEWORK-MIB;"
    },
    {
      "indent": 0,
      "text": "snmpUsmMIB MODULE-IDENTITY LAST-UPDATED \"200210160000Z\" -- 16 Oct 2002, midnight ORGANIZATION \"SNMPv3 Working Group\" CONTACT-INFO \"WG-email: snmpv3@lists.tislabs.com Subscribe: majordomo@lists.tislabs.com In msg body: subscribe snmpv3",
      "ja": "snmpUsmMIB MODULE-IDENTITY LAST-UPDATED \"200210160000Z\"-2002年10月16日、深夜組織 \"SNMPv3ワーキンググループ\"連絡先情報 \"WG-email：snmpv3@lists.tislabs.com購読：majordomo@lists.tislabs.comメッセージ本文：snmpv3をサブスクライブします"
    },
    {
      "indent": 18,
      "text": "Chair: Russ Mundy Network Associates Laboratories postal: 15204 Omega Drive, Suite 300 Rockville, MD 20850-4601 USA email: mundy@tislabs.com phone: +1 301-947-7107",
      "ja": "議長：Russ Mundy Network Associates Laboratories郵便：15204 Omega Drive、Suite 300 Rockville、MD 20850-4601 USAメール：mundy@tislabs.com電話：+1 301-947-7107"
    },
    {
      "indent": 18,
      "text": "Co-Chair: David Harrington Enterasys Networks Postal: 35 Industrial Way P. O. Box 5004 Rochester, New Hampshire 03866-5005 USA EMail: dbh@enterasys.com Phone: +1 603-337-2614",
      "ja": "共同議長：David Harrington Enterasys Networks郵便：35 Industrial Way P.O. Box 5004 Rochester、New Hampshire 03866-5005 USA Eメール：dbh@enterasys.com電話：+1 603-337-2614"
    },
    {
      "indent": 18,
      "text": "Co-editor Uri Blumenthal Lucent Technologies postal: 67 Whippany Rd. Whippany, NJ 07981 USA email: uri@lucent.com phone: +1-973-386-2163",
      "ja": "共同編集者Uri Blumenthal Lucent Technologies郵便：67 Whippany Rd。 Whippany、NJ 07981 USA email：uri@lucent.com電話：+ 1-973-386-2163"
    },
    {
      "indent": 4,
      "text": " Co-editor: Bert Wijnen Lucent Technologies postal: Schagen 33 3461 GL Linschoten Netherlands email: bwijnen@lucent.com phone: +31-348-480-685 \" DESCRIPTION \"The management information definitions for the SNMP User-based Security Model.",
      "ja": "共同編集者：Bert Wijnen Lucent Technologies郵便：Schagen 33 3461 GL Linschotenオランダメール：bwijnen@lucent.com電話：+ 31-348-480-685 \"説明\" SNMPユーザーベースのセキュリティモデルの管理情報定義。"
    },
    {
      "indent": 0,
      "text": " Copyright (C) The Internet Society (2002). This version of this MIB module is part of RFC 3414; see the RFC itself for full legal notices. \" -- Revision history",
      "ja": "Copyright（C）The Internet Society（2002）。このMIBモジュールのこのバージョンはRFC 3414の一部です。完全な法的通知については、RFC自体を参照してください。 \"-改訂履歴"
    },
    {
      "indent": 4,
      "text": "REVISION \"200210160000Z\" -- 16 Oct 2002, midnight DESCRIPTION \"Changes in this revision: - Updated references and contact info. - Clarification to usmUserCloneFrom DESCRIPTION clause - Fixed 'command responder' into 'command generator' in last para of DESCRIPTION clause of usmUserTable. This revision published as RFC3414. \" REVISION \"199901200000Z\" -- 20 Jan 1999, midnight DESCRIPTION \"Clarifications, published as RFC2574\"",
      "ja": "REVISION \"200210160000Z\"-2002年10月16日、真夜中説明 \"このリビジョンでの変更：-参照と連絡先情報の更新。-usmUserCloneFrom DESCRIPTION句の明確化-usmUserTableのDESCRIPTION句の最後の段落の「コマンドレスポンダー」を「コマンドジェネレーター」に修正。この改訂版はRFC3414として公開されました。「REVISION \"199901200000Z\"-1999年1月20日、真夜中説明 \"説明、RFC2574として公開されました\""
    },
    {
      "indent": 4,
      "text": "REVISION \"199711200000Z\" -- 20 Nov 1997, midnight DESCRIPTION \"Initial version, published as RFC2274\"",
      "ja": "REVISION \"199711200000Z\"-1997年11月20日、真夜中説明 \"初期バージョン、RFC2274として公開\""
    },
    {
      "indent": 4,
      "text": "::= { snmpModules 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Administrative assignments ****************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmMIBObjects     OBJECT IDENTIFIER ::= { snmpUsmMIB 1 }\nusmMIBConformance OBJECT IDENTIFIER ::= { snmpUsmMIB 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Identification of Authentication and Privacy Protocols ************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmNoAuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"No Authentication Protocol.\"\n    ::= { snmpAuthProtocols 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmHMACMD5AuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"The HMAC-MD5-96 Digest Authentication Protocol.\"\n    REFERENCE    \"- H. Krawczyk, M. Bellare, R. Canetti HMAC:\n                    Keyed-Hashing for Message Authentication,\n                    RFC2104, Feb 1997.\n                  - Rivest, R., Message Digest Algorithm MD5, RFC1321.\n                 \"\n    ::= { snmpAuthProtocols 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmHMACSHAAuthProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"The HMAC-SHA-96 Digest Authentication Protocol.\"\n    REFERENCE    \"- H. Krawczyk, M. Bellare, R. Canetti, HMAC:\n                    Keyed-Hashing for Message Authentication,\n                    RFC2104, Feb 1997.\n                  - Secure Hash Algorithm. NIST FIPS 180-1.\n                 \"\n    ::= { snmpAuthProtocols 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmNoPrivProtocol OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"No Privacy Protocol.\"\n    ::= { snmpPrivProtocols 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmDESPrivProtocol OBJECT-IDENTITY STATUS current DESCRIPTION \"The CBC-DES Symmetric Encryption Protocol.\" REFERENCE \"- Data Encryption Standard, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 46-1.",
      "ja": "usmDESPrivProtocol OBJECT-IDENTITY STATUS current DESCRIPTION「CBC-DES対称暗号化プロトコル」。参照 \"-データの暗号化標準、米国国立標準技術研究所。連邦情報処理標準（FIPS）出版物46-1。"
    },
    {
      "indent": 20,
      "text": "Supersedes FIPS Publication 46, (January, 1977; reaffirmed January, 1988).",
      "ja": "FIPS Publication 46に取って代わります（1977年1月、1988年1月に再確認）。"
    },
    {
      "indent": 18,
      "text": "- Data Encryption Algorithm, American National Standards Institute. ANSI X3.92-1981, (December, 1980).",
      "ja": "- データ暗号化アルゴリズム、American National Standards Institute。 ANSI X3.92-1981、（1980年12月）。"
    },
    {
      "indent": 18,
      "text": "- DES Modes of Operation, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 81, (December, 1980).",
      "ja": "- 国立標準技術研究所のDES Modes of Operation。連邦情報処理標準（FIPS）Publication 81、（1980年12月）。"
    },
    {
      "indent": 4,
      "text": "              - Data Encryption Algorithm - Modes of Operation,\n                American National Standards Institute.\n                ANSI X3.106-1983, (May 1983).\n             \"\n::= { snmpPrivProtocols 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Textual Conventions ***********************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KeyChange ::=     TEXTUAL-CONVENTION\n   STATUS         current\n   DESCRIPTION\n         \"Every definition of an object with this syntax must identify\n          a protocol P, a secret key K, and a hash algorithm H\n          that produces output of L octets.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "The object's value is a manager-generated, partially-random value which, when modified, causes the value of the secret key K, to be modified via a one-way function.",
      "ja": "オブジェクトの値は、マネージャーが生成した部分的にランダムな値であり、変更されると、秘密鍵Kの値が一方向関数を介して変更されます。"
    },
    {
      "indent": 10,
      "text": "The value of an instance of this object is the concatenation of two components: first a 'random' component and then a 'delta' component.",
      "ja": "このオブジェクトのインスタンスの値は、2つのコンポーネントの連結です。最初は「ランダム」コンポーネント、次に「デルタ」コンポーネントです。"
    },
    {
      "indent": 10,
      "text": "The lengths of the random and delta components are given by the corresponding value of the protocol P; if P requires K to be a fixed length, the length of both the random and delta components is that fixed length; if P allows the length of K to be variable up to a particular maximum length, the length of the random component is that maximum length and the length of the delta component is any length less than or equal to that maximum length. For example, usmHMACMD5AuthProtocol requires K to be a fixed length of 16 octets and L - of 16 octets. usmHMACSHAAuthProtocol requires K to be a fixed length of 20 octets and L - of 20 octets. Other protocols may define other sizes, as deemed appropriate.",
      "ja": "ランダム成分とデルタ成分の長さは、プロトコルPの対応する値によって指定されます。 PがKを固定長にする必要がある場合、ランダム成分とデルタ成分の両方の長さがその固定長になります。 PがKの長さを特定の最大長まで可変にできる場合、ランダムコンポーネントの長さはその最大長であり、デルタコンポーネントの長さはその最大長以下の任意の長さです。たとえば、usmHMACMD5AuthProtocolでは、Kを16オクテットの固定長、L-16オクテットにする必要があります。 usmHMACSHAAuthProtocolでは、Kを20オクテットの固定長、L-20オクテットにする必要があります。他のプロトコルは、適切と見なされるように、他のサイズを定義することがあります。"
    },
    {
      "indent": 10,
      "text": "When a requester wants to change the old key K to a new key keyNew on a remote entity, the 'random' component is obtained from either a true random generator, or from a pseudorandom generator, and the 'delta' component is computed as follows:",
      "ja": "リクエスターがリモートエンティティの古いキーKを新しいキーkeyNewに変更する場合、「ランダム」コンポーネントは、真のランダムジェネレーターまたは疑似ランダムジェネレーターから取得され、「デルタ」コンポーネントは次のように計算されます。 ："
    },
    {
      "indent": 11,
      "text": "- a temporary variable is initialized to the existing value of K; - if the length of the keyNew is greater than L octets, then: - the random component is appended to the value of the temporary variable, and the result is input to the the hash algorithm H to produce a digest value, and the temporary variable is set to this digest value; - the value of the temporary variable is XOR-ed with the first (next) L-octets (16 octets in case of MD5) of the keyNew to produce the first (next) L-octets (16 octets in case of MD5) of the 'delta' component. - the above two steps are repeated until the unused portion of the keyNew component is L octets or less, - the random component is appended to the value of the temporary variable, and the result is input to the hash algorithm H to produce a digest value; - this digest value, truncated if necessary to be the same length as the unused portion of the keyNew, is XOR-ed with the unused portion of the keyNew to produce the (final portion of the) 'delta' component.",
      "ja": "- 一時変数は、Kの既存の値に初期化されます。 -keyNewの長さがLオクテットより大きい場合：-ランダムコンポーネントが一時変数の値に追加され、その結果がハッシュアルゴリズムHに入力されてダイジェスト値と一時変数が生成されます。このダイジェスト値に設定されます。 -一時変数の値は、keyNewの最初の（次の）Lオクテット（MD5の場合は16オクテット）とXORされ、最初の（次の）Lオクテット（MD5の場合は16オクテット）を生成します。 「デルタ」コンポーネント。 -keyNewコンポーネントの未使用部分がLオクテット以下になるまで上記の2つのステップが繰り返されます-ランダムコンポーネントが一時変数の値に追加され、結果がハッシュアルゴリズムHに入力されてダイジェスト値が生成されます; -このダイジェスト値は、必要に応じてkeyNewの未使用部分と同じ長さに切り捨てられ、keyNewの未使用部分とXORされて、「デルタ」コンポーネント（の最終部分）が生成されます。"
    },
    {
      "indent": 11,
      "text": "For example, using MD5 as the hash algorithm H:",
      "ja": "たとえば、ハッシュアルゴリズムHとしてMD5を使用します。"
    },
    {
      "indent": 14,
      "text": "iterations = (lenOfDelta - 1)/16; /* integer division */\ntemp = keyOld;\nfor (i = 0; i < iterations; i++) {\n    temp = MD5 (temp || random);\n    delta[i*16 .. (i*16)+15] =\n           temp XOR keyNew[i*16 .. (i*16)+15];\n}\ntemp = MD5 (temp || random);\ndelta[i*16 .. lenOfDelta-1] =\n       temp XOR keyNew[i*16 .. lenOfDelta-1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "The 'random' and 'delta' components are then concatenated as described above, and the resulting octet string is sent to the recipient as the new value of an instance of this object.",
      "ja": "次に、「ランダム」コンポーネントと「デルタ」コンポーネントが上記のように連結され、結果のオクテット文字列がこのオブジェクトのインスタンスの新しい値として受信者に送信されます。"
    },
    {
      "indent": 10,
      "text": "At the receiver side, when an instance of this object is set to a new value, then a new value of K is computed as follows:",
      "ja": "受信側では、このオブジェクトのインスタンスが新しい値に設定されると、Kの新しい値が次のように計算されます。"
    },
    {
      "indent": 11,
      "text": "- a temporary variable is initialized to the existing value of K; - if the length of the delta component is greater than L octets, then: - the random component is appended to the value of the temporary variable, and the result is input to the hash algorithm H to produce a digest value, and the temporary variable is set to this digest value; - the value of the temporary variable is XOR-ed with the first (next) L-octets (16 octets in case of MD5) of the delta component to produce the first (next) L-octets (16 octets in case of MD5) of the new value of K. - the above two steps are repeated until the unused portion of the delta component is L octets or less, - the random component is appended to the value of the temporary variable, and the result is input to the hash algorithm H to produce a digest value; - this digest value, truncated if necessary to be the same length as the unused portion of the delta component, is XOR-ed with the unused portion of the delta component to produce the (final portion of the) new value of K.",
      "ja": "- 一時変数は、Kの既存の値に初期化されます。 -デルタコンポーネントの長さがLオクテットより大きい場合：-ランダムコンポーネントが一時変数の値に追加され、その結果がハッシュアルゴリズムHに入力されて、ダイジェスト値と一時変数が生成されます。このダイジェスト値に設定されます。 -一時変数の値は、デルタコンポーネントの最初の（次の）Lオクテット（MD5の場合は16オクテット）とXORされて、最初の（次の）Lオクテット（MD5の場合は16オクテット）を生成します。 Kの新しい値-上記の2つのステップは、デルタ成分の未使用部分がLオクテット以下になるまで繰り返されます-ランダム成分が一時変数の値に追加され、結果がハッシュに入力されますダイジェスト値を生成するアルゴリズムH。 -このダイジェスト値は、必要に応じてデルタコンポーネントの未使用部分と同じ長さに切り捨てられ、デルタコンポーネントの未使用部分とXORされて、Kの新しい値（の最終部分）が生成されます。"
    },
    {
      "indent": 11,
      "text": "For example, using MD5 as the hash algorithm H:",
      "ja": "たとえば、ハッシュアルゴリズムHとしてMD5を使用します。"
    },
    {
      "indent": 14,
      "text": "iterations = (lenOfDelta - 1)/16; /* integer division */\ntemp = keyOld;\nfor (i = 0; i < iterations; i++) {\n    temp = MD5 (temp || random);\n    keyNew[i*16 .. (i*16)+15] =\n           temp XOR delta[i*16 .. (i*16)+15];\n}\ntemp = MD5 (temp || random);\nkeyNew[i*16 .. lenOfDelta-1] =\n       temp XOR delta[i*16 .. lenOfDelta-1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "The value of an object with this syntax, whenever it is retrieved by the management protocol, is always the zero length string.",
      "ja": "この構文のオブジェクトの値は、管理プロトコルによって取得されるときは常に、長さがゼロの文字列です。"
    },
    {
      "indent": 10,
      "text": "Note that the keyOld and keyNew are the localized keys.",
      "ja": "keyOldとkeyNewはローカライズされたキーであることに注意してください。"
    },
    {
      "indent": 4,
      "text": " Note that it is probably wise that when an SNMP entity sends a SetRequest to change a key, that it keeps a copy of the old key until it has confirmed that the key change actually succeeded. \" SYNTAX OCTET STRING",
      "ja": "SNMPエンティティがSetRequestを送信してキーを変更する場合、キーの変更が実際に成功したことを確認するまで古いキーのコピーを保持するのが賢明であることに注意してください。 \"構文オクテット文字列"
    },
    {
      "indent": 0,
      "text": "-- Statistics for the User-based Security Model **********************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStats         OBJECT IDENTIFIER ::= { usmMIBObjects 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsUnsupportedSecLevels OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of packets received by the SNMP\n                 engine which were dropped because they requested a\n                 securityLevel that was unknown to the SNMP engine\n                 or otherwise unavailable.\n                \"\n    ::= { usmStats 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsNotInTimeWindows OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of packets received by the SNMP\n                 engine which were dropped because they appeared\n                 outside of the authoritative SNMP engine's window.\n                \"\n    ::= { usmStats 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsUnknownUserNames OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of packets received by the SNMP\n                 engine which were dropped because they referenced a\n                 user that was not known to the SNMP engine.\n                \"\n    ::= { usmStats 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsUnknownEngineIDs OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of packets received by the SNMP\n                 engine which were dropped because they referenced an\n                 snmpEngineID that was not known to the SNMP engine.\n                \"\n    ::= { usmStats 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsWrongDigests OBJECT-TYPE",
      "ja": "usmStatsWrongDigests OBJECT-TYPE"
    },
    {
      "indent": 4,
      "text": "SYNTAX       Counter32\nMAX-ACCESS   read-only\nSTATUS       current\nDESCRIPTION \"The total number of packets received by the SNMP\n             engine which were dropped because they didn't\n             contain the expected digest value.\n            \"\n::= { usmStats 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmStatsDecryptionErrors OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION \"The total number of packets received by the SNMP\n                 engine which were dropped because they could not be\n                 decrypted.\n                \"\n    ::= { usmStats 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- The usmUser Group ************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUser          OBJECT IDENTIFIER ::= { usmMIBObjects 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserSpinLock  OBJECT-TYPE\n    SYNTAX       TestAndIncr\n    MAX-ACCESS   read-write\n    STATUS       current\n    DESCRIPTION \"An advisory lock used to allow several cooperating\n                 Command Generator Applications to coordinate their\n                 use of facilities to alter secrets in the\n                 usmUserTable.\n                \"\n    ::= { usmUser 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- The table of valid users for the User-based Security Model ********",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserTable OBJECT-TYPE SYNTAX SEQUENCE OF UsmUserEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The table of users configured in the SNMP engine's Local Configuration Datastore (LCD).",
      "ja": "usmUserTable OBJECT-TYPE SYNTAX SEQUENCE OF UsmUserEntry MAX-ACCESS not-accessible現在の説明「SNMPエンジンのローカル構成データストア（LCD）で構成されているユーザーのテーブル。"
    },
    {
      "indent": 17,
      "text": "To create a new user (i.e., to instantiate a new conceptual row in this table), it is recommended to follow this procedure:",
      "ja": "新しいユーザーを作成するには（つまり、この表の新しい概念的な行をインスタンス化するには）、次の手順に従うことをお勧めします。"
    },
    {
      "indent": 19,
      "text": "1) GET(usmUserSpinLock.0) and save in sValue.",
      "ja": "1）GET（usmUserSpinLock.0）して、sValueに保存します。"
    },
    {
      "indent": 19,
      "text": "2) SET(usmUserSpinLock.0=sValue, usmUserCloneFrom=templateUser, usmUserStatus=createAndWait) You should use a template user to clone from which has the proper auth/priv protocol defined.",
      "ja": "2）SET（usmUserSpinLock.0 = sValue、usmUserCloneFrom = templateUser、usmUserStatus = createAndWait）テンプレートユーザーを使用して、適切なauth / privプロトコルが定義されているクローンを作成する必要があります。"
    },
    {
      "indent": 17,
      "text": "If the new user is to use privacy:",
      "ja": "新しいユーザーがプライバシーを使用する場合："
    },
    {
      "indent": 19,
      "text": "3) generate the keyChange value based on the secret privKey of the clone-from user and the secret key to be used for the new user. Let us call this pkcValue. 4) GET(usmUserSpinLock.0) and save in sValue. 5) SET(usmUserSpinLock.0=sValue, usmUserPrivKeyChange=pkcValue usmUserPublic=randomValue1) 6) GET(usmUserPulic) and check it has randomValue1. If not, repeat steps 4-6.",
      "ja": "3）clone-fromユーザーの秘密のprivKeyと新しいユーザーに使用される秘密の鍵に基づいてkeyChange値を生成します。これをpkcValueと呼びます。 4）GET（usmUserSpinLock.0）して、sValueに保存します。 5）SET（usmUserSpinLock.0 = sValue、usmUserPrivKeyChange = pkcValue usmUserPublic = randomValue1）6）GET（usmUserPulic）で、randomValue1があることを確認します。そうでない場合は、手順4〜6を繰り返します。"
    },
    {
      "indent": 17,
      "text": "If the new user will never use privacy:",
      "ja": "新しいユーザーがプライバシーを使用しない場合："
    },
    {
      "indent": 19,
      "text": "7) SET(usmUserPrivProtocol=usmNoPrivProtocol)",
      "ja": "7）SET（usmUserPrivProtocol = usmNoPrivProtocol）"
    },
    {
      "indent": 17,
      "text": "If the new user is to use authentication:",
      "ja": "新しいユーザーが認証を使用する場合："
    },
    {
      "indent": 19,
      "text": "8) generate the keyChange value based on the secret authKey of the clone-from user and the secret key to be used for the new user. Let us call this akcValue. 9) GET(usmUserSpinLock.0) and save in sValue. 10) SET(usmUserSpinLock.0=sValue, usmUserAuthKeyChange=akcValue usmUserPublic=randomValue2) 11) GET(usmUserPulic) and check it has randomValue2. If not, repeat steps 9-11.",
      "ja": "8）clone-fromユーザーのシークレットauthKeyと新しいユーザーに使用されるシークレットキーに基づいてkeyChange値を生成します。これをakcValueと呼びましょう。 9）GET（usmUserSpinLock.0）して、sValueに保存します。 10）SET（usmUserSpinLock.0 = sValue、usmUserAuthKeyChange = akcValue usmUserPublic = randomValue2）11）GET（usmUserPulic）で、randomValue2があることを確認します。そうでない場合は、手順9〜11を繰り返します。"
    },
    {
      "indent": 17,
      "text": "If the new user will never use authentication:",
      "ja": "新しいユーザーが認証を使用しない場合："
    },
    {
      "indent": 19,
      "text": "12) SET(usmUserAuthProtocol=usmNoAuthProtocol)",
      "ja": "12）SET（usmUserAuthProtocol = usmNoAuthProtocol）"
    },
    {
      "indent": 17,
      "text": "Finally, activate the new user:",
      "ja": "最後に、新しいユーザーをアクティブ化します。"
    },
    {
      "indent": 19,
      "text": "13) SET(usmUserStatus=active)",
      "ja": "13）SET（usmUserStatus = active）"
    },
    {
      "indent": 17,
      "text": "The new user should now be available and ready to be used for SNMPv3 communication. Note however that access to MIB data must be provided via configuration of the SNMP-VIEW-BASED-ACM-MIB.",
      "ja": "これで新しいユーザーが利用可能になり、SNMPv3通信に使用できるようになります。ただし、MIBデータへのアクセスは、SNMP-VIEW-BASED-ACM-MIBの構成を介して提供する必要があることに注意してください。"
    },
    {
      "indent": 4,
      "text": "             The use of usmUserSpinlock is to avoid conflicts with\n             another SNMP command generator application which may\n             also be acting on the usmUserTable.\n            \"\n::= { usmUser 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserEntry     OBJECT-TYPE\n    SYNTAX       UsmUserEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION \"A user configured in the SNMP engine's Local\n                 Configuration Datastore (LCD) for the User-based\n                 Security Model.\n                \"\n    INDEX       { usmUserEngineID,\n                  usmUserName\n                }\n    ::= { usmUserTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "UsmUserEntry ::= SEQUENCE\n    {\n        usmUserEngineID         SnmpEngineID,\n        usmUserName             SnmpAdminString,\n        usmUserSecurityName     SnmpAdminString,\n        usmUserCloneFrom        RowPointer,\n        usmUserAuthProtocol     AutonomousType,\n        usmUserAuthKeyChange    KeyChange,\n        usmUserOwnAuthKeyChange KeyChange,\n        usmUserPrivProtocol     AutonomousType,\n        usmUserPrivKeyChange    KeyChange,\n        usmUserOwnPrivKeyChange KeyChange,\n        usmUserPublic           OCTET STRING,\n        usmUserStorageType      StorageType,\n        usmUserStatus           RowStatus\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserEngineID OBJECT-TYPE SYNTAX SnmpEngineID MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An SNMP engine's administratively-unique identifier.",
      "ja": "usmUserEngineID OBJECT-TYPE構文SnmpEngineID MAX-ACCESS not-accessibleステータス現在の説明「SNMPエンジンの管理上一意の識別子。"
    },
    {
      "indent": 17,
      "text": "In a simple agent, this value is always that agent's own snmpEngineID value.",
      "ja": "単純なエージェントでは、この値は常にそのエージェント自身のsnmpEngineID値です。"
    },
    {
      "indent": 17,
      "text": "The value can also take the value of the snmpEngineID of a remote SNMP engine with which this user can communicate.",
      "ja": "この値は、このユーザーが通信できるリモートSNMPエンジンのsnmpEngineIDの値を取ることもできます。"
    },
    {
      "indent": 4,
      "text": "            \"\n::= { usmUserEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserName OBJECT-TYPE SYNTAX SnmpAdminString (SIZE(1..32)) MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A human readable string representing the name of the user.",
      "ja": "usmUserName OBJECT-TYPE構文SnmpAdminString（SIZE（1..32））MAX-ACCESS not-accessibleステータス現在の説明「ユーザーの名前を表す人間が読める文字列。"
    },
    {
      "indent": 4,
      "text": "             This is the (User-based Security) Model dependent\n             security ID.\n            \"\n::= { usmUserEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserSecurityName OBJECT-TYPE SYNTAX SnmpAdminString MAX-ACCESS read-only STATUS current DESCRIPTION \"A human readable string representing the user in Security Model independent format.",
      "ja": "usmUserSecurityName OBJECT-TYPE構文SnmpAdminString MAX-ACCESS読み取り専用ステータス現在の説明「セキュリティモデルに依存しない形式でユーザーを表す人間が読める文字列。"
    },
    {
      "indent": 4,
      "text": "             The default transformation of the User-based Security\n             Model dependent security ID to the securityName and\n             vice versa is the identity function so that the\n             securityName is the same as the userName.\n            \"\n::= { usmUserEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserCloneFrom OBJECT-TYPE SYNTAX RowPointer MAX-ACCESS read-create STATUS current DESCRIPTION \"A pointer to another conceptual row in this usmUserTable. The user in this other conceptual row is called the clone-from user.",
      "ja": "usmUserCloneFrom OBJECT-TYPE構文RowPointer MAX-ACCESS read-create STATUS現在の説明「このusmUserTableの別の概念的な行へのポインタ。この別の概念的な行のユーザーは、クローン元ユーザーと呼ばれます。"
    },
    {
      "indent": 17,
      "text": "When a new user is created (i.e., a new conceptual row is instantiated in this table), the privacy and authentication parameters of the new user must be cloned from its clone-from user. These parameters are: - authentication protocol (usmUserAuthProtocol) - privacy protocol (usmUserPrivProtocol) They will be copied regardless of what the current value is.",
      "ja": "新しいユーザーが作成されると（つまり、このテーブルで新しい概念的な行がインスタンス化されます）、新しいユーザーのプライバシーと認証のパラメーターをその複製元ユーザーから複製する必要があります。これらのパラメーターは次のとおりです。-認証プロトコル（usmUserAuthProtocol）-プライバシープロトコル（usmUserPrivProtocol）これらは、現在の値に関係なくコピーされます。"
    },
    {
      "indent": 17,
      "text": "Cloning also causes the initial values of the secret authentication key (authKey) and the secret encryption key (privKey) of the new user to be set to the same values as the corresponding secrets of the clone-from user to allow the KeyChange process to occur as required during user creation.",
      "ja": "また、複製により、新しいユーザーの秘密認証キー（authKey）と秘密暗号化キー（privKey）の初期値が、複製元ユーザーの対応する秘密と同じ値に設定され、KeyChangeプロセスが発生します。ユーザー作成時に必要に応じて。"
    },
    {
      "indent": 17,
      "text": "The first time an instance of this object is set by a management operation (either at or after its instantiation), the cloning process is invoked. Subsequent writes are successful but invoke no action to be taken by the receiver. The cloning process fails with an 'inconsistentName' error if the conceptual row representing the clone-from user does not exist or is not in an active state when the cloning process is invoked.",
      "ja": "このオブジェクトのインスタンスが管理操作（インスタンス化時またはその後）によって初めて設定されるときに、クローン作成プロセスが呼び出されます。後続の書き込みは成功しますが、レシーバーが実行するアクションはありません。 clone-fromユーザーを表す概念的な行が存在しないか、複製プロセスが呼び出されたときにアクティブな状態でない場合、複製プロセスは「inconsistentName」エラーで失敗します。"
    },
    {
      "indent": 4,
      "text": "             When this object is read, the ZeroDotZero OID\n             is returned.\n            \"\n::= { usmUserEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserAuthProtocol OBJECT-TYPE SYNTAX AutonomousType MAX-ACCESS read-create STATUS current DESCRIPTION \"An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be authenticated, and if so, the type of authentication protocol which is used.",
      "ja": "usmUserAuthProtocol OBJECT-TYPE SYNTAX AutonomousType MAX-ACCESS read-create STATUS current DESCRIPTION \"usmUserEngineIDによって識別されたSNMPエンジンとの間でこのユーザーに代わって送信されたメッセージを認証できるかどうか、および認証できる場合は、認証プロトコルのタイプ使用されます。"
    },
    {
      "indent": 17,
      "text": "An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same conceptual row).",
      "ja": "このオブジェクトのインスタンスは、同じユーザーの他のオブジェクトインスタンスの作成と同時に作成されます（つまり、同じ概念的な行に最初のオブジェクトインスタンスを作成する設定操作の処理の一部として）。"
    },
    {
      "indent": 17,
      "text": "If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned.",
      "ja": "最初の設定操作（つまり、行の作成時）が不明またはサポートされていないプロトコルの値を設定しようとすると、「wrongValue」エラーが返されます。"
    },
    {
      "indent": 17,
      "text": "The value will be overwritten/set when a set operation is performed on the corresponding instance of usmUserCloneFrom.",
      "ja": "値は、usmUserCloneFromの対応するインスタンスで設定操作が実行されると上書き/設定されます。"
    },
    {
      "indent": 17,
      "text": "Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the usmNoAuthProtocol.",
      "ja": "いったんインスタンス化されると、このオブジェクトのこのようなインスタンスの値は、セット操作を介してのみusmNoAuthProtocolの値に変更できます。"
    },
    {
      "indent": 17,
      "text": "If a set operation tries to change the value of an existing instance of this object to any value other than usmNoAuthProtocol, then an 'inconsistentValue' error must be returned.",
      "ja": "設定操作でこのオブジェクトの既存のインスタンスの値をusmNoAuthProtocol以外の値に変更しようとすると、 'inconsistentValue'エラーが返されます。"
    },
    {
      "indent": 4,
      "text": "             If a set operation tries to set the value to the\n             usmNoAuthProtocol while the usmUserPrivProtocol value\n             in the same row is not equal to usmNoPrivProtocol,\n             then an 'inconsistentValue' error must be returned.\n             That means that an SNMP command generator application\n             must first ensure that the usmUserPrivProtocol is set\n             to the usmNoPrivProtocol value before it can set\n             the usmUserAuthProtocol value to usmNoAuthProtocol.\n            \"\nDEFVAL      { usmNoAuthProtocol }\n::= { usmUserEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserAuthKeyChange OBJECT-TYPE SYNTAX KeyChange -- typically (SIZE (0 | 32)) for HMACMD5 -- typically (SIZE (0 | 40)) for HMACSHA MAX-ACCESS read-create STATUS current DESCRIPTION \"An object, which when modified, causes the secret authentication key used for messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, to be modified via a one-way function.",
      "ja": "usmUserAuthKeyChange OBJECT-TYPE SYNTAX KeyChange-通常（SIZE（0 | 32））HMACMD5の場合-通常（SIZE（0 | 40））の場合HMACSHA MAX-ACCESS read-createステータス現在の説明 \"オブジェクトが変更されると、このユーザーに代わってusmUserEngineIDで識別されるSNMPエンジンとの間で送信されるメッセージに使用される秘密認証キー。一方向関数を介して変更されます。"
    },
    {
      "indent": 17,
      "text": "The associated protocol is the usmUserAuthProtocol. The associated secret key is the user's secret authentication key (authKey). The associated hash algorithm is the algorithm used by the user's usmUserAuthProtocol.",
      "ja": "関連するプロトコルは、usmUserAuthProtocolです。関連する秘密鍵は、ユーザーの秘密認証鍵（authKey）です。関連するハッシュアルゴリズムは、ユーザーのusmUserAuthProtocolによって使用されるアルゴリズムです。"
    },
    {
      "indent": 17,
      "text": "When creating a new user, it is an 'inconsistentName' error for a set operation to refer to this object unless it is previously or concurrently initialized through a set operation on the corresponding instance of usmUserCloneFrom.",
      "ja": "新しいユーザーを作成するとき、usmUserCloneFromの対応するインスタンスのセット操作によって以前または同時に初期化されていない限り、このオブジェクトを参照するセット操作の「不整合名」エラーです。"
    },
    {
      "indent": 17,
      "text": "When the value of the corresponding usmUserAuthProtocol is usmNoAuthProtocol, then a set is successful, but effectively is a no-op.",
      "ja": "対応するusmUser AuthProtocolの値がusm NoAuthプロトコルである場合、セットは成功しますが、事実上何もしません。"
    },
    {
      "indent": 17,
      "text": "When this object is read, the zero-length (empty) string is returned.",
      "ja": "このオブジェクトが読み取られると、長さゼロ（空）のストリングが返されます。"
    },
    {
      "indent": 17,
      "text": "The recommended way to do a key change is as follows:",
      "ja": "キーを変更するための推奨される方法は次のとおりです。"
    },
    {
      "indent": 19,
      "text": "1) GET(usmUserSpinLock.0) and save in sValue. 2) generate the keyChange value based on the old (existing) secret key and the new secret key, let us call this kcValue.",
      "ja": "1）GET（usmUserSpinLock.0）して、sValueに保存します。 2）古い（既存の）秘密鍵と新しい秘密鍵に基づいてkeyChange値を生成します。これをkcValueと呼びます。"
    },
    {
      "indent": 17,
      "text": "If you do the key change on behalf of another user:",
      "ja": "別のユーザーに代わってキーの変更を行う場合："
    },
    {
      "indent": 19,
      "text": "3) SET(usmUserSpinLock.0=sValue, usmUserAuthKeyChange=kcValue usmUserPublic=randomValue)",
      "ja": "3）SET（usmUserSpinLock.0 = sValue、usmUserAuthKeyChange = kcValue usmUserPublic = randomValue）"
    },
    {
      "indent": 17,
      "text": "If you do the key change for yourself:",
      "ja": "自分でキーの変更を行う場合："
    },
    {
      "indent": 19,
      "text": "4) SET(usmUserSpinLock.0=sValue, usmUserOwnAuthKeyChange=kcValue usmUserPublic=randomValue)",
      "ja": "4）SET（usmUserSpinLock.0 = sValue、usmUserOwnAuthKeyChange = kcValue usmUserPublic = randomValue）"
    },
    {
      "indent": 4,
      "text": "             If you get a response with error-status of noError,\n             then the SET succeeded and the new key is active.\n             If you do not get a response, then you can issue a\n             GET(usmUserPublic) and check if the value is equal\n             to the randomValue you did send in the SET. If so, then\n             the key change succeeded and the new key is active\n             (probably the response got lost). If not, then the SET\n             request probably never reached the target and so you\n             can start over with the procedure above.\n            \"\nDEFVAL      { ''H }    -- the empty string\n::= { usmUserEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserOwnAuthKeyChange OBJECT-TYPE SYNTAX KeyChange -- typically (SIZE (0 | 32)) for HMACMD5 -- typically (SIZE (0 | 40)) for HMACSHA MAX-ACCESS read-create STATUS current DESCRIPTION \"Behaves exactly as usmUserAuthKeyChange, with one notable difference: in order for the set operation to succeed, the usmUserName of the operation requester must match the usmUserName that indexes the row which is targeted by this operation. In addition, the USM security model must be used for this operation.",
      "ja": "usmUserOwnAuthKeyChange OBJECT-TYPE SYNTAX KeyChange-通常（SIZE（0 | 32））HMACMD5の場合-通常（SIZE（0 | 40））の場合HMACSHA MAX-ACCESS read-create STATUS現在の説明 \"usmUserAuthKeyChangeとまったく同じように動作し、1つの注目すべき違い：設定操作が成功するためには、操作リクエスタのusmUserNameが、この操作の対象となる行にインデックスを付けるusmUserNameと一致する必要があります。さらに、この操作にはUSMセキュリティモデルを使用する必要があります。"
    },
    {
      "indent": 17,
      "text": "The idea here is that access to this column can be public, since it will only allow a user to change his own secret authentication key (authKey). Note that this can only be done once the row is active.",
      "ja": "ここでの考え方は、ユーザーが自分の秘密認証キー（authKey）のみを変更できるため、この列へのアクセスは公開できるということです。これは、行がアクティブになったときにのみ実行できることに注意してください。"
    },
    {
      "indent": 17,
      "text": "When a set is received and the usmUserName of the requester is not the same as the umsUserName that indexes the row which is targeted by this operation, then a 'noAccess' error must be returned.",
      "ja": "セットが受信され、リクエスターのusmUserNameが、この操作の対象となる行にインデックスを付けるumsUserNameと同じでない場合、「noAccess」エラーが返される必要があります。"
    },
    {
      "indent": 4,
      "text": "             When a set is received and the security model in use\n             is not USM, then a 'noAccess' error must be returned.\n            \"\nDEFVAL      { ''H }    -- the empty string\n::= { usmUserEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserPrivProtocol OBJECT-TYPE SYNTAX AutonomousType MAX-ACCESS read-create STATUS current DESCRIPTION \"An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be protected from disclosure, and if so, the type of privacy protocol which is used.",
      "ja": "usmUserPrivProtocol OBJECT-TYPE SYNTAX AutonomousType MAX-ACCESS read-create STATUS current DESCRIPTION \"このユーザーに代わってusmUserEngineIDによって識別されたSNMPエンジンとの間で送受信されたメッセージを、開示から保護できるかどうかの表示。使用されるプライバシープロトコル。"
    },
    {
      "indent": 17,
      "text": "An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same conceptual row).",
      "ja": "このオブジェクトのインスタンスは、同じユーザーの他のオブジェクトインスタンスの作成と同時に作成されます（つまり、同じ概念的な行に最初のオブジェクトインスタンスを作成する設定操作の処理の一部として）。"
    },
    {
      "indent": 17,
      "text": "If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned.",
      "ja": "最初の設定操作（つまり、行の作成時）が不明またはサポートされていないプロトコルの値を設定しようとすると、「wrongValue」エラーが返されます。"
    },
    {
      "indent": 17,
      "text": "The value will be overwritten/set when a set operation is performed on the corresponding instance of usmUserCloneFrom.",
      "ja": "値は、usmUserCloneFromの対応するインスタンスで設定操作が実行されると上書き/設定されます。"
    },
    {
      "indent": 17,
      "text": "Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the usmNoPrivProtocol.",
      "ja": "いったんインスタンス化されると、このオブジェクトのそのようなインスタンスの値は、セット操作を介してのみusmNoPrivProtocolの値に変更できます。"
    },
    {
      "indent": 17,
      "text": "If a set operation tries to change the value of an existing instance of this object to any value other than usmNoPrivProtocol, then an 'inconsistentValue' error must be returned.",
      "ja": "セット操作がこのオブジェクトの既存のインスタンスの値をusmNoPrivProtocol以外の値に変更しようとすると、 'inconsistentValue'エラーが返されます。"
    },
    {
      "indent": 4,
      "text": "             Note that if any privacy protocol is used, then you\n             must also use an authentication protocol. In other\n             words, if usmUserPrivProtocol is set to anything else\n             than usmNoPrivProtocol, then the corresponding instance\n             of usmUserAuthProtocol cannot have a value of usmNoAuthProtocol. If it does, then an\n             'inconsistentValue' error must be returned.\n            \"\nDEFVAL      { usmNoPrivProtocol }\n::= { usmUserEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserPrivKeyChange OBJECT-TYPE SYNTAX KeyChange -- typically (SIZE (0 | 32)) for DES MAX-ACCESS read-create STATUS current DESCRIPTION \"An object, which when modified, causes the secret encryption key used for messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, to be modified via a one-way function.",
      "ja": "usmUserPrivKeyChange OBJECT-TYPE SYNTAX KeyChange-通常（SIZE（0 | 32））DES MAX-ACCESS読み取り-作成ステータス現在の説明「オブジェクトは、変更されると、このユーザーの代わりに送信されるメッセージに使用される秘密暗号化キーを生成しますusmUserEngineIDで識別されたSNMPエンジンとの間で、一方向関数を介して変更されます。"
    },
    {
      "indent": 17,
      "text": "The associated protocol is the usmUserPrivProtocol. The associated secret key is the user's secret privacy key (privKey). The associated hash algorithm is the algorithm used by the user's usmUserAuthProtocol.",
      "ja": "関連するプロトコルは、usmUserPrivProtocolです。関連する秘密鍵は、ユーザーの秘密プライバシー鍵（privKey）です。関連するハッシュアルゴリズムは、ユーザーのusmUserAuthProtocolによって使用されるアルゴリズムです。"
    },
    {
      "indent": 17,
      "text": "When creating a new user, it is an 'inconsistentName' error for a set operation to refer to this object unless it is previously or concurrently initialized through a set operation on the corresponding instance of usmUserCloneFrom.",
      "ja": "新しいユーザーを作成するとき、usmUserCloneFromの対応するインスタンスのセット操作によって以前または同時に初期化されていない限り、このオブジェクトを参照するセット操作の「不整合名」エラーです。"
    },
    {
      "indent": 17,
      "text": "When the value of the corresponding usmUserPrivProtocol is usmNoPrivProtocol, then a set is successful, but effectively is a no-op.",
      "ja": "対応するusmUserPrivProtocolの値がusmNoPrivProtocolである場合、セットは成功しますが、事実上何もしません。"
    },
    {
      "indent": 4,
      "text": "             When this object is read, the zero-length (empty)\n             string is returned.\n             See the description clause of usmUserAuthKeyChange for\n             a recommended procedure to do a key change.\n            \"\nDEFVAL      { ''H }    -- the empty string\n::= { usmUserEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserOwnPrivKeyChange OBJECT-TYPE SYNTAX KeyChange -- typically (SIZE (0 | 32)) for DES MAX-ACCESS read-create STATUS current DESCRIPTION \"Behaves exactly as usmUserPrivKeyChange, with one notable difference: in order for the Set operation to succeed, the usmUserName of the operation requester must match the usmUserName that indexes the row which is targeted by this operation. In addition, the USM security model must be used for this operation.",
      "ja": "usmUserOwnPrivKeyChange OBJECT-TYPE SYNTAX KeyChange-通常（SIZE（0 | 32））DES MAX-ACCESSの場合read-createステータス現在の説明操作のリクエスタのは、この操作の対象となる行にインデックスを付けるusmUserNameと一致する必要がありますさらに、この操作にはUSMセキュリティモデルを使用する必要があります。"
    },
    {
      "indent": 17,
      "text": "The idea here is that access to this column can be public, since it will only allow a user to change his own secret privacy key (privKey). Note that this can only be done once the row is active.",
      "ja": "ここでは、ユーザーが自分の秘密プライバシーキー（privKey）のみを変更できるため、この列へのアクセスを公開することができます。これは、行がアクティブになったときにのみ実行できることに注意してください。"
    },
    {
      "indent": 17,
      "text": "When a set is received and the usmUserName of the requester is not the same as the umsUserName that indexes the row which is targeted by this operation, then a 'noAccess' error must be returned.",
      "ja": "セットが受信され、リクエスターのusmUserNameが、この操作の対象となる行にインデックスを付けるumsUserNameと同じでない場合、「noAccess」エラーが返される必要があります。"
    },
    {
      "indent": 4,
      "text": "             When a set is received and the security model in use\n             is not USM, then a 'noAccess' error must be returned.\n            \"\nDEFVAL      { ''H }    -- the empty string\n::= { usmUserEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserPublic    OBJECT-TYPE\n    SYNTAX       OCTET STRING (SIZE(0..32))\n    MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION \"A publicly-readable value which can be written as part\n                 of the procedure for changing a user's secret\n                 authentication and/or privacy key, and later read to\n                 determine whether the change of the secret was\n                 effected.\n                \"\n    DEFVAL      { ''H }  -- the empty string\n    ::= { usmUserEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS current DESCRIPTION \"The storage type for this conceptual row.",
      "ja": "usmUserStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS current DESCRIPTION \"この概念的な行のストレージタイプ。"
    },
    {
      "indent": 17,
      "text": "Conceptual rows having the value 'permanent' must allow write-access at a minimum to:",
      "ja": "値が「永続的」である概念的な行は、少なくとも次のことを行うために書き込みアクセスを許可する必要があります。"
    },
    {
      "indent": 17,
      "text": "- usmUserAuthKeyChange, usmUserOwnAuthKeyChange and usmUserPublic for a user who employs authentication, and - usmUserPrivKeyChange, usmUserOwnPrivKeyChange and usmUserPublic for a user who employs privacy.",
      "ja": "- 認証を使用するユーザーの場合はusmUserAuthKeyChange、usmUserOwnAuthKeyChangeおよびusmUserPublic、プライバシーを使用するユーザーの場合はusmUserPrivKeyChange、usmUserOwnPrivKeyChangeおよびusmUserPublic"
    },
    {
      "indent": 17,
      "text": "Note that any user who employs authentication or privacy must allow its secret(s) to be updated and thus cannot be 'readOnly'.",
      "ja": "認証またはプライバシーを使用するユーザーは、シークレットの更新を許可する必要があるため、「読み取り専用」にすることはできません。"
    },
    {
      "indent": 17,
      "text": "If an initial set operation tries to set the value to 'readOnly' for a user who employs authentication or privacy, then an 'inconsistentValue' error must be returned. Note that if the value has been previously set (implicit or explicit) to any value, then the rules as defined in the StorageType Textual Convention apply.",
      "ja": "最初の設定操作で、認証またはプライバシーを使用するユーザーの値を「読み取り専用」に設定しようとすると、「inconsistentValue」エラーが返される必要があります。値が以前に（暗黙的または明示的に）任意の値に設定されている場合は、StorageType Textual Conventionで定義されているルールが適用されることに注意してください。"
    },
    {
      "indent": 4,
      "text": "             It is an implementation issue to decide if a SET for\n             a readOnly or permanent row is accepted at all. In some\n             contexts this may make sense, in others it may not. If\n             a SET for a readOnly or permanent row is not accepted\n             at all, then a 'wrongValue' error must be returned.\n            \"\nDEFVAL      { nonVolatile }\n::= { usmUserEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmUserStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this conceptual row.",
      "ja": "usmUserStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION「この概念的な行のステータス。"
    },
    {
      "indent": 17,
      "text": "Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the usmUserStatus column is 'notReady'.",
      "ja": "対応するすべての列のインスタンスが適切に構成されるまで、usmUserStatus列の対応するインスタンスの値は「notReady」です。"
    },
    {
      "indent": 17,
      "text": "In particular, a newly created row for a user who employs authentication, cannot be made active until the corresponding usmUserCloneFrom and usmUserAuthKeyChange have been set.",
      "ja": "特に、認証を使用するユーザー用に新しく作成された行は、対応するusmUserCloneFromおよびusmUserAuthKeyChangeが設定されるまでアクティブにできません。"
    },
    {
      "indent": 17,
      "text": "Further, a newly created row for a user who also employs privacy, cannot be made active until the usmUserPrivKeyChange has been set.",
      "ja": "さらに、プライバシーを使用するユーザー用に新しく作成された行は、usmUserPrivKeyChangeが設定されるまでアクティブにできません。"
    },
    {
      "indent": 17,
      "text": "The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified:",
      "ja": "RowStatus TC [RFC2579]では、このDESCRIPTION句で、この行の他のオブジェクトを変更できる状況を指定する必要があります。"
    },
    {
      "indent": 4,
      "text": "             The value of this object has no effect on whether\n             other objects in this conceptual row can be modified,\n             except for usmUserOwnAuthKeyChange and\n             usmUserOwnPrivKeyChange. For these 2 objects, the value of usmUserStatus MUST be active.\n            \"\n::= { usmUserEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Conformance Information *******************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "usmMIBCompliances OBJECT IDENTIFIER ::= { usmMIBConformance 1 }\nusmMIBGroups      OBJECT IDENTIFIER ::= { usmMIBConformance 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Compliance statements",
      "ja": "-コンプライアンスステートメント"
    },
    {
      "indent": 0,
      "text": "usmMIBCompliance MODULE-COMPLIANCE STATUS current DESCRIPTION \"The compliance statement for SNMP engines which implement the SNMP-USER-BASED-SM-MIB. \"",
      "ja": "usmMIBCompliance MODULE-COMPLIANCE STATUS current DESCRIPTION「SNMP-USER-BASED-SM-MIBを実装するSNMPエンジンのコンプライアンスステートメント。」"
    },
    {
      "indent": 4,
      "text": "MODULE -- this module MANDATORY-GROUPS { usmMIBBasicGroup }",
      "ja": "MODULE-このモジュールMANDATORY-GROUPS {usmMIBBasicGroup}"
    },
    {
      "indent": 8,
      "text": "OBJECT usmUserAuthProtocol MIN-ACCESS read-only DESCRIPTION \"Write access is not required.\"",
      "ja": "OBJECT usmUserAuthProtocol MIN-ACCESS読み取り専用説明「書き込みアクセスは必要ありません。」"
    },
    {
      "indent": 8,
      "text": "OBJECT usmUserPrivProtocol MIN-ACCESS read-only DESCRIPTION \"Write access is not required.\"",
      "ja": "オブジェクトusmUserPrivProtocol MIN-ACCESS読み取り専用説明「書き込みアクセスは必要となりません。」"
    },
    {
      "indent": 4,
      "text": "::= { usmMIBCompliances 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Units of compliance\nusmMIBBasicGroup OBJECT-GROUP\n    OBJECTS     {\n                  usmStatsUnsupportedSecLevels,\n                  usmStatsNotInTimeWindows,\n                  usmStatsUnknownUserNames,\n                  usmStatsUnknownEngineIDs,\n                  usmStatsWrongDigests,\n                  usmStatsDecryptionErrors,\n                  usmUserSpinLock,\n                  usmUserSecurityName,\n                  usmUserCloneFrom,\n                  usmUserAuthProtocol,\n                  usmUserAuthKeyChange,\n                  usmUserOwnAuthKeyChange,\n                  usmUserPrivProtocol,\n                  usmUserPrivKeyChange,\n                  usmUserOwnPrivKeyChange, usmUserPublic,\n                  usmUserStorageType,\n                  usmUserStatus\n                }\n    STATUS       current\n    DESCRIPTION \"A collection of objects providing for configuration\n                 of an SNMP engine which implements the SNMP\n                 User-based Security Model.\n                \"\n    ::= { usmMIBGroups 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "6. HMAC-MD5-96 Authentication Protocol",
      "section_title": true,
      "ja": "6. HMAC-MD5-96認証プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the HMAC-MD5-96 authentication protocol. This authentication protocol is the first defined for the User-based Security Model. It uses MD5 hash-function which is described in [RFC1321], in HMAC mode described in [RFC2104], truncating the output to 96 bits.",
      "ja": "このセクションでは、HMAC-MD5-96認証プロトコルについて説明します。この認証プロトコルは、ユーザーベースのセキュリティモデルに対して最初に定義されたものです。 [RFC1321]で説明されているMD5ハッシュ関数を使用し、[RFC2104]で説明されているHMACモードで、出力を96ビットに切り捨てます。"
    },
    {
      "indent": 3,
      "text": "This protocol is identified by usmHMACMD5AuthProtocol.",
      "ja": "このプロトコルは、usmHMACMD5AuthProtocolによって識別されます。"
    },
    {
      "indent": 3,
      "text": "Over time, other authentication protocols may be defined either as a replacement of this protocol or in addition to this protocol.",
      "ja": "時間の経過とともに、他の認証プロトコルは、このプロトコルの代替として、またはこのプロトコルに加えて定義される可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Mechanisms",
      "section_title": true,
      "ja": "6.1. メカニズム"
    },
    {
      "indent": 3,
      "text": "- In support of data integrity, a message digest algorithm is required. A digest is calculated over an appropriate portion of an SNMP message and included as part of the message sent to the recipient.",
      "ja": "- データの整合性をサポートするには、メッセージダイジェストアルゴリズムが必要です。ダイジェストは、SNMPメッセージの適切な部分で計算され、受信者に送信されるメッセージの一部として含まれます。"
    },
    {
      "indent": 3,
      "text": "- In support of data origin authentication and data integrity, a secret value is prepended to SNMP message prior to computing the digest; the calculated digest is partially inserted into the SNMP message prior to transmission, and the prepended value is not transmitted. The secret value is shared by all SNMP engines authorized to originate messages on behalf of the appropriate user.",
      "ja": "- データ発信元認証とデータ整合性をサポートするために、ダイジェストを計算する前に、SNMPメッセージにシークレット値が付加されます。計算されたダイジェストは、送信前にSNMPメッセージに部分的に挿入され、付加された値は送信されません。シークレット値は、適切なユーザーに代わってメッセージを発信することを許可されたすべてのSNMPエンジンによって共有されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Digest Authentication Mechanism",
      "section_title": true,
      "ja": "6.1.1. ダイジェスト認証メカニズム"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication Mechanism defined in this memo provides for:",
      "ja": "このメモで定義されているダイジェスト認証メカニズムは、以下を提供します："
    },
    {
      "indent": 3,
      "text": "- verification of the integrity of a received message, i.e., the message received is the message sent.",
      "ja": "- 受信したメッセージの整合性の検証、つまり、受信したメッセージは送信したメッセージです。"
    },
    {
      "indent": 5,
      "text": "The integrity of the message is protected by computing a digest over an appropriate portion of the message. The digest is computed by the originator of the message, transmitted with the message, and verified by the recipient of the message.",
      "ja": "メッセージの整合性は、メッセージの適切な部分でダイジェストを計算することによって保護されます。ダイジェストはメッセージの発信者によって計算され、メッセージとともに送信され、メッセージの受信者によって検証されます。"
    },
    {
      "indent": 3,
      "text": "- verification of the user on whose behalf the message was generated.",
      "ja": "- メッセージが生成されたユーザーの確認。"
    },
    {
      "indent": 5,
      "text": "A secret value known only to SNMP engines authorized to generate messages on behalf of a user is used in HMAC mode (see [RFC2104]). It also recommends the hash-function output used as Message Authentication Code, to be truncated.",
      "ja": "ユーザーに代わってメッセージを生成することを許可されたSNMPエンジンだけが知っている秘密の値がHMACモードで使用されます（[RFC2104]を参照）。また、メッセージ認証コードとして使用されるハッシュ関数の出力を切り捨てることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "This protocol uses the MD5 [RFC1321] message digest algorithm. A 128-bit MD5 digest is calculated in a special (HMAC) way over the designated portion of an SNMP message and the first 96 bits of this digest is included as part of the message sent to the recipient. The size of the digest carried in a message is 12 octets. The size of the private authentication key (the secret) is 16 octets. For the details see section 6.3.",
      "ja": "このプロトコルは、MD5 [RFC1321]メッセージダイジェストアルゴリズムを使用します。 128ビットのMD5ダイジェストは、SNMPメッセージの指定部分に対して特別な（HMAC）方法で計算され、このダイジェストの最初の96ビットは、受信者に送信されるメッセージの一部として含まれます。メッセージで運ばれるダイジェストのサイズは12オクテットです。秘密認証キー（シークレット）のサイズは16オクテットです。詳細については、セクション6.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2. Elements of the Digest Authentication Protocol",
      "section_title": true,
      "ja": "6.2. ダイジェスト認証プロトコルの要素"
    },
    {
      "indent": 3,
      "text": "This section contains definitions required to realize the authentication module defined in this section of this memo.",
      "ja": "このセクションには、このメモのこのセクションで定義されている認証モジュールを実現するために必要な定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Users",
      "section_title": true,
      "ja": "6.2.1. ユーザー"
    },
    {
      "indent": 3,
      "text": "Authentication using this authentication protocol makes use of a defined set of userNames. For any user on whose behalf a message must be authenticated at a particular SNMP engine, that SNMP engine must have knowledge of that user. An SNMP engine that wishes to communicate with another SNMP engine must also have knowledge of a user known to that engine, including knowledge of the applicable attributes of that user.",
      "ja": "この認証プロトコルを使用した認証では、定義された一連のuserNameを使用します。メッセージを特定のSNMPエンジンで認証する必要があるユーザーの場合、そのSNMPエンジンはそのユーザーの知識を持っている必要があります。別のSNMPエンジンと通信するSNMPエンジンは、そのエンジンに認識されているユーザーの知識（そのユーザーに適用可能な属性の知識を含む）も持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "A user and its attributes are defined as follows:",
      "ja": "ユーザーとその属性は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "<userName> A string representing the name of the user. <authKey> A user's secret key to be used when calculating a digest. It MUST be 16 octets long for MD5.",
      "ja": "<userName>ユーザーの名前を表す文字列。 <authKey>ダイジェストを計算するときに使用されるユーザーの秘密鍵。 MD5では16オクテットでなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.2. msgAuthoritativeEngineID",
      "section_title": true,
      "ja": "6.2.2. msgAuthoritativeEngineID"
    },
    {
      "indent": 3,
      "text": "The msgAuthoritativeEngineID value contained in an authenticated message specifies the authoritative SNMP engine for that particular message (see the definition of SnmpEngineID in the SNMP Architecture document [RFC3411]).",
      "ja": "認証されたメッセージに含まれるmsgAuthoritativeEngineID値は、その特定のメッセージの信頼できるSNMPエンジンを指定します（SNMPアーキテクチャドキュメント[RFC3411]のSnmpEngineIDの定義を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The user's (private) authentication key is normally different at each authoritative SNMP engine and so the snmpEngineID is used to select the proper key for the authentication process.",
      "ja": "ユーザーの（プライベート）認証キーは通常、信頼できるSNMPエンジンごとに異なるため、snmpEngineIDを使用して、認証プロセスに適切なキーを選択します。"
    },
    {
      "indent": 0,
      "text": "6.2.3. SNMP Messages Using this Authentication Protocol",
      "section_title": true,
      "ja": "6.2.3. この認証プロトコルを使用するSNMPメッセージ"
    },
    {
      "indent": 3,
      "text": "Messages using this authentication protocol carry a msgAuthenticationParameters field as part of the msgSecurityParameters. For this protocol, the msgAuthenticationParameters field is the serialized OCTET STRING representing the first 12 octets of the HMAC-MD5-96 output done over the wholeMsg.",
      "ja": "この認証プロトコルを使用するメッセージには、msgSecurityParametersの一部としてmsgAuthenticationParametersフィールドが含まれます。このプロトコルの場合、msgAuthenticationParametersフィールドは、HMS-MD5-96出力全体の最初の12オクテットを表す、シリアライズされたOCTET STRINGです。"
    },
    {
      "indent": 3,
      "text": "The digest is calculated over the wholeMsg so if a message is authenticated, that also means that all the fields in the message are intact and have not been tampered with.",
      "ja": "ダイジェストは全体のメッセージに対して計算されるため、メッセージが認証された場合、メッセージのすべてのフィールドが変更されておらず、改ざんされていないことも意味します。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Services provided by the HMAC-MD5-96 Authentication Module",
      "section_title": true,
      "ja": "6.2.4. HMAC-MD5-96認証モジュールによって提供されるサービス"
    },
    {
      "indent": 3,
      "text": "This section describes the inputs and outputs that the HMAC-MD5-96 Authentication module expects and produces when the User-based Security module calls the HMAC-MD5-96 Authentication module for services.",
      "ja": "このセクションでは、ユーザーベースのセキュリティモジュールがサービスのHMAC-MD5-96認証モジュールを呼び出すときに、HMAC-MD5-96認証モジュールが予期し、生成する入出力について説明します。"
    },
    {
      "indent": 0,
      "text": "6.2.4.1. Services for Generating an Outgoing SNMP Message",
      "section_title": true,
      "ja": "6.2.4.1. 発信SNMPメッセージを生成するためのサービス"
    },
    {
      "indent": 3,
      "text": "The HMAC-MD5-96 authentication protocol assumes that the selection of the authKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "HMAC-MD5-96認証プロトコルは、authKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the authentication module returns statusInformation and, if the message digest was correctly calculated, the wholeMsg with the digest inserted at the proper place. The abstract service primitive is:",
      "ja": "完了すると、認証モジュールはstatusInformationを返し、メッセージダイジェストが正しく計算された場合は、適切な場所に挿入されたダイジェストを含むholeMsg。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation = -- success or failure authenticateOutgoingMsg( IN authKey -- secret key for authentication IN wholeMsg -- unauthenticated complete message OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation =-成功または失敗authenticateOutgoingMsg（IN authKey-認証用の秘密鍵IN wholeMsg-認証されていない完全なメッセージOUT authenticationWholeMsg-完全に認証されたメッセージ）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the authentication process was successful. If not it is an indication of the problem.",
      "ja": "statusInformation認証プロセスが成功したかどうかを示します。そうでない場合は、問題の兆候です。"
    },
    {
      "indent": 3,
      "text": "authKey The secret key to be used by the authentication algorithm. The length of this key MUST be 16 octets.",
      "ja": "authKey認証アルゴリズムで使用される秘密鍵。このキーの長さは16オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The message to be authenticated.",
      "ja": "wholeMsg認証されるメッセージ。"
    },
    {
      "indent": 3,
      "text": "authenticatedWholeMsg The authenticated message (including inserted digest) on output.",
      "ja": "authenticationWholeMsg出力時の認証済みメッセージ（挿入されたダイジェストを含む）。"
    },
    {
      "indent": 3,
      "text": "Note, that authParameters field is filled by the authentication module and this module and this field should be already present in the wholeMsg before the Message Authentication Code (MAC) is generated.",
      "ja": "authParametersフィールドは認証モジュールとこのモジュールによって入力され、このフィールドはメッセージ認証コード（MAC）が生成される前に、WholeMsgにすでに存在している必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.2.4.2. Services for Processing an Incoming SNMP Message",
      "section_title": true,
      "ja": "6.2.4.2. 着信SNMPメッセージを処理するためのサービス"
    },
    {
      "indent": 3,
      "text": "The HMAC-MD5-96 authentication protocol assumes that the selection of the authKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "HMAC-MD5-96認証プロトコルは、authKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the authentication module returns statusInformation and, if the message digest was correctly calculated, the wholeMsg as it was processed. The abstract service primitive is:",
      "ja": "完了すると、認証モジュールはstatusInformationを返し、メッセージダイジェストが正しく計算された場合は、処理されたときの全体のメッセージです。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation = -- success or failure authenticateIncomingMsg( IN authKey -- secret key for authentication IN authParameters -- as received on the wire IN wholeMsg -- as received on the wire OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation =-成功または失敗authenticateIncomingMsg（IN authKey-認証用の秘密鍵IN authParameters-回線上で受信されたとおりINholeMsg-回線上で受信された場合OUT authenticationWholeMsg-完全な認証済みメッセージ）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the authentication process was successful. If not it is an indication of the problem.",
      "ja": "statusInformation認証プロセスが成功したかどうかを示します。そうでない場合は、問題の兆候です。"
    },
    {
      "indent": 3,
      "text": "authKey The secret key to be used by the authentication algorithm. The length of this key MUST be 16 octets.",
      "ja": "authKey認証アルゴリズムで使用される秘密鍵。このキーの長さは16オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "authParameters The authParameters from the incoming message.",
      "ja": "authParameters着信メッセージからのauthParameters。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The message to be authenticated on input and the authenticated message on output.",
      "ja": "wholeMsg入力時に認証されるメッセージと出力時に認証されたメッセージ。"
    },
    {
      "indent": 3,
      "text": "authenticatedWholeMsg The whole message after the authentication check is complete.",
      "ja": "authenticationWholeMsg認証チェックが完了した後のメッセージ全体。"
    },
    {
      "indent": 0,
      "text": "6.3. Elements of Procedure",
      "section_title": true,
      "ja": "6.3. 手順の要素"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for the HMAC-MD5-96 authentication protocol.",
      "ja": "このセクションでは、HMAC-MD5-96認証プロトコルの手順について説明します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Processing an Outgoing Message",
      "section_title": true,
      "ja": "6.3.1. 発信メッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must authenticate an outgoing message using the usmHMACMD5AuthProtocol.",
      "ja": "このセクションでは、usmHMACMD5AuthProtocolを使用して発信メッセージを認証する必要がある場合に、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) The msgAuthenticationParameters field is set to the serialization, according to the rules in [RFC3417], of an OCTET STRING containing 12 zero octets.",
      "ja": "1）msgAuthenticationParametersフィールドは、[RFC3417]の規則に従って、12個のゼロオクテットを含むOCTET STRINGのシリアル化に設定されます。"
    },
    {
      "indent": 3,
      "text": "2) From the secret authKey, two keys K1 and K2 are derived:",
      "ja": "2）秘密のauthKeyから、2つの鍵K1およびK2が導出されます。"
    },
    {
      "indent": 6,
      "text": "a) extend the authKey to 64 octets by appending 48 zero octets; save it as extendedAuthKey",
      "ja": "a) 48のゼロオクテットを追加して、authKeyを64オクテットに拡張します。それをextendedAuthKeyとして保存します。"
    },
    {
      "indent": 6,
      "text": "b) obtain IPAD by replicating the octet 0x36 64 times;",
      "ja": "b) オクテット0x36を64回複製してIPADを取得します。"
    },
    {
      "indent": 6,
      "text": "c) obtain K1 by XORing extendedAuthKey with IPAD;",
      "ja": "c) IPADでextendedAuthKeyをXORしてK1を取得します。"
    },
    {
      "indent": 6,
      "text": "d) obtain OPAD by replicating the octet 0x5C 64 times;",
      "ja": "d) オクテット0x5Cを64回複製してOPADを取得します。"
    },
    {
      "indent": 6,
      "text": "e) obtain K2 by XORing extendedAuthKey with OPAD.",
      "ja": "e) OPADでextendedAuthKeyをXORしてK2を取得します。"
    },
    {
      "indent": 3,
      "text": "3) Prepend K1 to the wholeMsg and calculate MD5 digest over it according to [RFC1321].",
      "ja": "3）WholeMsgにK1を付加し、[RFC1321]に従ってMD5ダイジェストを計算します。"
    },
    {
      "indent": 3,
      "text": "4) Prepend K2 to the result of the step 4 and calculate MD5 digest over it according to [RFC1321]. Take the first 12 octets of the final digest - this is Message Authentication Code (MAC).",
      "ja": "4）ステップ4の結果にK2を付加し、[RFC1321]に従ってMD5ダイジェストを計算します。最終ダイジェストの最初の12オクテットを取得します-これはメッセージ認証コード（MAC）です。"
    },
    {
      "indent": 3,
      "text": "5) Replace the msgAuthenticationParameters field with MAC obtained in the step 4.",
      "ja": "5）msgAuthenticationParametersフィールドを、手順4で取得したMACに置き換えます。"
    },
    {
      "indent": 3,
      "text": "6) The authenticatedWholeMsg is then returned to the caller together with statusInformation indicating success.",
      "ja": "6）次に、authenticationWholeMsgが、成功を示すstatusInformationとともに呼び出し元に返されます。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Processing an Incoming Message",
      "section_title": true,
      "ja": "6.3.2. 着信メッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must authenticate an incoming message using the usmHMACMD5AuthProtocol.",
      "ja": "このセクションでは、usmHMACMD5AuthProtocolを使用して着信メッセージを認証する必要がある場合に、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) If the digest received in the msgAuthenticationParameters field is not 12 octets long, then an failure and an errorIndication (authenticationError) is returned to the calling module.",
      "ja": "1）msgAuthenticationParametersフィールドで受信したダイジェストの長さが12オクテットでない場合、失敗とerrorIndication（authenticationError）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "2) The MAC received in the msgAuthenticationParameters field is saved.",
      "ja": "2）msgAuthenticationParametersフィールドで受信したMACが保存されます。"
    },
    {
      "indent": 3,
      "text": "3) The digest in the msgAuthenticationParameters field is replaced by the 12 zero octets.",
      "ja": "3）msgAuthenticationParametersフィールドのダイジェストは、12個のゼロオクテットに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "4) From the secret authKey, two keys K1 and K2 are derived:",
      "ja": "4）秘密のauthKeyから、2つの鍵K1およびK2が導出されます。"
    },
    {
      "indent": 6,
      "text": "a) extend the authKey to 64 octets by appending 48 zero octets; save it as extendedAuthKey",
      "ja": "a) 48のゼロオクテットを追加して、authKeyを64オクテットに拡張します。それをextendedAuthKeyとして保存します。"
    },
    {
      "indent": 6,
      "text": "b) obtain IPAD by replicating the octet 0x36 64 times;",
      "ja": "b) オクテット0x36を64回複製してIPADを取得します。"
    },
    {
      "indent": 6,
      "text": "c) obtain K1 by XORing extendedAuthKey with IPAD;",
      "ja": "c) IPADでextendedAuthKeyをXORしてK1を取得します。"
    },
    {
      "indent": 6,
      "text": "d) obtain OPAD by replicating the octet 0x5C 64 times;",
      "ja": "d) オクテット0x5Cを64回複製してOPADを取得します。"
    },
    {
      "indent": 6,
      "text": "e) obtain K2 by XORing extendedAuthKey with OPAD.",
      "ja": "e) OPADでextendedAuthKeyをXORしてK2を取得します。"
    },
    {
      "indent": 3,
      "text": "5) The MAC is calculated over the wholeMsg:",
      "ja": "5）MACは全体のメッセージに対して計算されます。"
    },
    {
      "indent": 6,
      "text": "a) prepend K1 to the wholeMsg and calculate the MD5 digest over it;",
      "ja": "a) WholeMsgにK1を付加し、MD5ダイジェストを計算します。"
    },
    {
      "indent": 6,
      "text": "b) prepend K2 to the result of step 5.a and calculate the MD5 digest over it;",
      "ja": "b) ステップ5.aの結果の前にK2を付加し、その上でMD5ダイジェストを計算します。"
    },
    {
      "indent": 6,
      "text": "c) first 12 octets of the result of step 5.b is the MAC.",
      "ja": "c) ステップ5.bの結果の最初の12オクテットはMACです。"
    },
    {
      "indent": 6,
      "text": "The msgAuthenticationParameters field is replaced with the MAC value that was saved in step 2.",
      "ja": "msgAuthenticationParametersフィールドは、手順2で保存されたMAC値に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "6) Then the newly calculated MAC is compared with the MAC saved in step 2. If they do not match, then an failure and an errorIndication (authenticationFailure) is returned to the calling module.",
      "ja": "6）次に、新しく計算されたMACがステップ2で保存されたMACと比較されます。それらが一致しない場合、失敗とerrorIndication（authenticationFailure）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "7) The authenticatedWholeMsg and statusInformation indicating success are then returned to the caller.",
      "ja": "7）その後、authenticatedWholeMsgおよび成功を示すstatusInformationが呼び出し元に返されます。"
    },
    {
      "indent": 0,
      "text": "7. HMAC-SHA-96 Authentication Protocol",
      "section_title": true,
      "ja": "7. HMAC-SHA-96認証プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the HMAC-SHA-96 authentication protocol. This protocol uses the SHA hash-function which is described in [SHA-NIST], in HMAC mode described in [RFC2104], truncating the output to 96 bits.",
      "ja": "このセクションでは、HMAC-SHA-96認証プロトコルについて説明します。このプロトコルは、[SHA-NIST]で説明されているSHAハッシュ関数を使用し、[RFC2104]で説明されているHMACモードで、出力を96ビットに切り捨てます。"
    },
    {
      "indent": 3,
      "text": "This protocol is identified by usmHMACSHAAuthProtocol.",
      "ja": "このプロトコルは、usmHMACSHAAuthProtocolによって識別されます。"
    },
    {
      "indent": 3,
      "text": "Over time, other authentication protocols may be defined either as a replacement of this protocol or in addition to this protocol.",
      "ja": "時間の経過とともに、他の認証プロトコルは、このプロトコルの代替として、またはこのプロトコルに加えて定義される可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.1. Mechanisms",
      "section_title": true,
      "ja": "7.1. メカニズム"
    },
    {
      "indent": 3,
      "text": "- In support of data integrity, a message digest algorithm is required. A digest is calculated over an appropriate portion of an SNMP message and included as part of the message sent to the recipient.",
      "ja": "- データの整合性をサポートするには、メッセージダイジェストアルゴリズムが必要です。ダイジェストは、SNMPメッセージの適切な部分で計算され、受信者に送信されるメッセージの一部として含まれます。"
    },
    {
      "indent": 3,
      "text": "- In support of data origin authentication and data integrity, a secret value is prepended to the SNMP message prior to computing the digest; the calculated digest is then partially inserted into the message prior to transmission. The prepended secret is not transmitted. The secret value is shared by all SNMP engines authorized to originate messages on behalf of the appropriate user.",
      "ja": "- データ発信元認証とデータ整合性をサポートするために、ダイジェストを計算する前に、秘密値がSNMPメッセージに付加されます。計算されたダイジェストは、送信前にメッセージに部分的に挿入されます。先頭に追加されたシークレットは送信されません。シークレット値は、適切なユーザーに代わってメッセージを発信することを許可されたすべてのSNMPエンジンによって共有されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Digest Authentication Mechanism",
      "section_title": true,
      "ja": "7.1.1. ダイジェスト認証メカニズム"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication Mechanism defined in this memo provides for:",
      "ja": "このメモで定義されているダイジェスト認証メカニズムは、以下を提供します："
    },
    {
      "indent": 3,
      "text": "- verification of the integrity of a received message, i.e., the message received is the message sent.",
      "ja": "- 受信したメッセージの整合性の検証、つまり、受信したメッセージは送信したメッセージです。"
    },
    {
      "indent": 5,
      "text": "The integrity of the message is protected by computing a digest over an appropriate portion of the message. The digest is computed by the originator of the message, transmitted with the message, and verified by the recipient of the message.",
      "ja": "メッセージの整合性は、メッセージの適切な部分でダイジェストを計算することによって保護されます。ダイジェストはメッセージの発信者によって計算され、メッセージとともに送信され、メッセージの受信者によって検証されます。"
    },
    {
      "indent": 3,
      "text": "- verification of the user on whose behalf the message was generated.",
      "ja": "- メッセージが生成されたユーザーの確認。"
    },
    {
      "indent": 5,
      "text": "A secret value known only to SNMP engines authorized to generate messages on behalf of a user is used in HMAC mode (see [RFC2104]). It also recommends the hash-function output used as Message Authentication Code, to be truncated.",
      "ja": "ユーザーに代わってメッセージを生成することを許可されたSNMPエンジンだけが知っている秘密の値がHMACモードで使用されます（[RFC2104]を参照）。また、メッセージ認証コードとして使用されるハッシュ関数の出力を切り捨てることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "This mechanism uses the SHA [SHA-NIST] message digest algorithm. A 160-bit SHA digest is calculated in a special (HMAC) way over the designated portion of an SNMP message and the first 96 bits of this digest is included as part of the message sent to the recipient. The size of the digest carried in a message is 12 octets. The size of the private authentication key (the secret) is 20 octets. For the details see section 7.3.",
      "ja": "このメカニズムは、SHA [SHA-NIST]メッセージダイジェストアルゴリズムを使用します。 160ビットのSHAダイジェストは、SNMPメッセージの指定部分に対して特別な（HMAC）方法で計算され、このダイジェストの最初の96ビットは、受信者に送信されるメッセージの一部として含まれます。メッセージで運ばれるダイジェストのサイズは12オクテットです。秘密認証キー（シークレット）のサイズは20オクテットです。詳細については、セクション7.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Elements of the HMAC-SHA-96 Authentication Protocol",
      "section_title": true,
      "ja": "7.2. HMAC-SHA-96認証プロトコルの要素"
    },
    {
      "indent": 3,
      "text": "This section contains definitions required to realize the authentication module defined in this section of this memo.",
      "ja": "このセクションには、このメモのこのセクションで定義されている認証モジュールを実現するために必要な定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Users",
      "section_title": true,
      "ja": "7.2.1. ユーザー"
    },
    {
      "indent": 3,
      "text": "Authentication using this authentication protocol makes use of a defined set of userNames. For any user on whose behalf a message must be authenticated at a particular SNMP engine, that SNMP engine must have knowledge of that user. An SNMP engine that wishes to communicate with another SNMP engine must also have knowledge of a user known to that engine, including knowledge of the applicable attributes of that user.",
      "ja": "この認証プロトコルを使用した認証では、定義された一連のuserNameを使用します。メッセージを特定のSNMPエンジンで認証する必要があるユーザーの場合、そのSNMPエンジンはそのユーザーの知識を持っている必要があります。別のSNMPエンジンと通信するSNMPエンジンは、そのエンジンに認識されているユーザーの知識（そのユーザーに適用可能な属性の知識を含む）も持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "A user and its attributes are defined as follows:",
      "ja": "ユーザーとその属性は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "<userName> A string representing the name of the user. <authKey> A user's secret key to be used when calculating a digest. It MUST be 20 octets long for SHA.",
      "ja": "<userName>ユーザーの名前を表す文字列。 <authKey>ダイジェストを計算するときに使用されるユーザーの秘密鍵。 SHAの場合は20オクテットでなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. msgAuthoritativeEngineID",
      "section_title": true,
      "ja": "7.2.2. msgAuthoritativeEngineID"
    },
    {
      "indent": 3,
      "text": "The msgAuthoritativeEngineID value contained in an authenticated message specifies the authoritative SNMP engine for that particular message (see the definition of SnmpEngineID in the SNMP Architecture document [RFC3411]).",
      "ja": "認証されたメッセージに含まれるmsgAuthoritativeEngineID値は、その特定のメッセージの信頼できるSNMPエンジンを指定します（SNMPアーキテクチャドキュメント[RFC3411]のSnmpEngineIDの定義を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The user's (private) authentication key is normally different at each authoritative SNMP engine and so the snmpEngineID is used to select the proper key for the authentication process.",
      "ja": "ユーザーの（プライベート）認証キーは通常、信頼できるSNMPエンジンごとに異なるため、snmpEngineIDを使用して、認証プロセスに適切なキーを選択します。"
    },
    {
      "indent": 0,
      "text": "7.2.3. SNMP Messages Using this Authentication Protocol",
      "section_title": true,
      "ja": "7.2.3. この認証プロトコルを使用するSNMPメッセージ"
    },
    {
      "indent": 3,
      "text": "Messages using this authentication protocol carry a msgAuthenticationParameters field as part of the msgSecurityParameters. For this protocol, the msgAuthenticationParameters field is the serialized OCTET STRING representing the first 12 octets of HMAC-SHA-96 output done over the wholeMsg.",
      "ja": "この認証プロトコルを使用するメッセージには、msgSecurityParametersの一部としてmsgAuthenticationParametersフィールドが含まれます。このプロトコルの場合、msgAuthenticationParametersフィールドは、HMS-SHA-96出力全体の最初の12オクテットを表す、シリアル化されたOCTET STRINGです。"
    },
    {
      "indent": 3,
      "text": "The digest is calculated over the wholeMsg so if a message is authenticated, that also means that all the fields in the message are intact and have not been tampered with.",
      "ja": "ダイジェストは全体のメッセージに対して計算されるため、メッセージが認証された場合、メッセージのすべてのフィールドが変更されておらず、改ざんされていないことも意味します。"
    },
    {
      "indent": 0,
      "text": "7.2.4. Services Provided by the HMAC-SHA-96 Authentication Module",
      "section_title": true,
      "ja": "7.2.4. HMAC-SHA-96認証モジュールによって提供されるサービス"
    },
    {
      "indent": 3,
      "text": "This section describes the inputs and outputs that the HMAC-SHA-96 Authentication module expects and produces when the User-based Security module calls the HMAC-SHA-96 Authentication module for services.",
      "ja": "このセクションでは、ユーザーベースのセキュリティモジュールがサービスのHMAC-SHA-96認証モジュールを呼び出すときに、HMAC-SHA-96認証モジュールが予期し、生成する入出力について説明します。"
    },
    {
      "indent": 0,
      "text": "7.2.4.1. Services for Generating an Outgoing SNMP Message",
      "section_title": true,
      "ja": "7.2.4.1. 発信SNMPメッセージを生成するためのサービス"
    },
    {
      "indent": 3,
      "text": "HMAC-SHA-96 authentication protocol assumes that the selection of the authKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "HMAC-SHA-96認証プロトコルは、authKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the authentication module returns statusInformation and, if the message digest was correctly calculated, the wholeMsg with the digest inserted at the proper place. The abstract service primitive is:",
      "ja": "完了すると、認証モジュールはstatusInformationを返し、メッセージダイジェストが正しく計算された場合は、適切な場所に挿入されたダイジェストを含むholeMsg。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation = -- success or failure authenticateOutgoingMsg( IN authKey -- secret key for authentication IN wholeMsg -- unauthenticated complete message OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation =-成功または失敗authenticateOutgoingMsg（IN authKey-認証用の秘密鍵IN wholeMsg-認証されていない完全なメッセージOUT authenticationWholeMsg-完全に認証されたメッセージ）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the authentication process was successful. If not it is an indication of the problem.",
      "ja": "statusInformation認証プロセスが成功したかどうかを示します。そうでない場合は、問題の兆候です。"
    },
    {
      "indent": 3,
      "text": "authKey The secret key to be used by the authentication algorithm. The length of this key MUST be 20 octets.",
      "ja": "authKey認証アルゴリズムで使用される秘密鍵。このキーの長さは20オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The message to be authenticated.",
      "ja": "wholeMsg認証されるメッセージ。"
    },
    {
      "indent": 3,
      "text": "authenticatedWholeMsg The authenticated message (including inserted digest) on output.",
      "ja": "authenticationWholeMsg出力時の認証済みメッセージ（挿入されたダイジェストを含む）。"
    },
    {
      "indent": 3,
      "text": "Note, that authParameters field is filled by the authentication module and this field should be already present in the wholeMsg before the Message Authentication Code (MAC) is generated.",
      "ja": "authParametersフィールドは認証モジュールによって入力され、このフィールドはメッセージ認証コード（MAC）が生成される前に、WholeMsgにすでに存在していることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.2.4.2. Services for Processing an Incoming SNMP Message",
      "section_title": true,
      "ja": "7.2.4.2. 着信SNMPメッセージを処理するためのサービス"
    },
    {
      "indent": 3,
      "text": "HMAC-SHA-96 authentication protocol assumes that the selection of the authKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "HMAC-SHA-96認証プロトコルは、authKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the authentication module returns statusInformation and, if the message digest was correctly calculated, the wholeMsg as it was processed. The abstract service primitive is:",
      "ja": "完了すると、認証モジュールはstatusInformationを返し、メッセージダイジェストが正しく計算された場合は、処理されたときの全体のメッセージです。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation = -- success or failure authenticateIncomingMsg( IN authKey -- secret key for authentication IN authParameters -- as received on the wire IN wholeMsg -- as received on the wire OUT authenticatedWholeMsg -- complete authenticated message )",
      "ja": "statusInformation =-成功または失敗authenticateIncomingMsg（IN authKey-認証用の秘密鍵IN authParameters-回線上で受信されたとおりINholeMsg-回線上で受信された場合OUT authenticationWholeMsg-完全な認証済みメッセージ）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of whether the authentication process was successful. If not it is an indication of the problem.",
      "ja": "statusInformation認証プロセスが成功したかどうかを示します。そうでない場合は、問題の兆候です。"
    },
    {
      "indent": 3,
      "text": "authKey The secret key to be used by the authentication algorithm. The length of this key MUST be 20 octets.",
      "ja": "authKey認証アルゴリズムで使用される秘密鍵。このキーの長さは20オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "authParameters The authParameters from the incoming message.",
      "ja": "authParameters着信メッセージからのauthParameters。"
    },
    {
      "indent": 3,
      "text": "wholeMsg The message to be authenticated on input and the authenticated message on output.",
      "ja": "wholeMsg入力時に認証されるメッセージと出力時に認証されたメッセージ。"
    },
    {
      "indent": 3,
      "text": "authenticatedWholeMsg The whole message after the authentication check is complete.",
      "ja": "authenticationWholeMsg認証チェックが完了した後のメッセージ全体。"
    },
    {
      "indent": 0,
      "text": "7.3. Elements of Procedure",
      "section_title": true,
      "ja": "7.3. 手順の要素"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for the HMAC-SHA-96 authentication protocol.",
      "ja": "このセクションでは、HMAC-SHA-96認証プロトコルの手順について説明します。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Processing an Outgoing Message",
      "section_title": true,
      "ja": "7.3.1. 発信メッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must authenticate an outgoing message using the usmHMACSHAAuthProtocol.",
      "ja": "このセクションでは、usmHMACSHAAuthProtocolを使用して発信メッセージを認証する必要がある場合に、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) The msgAuthenticationParameters field is set to the serialization, according to the rules in [RFC3417], of an OCTET STRING containing 12 zero octets.",
      "ja": "1）msgAuthenticationParametersフィールドは、[RFC3417]の規則に従って、12個のゼロオクテットを含むOCTET STRINGのシリアル化に設定されます。"
    },
    {
      "indent": 3,
      "text": "2) From the secret authKey, two keys K1 and K2 are derived:",
      "ja": "2）秘密のauthKeyから、2つの鍵K1およびK2が導出されます。"
    },
    {
      "indent": 6,
      "text": "a) extend the authKey to 64 octets by appending 44 zero octets; save it as extendedAuthKey",
      "ja": "a) 44のゼロオクテットを追加して、authKeyを64オクテットに拡張します。それをextendedAuthKeyとして保存します。"
    },
    {
      "indent": 6,
      "text": "b) obtain IPAD by replicating the octet 0x36 64 times;",
      "ja": "b) オクテット0x36を64回複製してIPADを取得します。"
    },
    {
      "indent": 6,
      "text": "c) obtain K1 by XORing extendedAuthKey with IPAD;",
      "ja": "c) IPADでextendedAuthKeyをXORしてK1を取得します。"
    },
    {
      "indent": 6,
      "text": "d) obtain OPAD by replicating the octet 0x5C 64 times;",
      "ja": "d) オクテット0x5Cを64回複製してOPADを取得します。"
    },
    {
      "indent": 6,
      "text": "e) obtain K2 by XORing extendedAuthKey with OPAD.",
      "ja": "e) OPADでextendedAuthKeyをXORしてK2を取得します。"
    },
    {
      "indent": 3,
      "text": "3) Prepend K1 to the wholeMsg and calculate the SHA digest over it according to [SHA-NIST].",
      "ja": "3）WholeMsgにK1を付加し、[SHA-NIST]に従ってS1ダイジェストを計算します。"
    },
    {
      "indent": 3,
      "text": "4) Prepend K2 to the result of the step 4 and calculate SHA digest over it according to [SHA-NIST]. Take the first 12 octets of the final digest - this is Message Authentication Code (MAC).",
      "ja": "4）ステップ4の結果にK2を付加し、[SHA-NIST]に従ってSHAダイジェストを計算します。最終ダイジェストの最初の12オクテットを取得します-これはメッセージ認証コード（MAC）です。"
    },
    {
      "indent": 3,
      "text": "5) Replace the msgAuthenticationParameters field with MAC obtained in the step 5.",
      "ja": "5）msgAuthenticationParametersフィールドを、手順5で取得したMACに置き換えます。"
    },
    {
      "indent": 3,
      "text": "6) The authenticatedWholeMsg is then returned to the caller together with statusInformation indicating success.",
      "ja": "6）次に、authenticationWholeMsgが、成功を示すstatusInformationとともに呼び出し元に返されます。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Processing an Incoming Message",
      "section_title": true,
      "ja": "7.3.2. 着信メッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must authenticate an incoming message using the usmHMACSHAAuthProtocol.",
      "ja": "このセクションでは、usmHMACSHAAuthProtocolを使用して着信メッセージを認証する必要がある場合に、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) If the digest received in the msgAuthenticationParameters field is not 12 octets long, then an failure and an errorIndication (authenticationError) is returned to the calling module.",
      "ja": "1）msgAuthenticationParametersフィールドで受信したダイジェストの長さが12オクテットでない場合、失敗とerrorIndication（authenticationError）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "2) The MAC received in the msgAuthenticationParameters field is saved.",
      "ja": "2）msgAuthenticationParametersフィールドで受信したMACが保存されます。"
    },
    {
      "indent": 3,
      "text": "3) The digest in the msgAuthenticationParameters field is replaced by the 12 zero octets.",
      "ja": "3）msgAuthenticationParametersフィールドのダイジェストは、12個のゼロオクテットに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "4) From the secret authKey, two keys K1 and K2 are derived:",
      "ja": "4）秘密のauthKeyから、2つの鍵K1およびK2が導出されます。"
    },
    {
      "indent": 6,
      "text": "a) extend the authKey to 64 octets by appending 44 zero octets; save it as extendedAuthKey",
      "ja": "a) 44のゼロオクテットを追加して、authKeyを64オクテットに拡張します。それをextendedAuthKeyとして保存します。"
    },
    {
      "indent": 6,
      "text": "b) obtain IPAD by replicating the octet 0x36 64 times;",
      "ja": "b) オクテット0x36を64回複製してIPADを取得します。"
    },
    {
      "indent": 6,
      "text": "c) obtain K1 by XORing extendedAuthKey with IPAD;",
      "ja": "c) IPADでextendedAuthKeyをXORしてK1を取得します。"
    },
    {
      "indent": 6,
      "text": "d) obtain OPAD by replicating the octet 0x5C 64 times;",
      "ja": "d) オクテット0x5Cを64回複製してOPADを取得します。"
    },
    {
      "indent": 6,
      "text": "e) obtain K2 by XORing extendedAuthKey with OPAD.",
      "ja": "e) OPADでextendedAuthKeyをXORしてK2を取得します。"
    },
    {
      "indent": 3,
      "text": "5) The MAC is calculated over the wholeMsg:",
      "ja": "5）MACは全体のメッセージに対して計算されます。"
    },
    {
      "indent": 6,
      "text": "a) prepend K1 to the wholeMsg and calculate the SHA digest over it;",
      "ja": "a) WholeMsgの前にK1を付加し、その上にSHAダイジェストを計算します。"
    },
    {
      "indent": 6,
      "text": "b) prepend K2 to the result of step 5.a and calculate the SHA digest over it;",
      "ja": "b) ステップ5.aの結果にK2を付加し、その上でSHAダイジェストを計算します。"
    },
    {
      "indent": 6,
      "text": "c) first 12 octets of the result of step 5.b is the MAC.",
      "ja": "c) ステップ5.bの結果の最初の12オクテットはMACです。"
    },
    {
      "indent": 6,
      "text": "The msgAuthenticationParameters field is replaced with the MAC value that was saved in step 2.",
      "ja": "msgAuthenticationParametersフィールドは、手順2で保存されたMAC値に置き換えられます。"
    },
    {
      "indent": 3,
      "text": "6) The the newly calculated MAC is compared with the MAC saved in step 2. If they do not match, then a failure and an errorIndication (authenticationFailure) are returned to the calling module.",
      "ja": "6）新しく計算されたMACは、ステップ2で保存されたMACと比較されます。それらが一致しない場合、失敗とerrorIndication（authenticationFailure）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "7) The authenticatedWholeMsg and statusInformation indicating success are then returned to the caller.",
      "ja": "7）その後、authenticatedWholeMsgおよび成功を示すstatusInformationが呼び出し元に返されます。"
    },
    {
      "indent": 0,
      "text": "8. CBC-DES Symmetric Encryption Protocol",
      "section_title": true,
      "ja": "8. CBC-DES対称暗号化プロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the CBC-DES Symmetric Encryption Protocol. This protocol is the first privacy protocol defined for the User-based Security Model.",
      "ja": "このセクションでは、CBC-DES対称暗号化プロトコルについて説明します。このプロトコルは、ユーザーベースのセキュリティモデル用に定義された最初のプライバシープロトコルです。"
    },
    {
      "indent": 3,
      "text": "This protocol is identified by usmDESPrivProtocol.",
      "ja": "このプロトコルは、usmDESPrivProtocolによって識別されます。"
    },
    {
      "indent": 3,
      "text": "Over time, other privacy protocols may be defined either as a replacement of this protocol or in addition to this protocol.",
      "ja": "今後、他のプライバシープロトコルは、このプロトコルの代替として、またはこのプロトコルに加えて定義される可能性があります。"
    },
    {
      "indent": 0,
      "text": "8.1. Mechanisms",
      "section_title": true,
      "ja": "8.1. メカニズム"
    },
    {
      "indent": 3,
      "text": "- In support of data confidentiality, an encryption algorithm is required. An appropriate portion of the message is encrypted prior to being transmitted. The User-based Security Model specifies that the scopedPDU is the portion of the message that needs to be encrypted.",
      "ja": "- データの機密性をサポートするには、暗号化アルゴリズムが必要です。メッセージの適切な部分は、送信される前に暗号化されます。ユーザーベースのセキュリティモデルは、scopedPDUがメッセージの暗号化が必要な部分であることを指定しています。"
    },
    {
      "indent": 3,
      "text": "- A secret value in combination with a timeliness value is used to create the en/decryption key and the initialization vector. The secret value is shared by all SNMP engines authorized to originate messages on behalf of the appropriate user.",
      "ja": "- 適時性値と組み合わせた秘密値を使用して、暗号化/復号化キーと初期化ベクトルが作成されます。シークレット値は、適切なユーザーに代わってメッセージを発信することを許可されたすべてのSNMPエンジンによって共有されます。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Symmetric Encryption Protocol",
      "section_title": true,
      "ja": "8.1.1. 対称暗号化プロトコル"
    },
    {
      "indent": 3,
      "text": "The Symmetric Encryption Protocol defined in this memo provides support for data confidentiality. The designated portion of an SNMP message is encrypted and included as part of the message sent to the recipient.",
      "ja": "このメモで定義されている対称暗号化プロトコルは、データの機密性をサポートします。 SNMPメッセージの指定部分は暗号化され、受信者に送信されるメッセージの一部として含まれます。"
    },
    {
      "indent": 3,
      "text": "Two organizations have published specifications defining the DES: the National Institute of Standards and Technology (NIST) [DES-NIST] and the American National Standards Institute [DES-ANSI]. There is a companion Modes of Operation specification for each definition ([DESO-NIST] and [DESO-ANSI], respectively).",
      "ja": "2つの組織がDESを定義する仕様を公開しています。NationalInstitute of Standards and Technology（NIST）[DES-NIST]とAmerican National Standards Institute [DES-ANSI]です。各定義（[DESO-NIST]および[DESO-ANSI]のそれぞれ）に対応する動作モードの仕様があります。"
    },
    {
      "indent": 3,
      "text": "The NIST has published three additional documents that implementors may find useful.",
      "ja": "NISTは、実装者が役立つと思われる3つの追加ドキュメントを公開しています。"
    },
    {
      "indent": 3,
      "text": "- There is a document with guidelines for implementing and using the DES, including functional specifications for the DES and its modes of operation [DESG-NIST].",
      "ja": "- DESおよびその動作モードの機能仕様を含む、DESの実装および使用に関するガイドラインが記載されたドキュメントがあります[DESG-NIST]。"
    },
    {
      "indent": 3,
      "text": "- There is a specification of a validation test suite for the DES [DEST-NIST]. The suite is designed to test all aspects of the DES and is useful for pinpointing specific problems.",
      "ja": "- DES [DEST-NIST]の検証テストスイートの仕様があります。このスイートは、DESのすべての側面をテストするように設計されており、特定の問題を特定するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "- There is a specification of a maintenance test for the DES [DESM-NIST]. The test utilizes a minimal amount of data and processing to test all components of the DES. It provides a simple yes-or-no indication of correct operation and is useful to run as part of an initialization step, e.g., when a computer re-boots.",
      "ja": "- DESの保守テストの仕様があります[DESM-NIST]。テストでは、最小限のデータと処理を使用して、DESのすべてのコンポーネントをテストします。これは、正しい操作の単純な「はい」または「いいえ」の表示を提供し、たとえばコンピューターが再起動するときなど、初期化ステップの一部として実行するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "8.1.1.1. DES key and Initialization Vector",
      "section_title": true,
      "ja": "8.1.1.1. DESキーと初期化ベクトル"
    },
    {
      "indent": 3,
      "text": "The first 8 octets of the 16-octet secret (private privacy key) are used as a DES key. Since DES uses only 56 bits, the Least Significant Bit in each octet is disregarded.",
      "ja": "The first 8 octets of the 16-octet secret (private privacy key) are used as a DES key. Since DES uses only 56 bits, the Least Significant Bit in each octet is disregarded."
    },
    {
      "indent": 3,
      "text": "The Initialization Vector for encryption is obtained using the following procedure.",
      "ja": "暗号化の初期化ベクトルは、次の手順で取得します。"
    },
    {
      "indent": 3,
      "text": "The last 8 octets of the 16-octet secret (private privacy key) are used as pre-IV.",
      "ja": "16オクテットのシークレット（プライベートプライバシーキー）の最後の8オクテットは、IV以前のバージョンとして使用されます。"
    },
    {
      "indent": 3,
      "text": "In order to ensure that the IV for two different packets encrypted by the same key, are not the same (i.e., the IV does not repeat) we need to \"salt\" the pre-IV with something unique per packet. An 8-octet string is used as the \"salt\". The concatenation of the generating SNMP engine's 32-bit snmpEngineBoots and a local 32-bit integer, that the encryption engine maintains, is input to the \"salt\". The 32-bit integer is initialized to an arbitrary value at boot time.",
      "ja": "同じキーで暗号化された2つの異なるパケットのIVが同じにならないようにする（つまり、IVが繰り返されない）ためには、パケットごとに一意の何かでpre-IVを「ソルト」する必要があります。 「塩」として8オクテットの文字列が使用されます。生成するSNMPエンジンの32ビットのsnmpEngineBootsと、暗号化エンジンが保持するローカルの32ビット整数を連結したものが「塩」に入力されます。 32ビット整数は、ブート時に任意の値に初期化されます。"
    },
    {
      "indent": 3,
      "text": "The 32-bit snmpEngineBoots is converted to the first 4 octets (Most Significant Byte first) of our \"salt\". The 32-bit integer is then converted to the last 4 octet (Most Significant Byte first) of our \"salt\". The resulting \"salt\" is then XOR-ed with the pre-IV to obtain the IV. The 8-octet \"salt\" is then put into the privParameters field encoded as an OCTET STRING. The \"salt\" integer is then modified. We recommend that it be incremented by one and wrap when it reaches the maximum value.",
      "ja": "32ビットのsnmpEngineBootsは、「塩」の最初の4オクテット（最上位バイトが最初）に変換されます。次に、32ビット整数は、「塩」の最後の4オクテット（最上位バイトが最初）に変換されます。次に、結果として得られる「塩」は、プレIVとXOR演算されて、IVが取得されます。次に、8オクテットの「塩」がOCTET STRINGとしてエンコードされたprivParametersフィールドに入力されます。次に、「塩」整数が変更されます。最大値に達したときに1ずつ増やしてラップすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "How exactly the value of the \"salt\" (and thus of the IV) varies, is an implementation issue, as long as the measures are taken to avoid producing a duplicate IV.",
      "ja": "重複したIVの生成を回避するための対策が講じられている限り、「塩」（したがってIVの値）がどの程度正確に変化するかは、実装の問題です。"
    },
    {
      "indent": 3,
      "text": "The \"salt\" must be placed in the privParameters field to enable the receiving entity to compute the correct IV and to decrypt the message.",
      "ja": "「塩」は、受信エンティティが正しいIVを計算してメッセージを復号化できるように、privParametersフィールドに配置する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.1.2. Data Encryption",
      "section_title": true,
      "ja": "8.1.1.2. データ暗号化"
    },
    {
      "indent": 3,
      "text": "The data to be encrypted is treated as sequence of octets. Its length should be an integral multiple of 8 - and if it is not, the data is padded at the end as necessary. The actual pad value is irrelevant.",
      "ja": "暗号化されるデータは、オクテットのシーケンスとして扱われます。その長さは8の整数倍である必要があります。そうでない場合、データは必要に応じて末尾に埋め込まれます。実際のパッド値は関係ありません。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in Cipher Block Chaining mode.",
      "ja": "データは暗号化ブロックチェーンモードで暗号化されます。"
    },
    {
      "indent": 3,
      "text": "The plaintext is divided into 64-bit blocks.",
      "ja": "平文は64ビットのブロックに分割されます。"
    },
    {
      "indent": 3,
      "text": "The plaintext for each block is XOR-ed with the ciphertext of the previous block, the result is encrypted and the output of the encryption is the ciphertext for the block. This procedure is repeated until there are no more plaintext blocks.",
      "ja": "各ブロックの平文は前のブロックの暗号文とXORされ、結果は暗号化され、暗号化の出力はブロックの暗号文です。この手順は、平文ブロックがなくなるまで繰り返されます。"
    },
    {
      "indent": 3,
      "text": "For the very first block, the Initialization Vector is used instead of the ciphertext of the previous block.",
      "ja": "最初のブロックでは、前のブロックの暗号文の代わりに初期化ベクトルが使用されます。"
    },
    {
      "indent": 0,
      "text": "8.1.1.3. Data Decryption",
      "section_title": true,
      "ja": "8.1.1.3. データの復号化"
    },
    {
      "indent": 3,
      "text": "Before decryption, the encrypted data length is verified. If the length of the OCTET STRING to be decrypted is not an integral multiple of 8 octets, the decryption process is halted and an appropriate exception noted. When decrypting, the padding is ignored.",
      "ja": "復号化する前に、暗号化されたデータ長が検証されます。復号化されるOCTET STRINGの長さが8オクテットの整数倍でない場合、復号化プロセスは停止され、適切な例外が通知されます。復号化するとき、パディングは無視されます。"
    },
    {
      "indent": 3,
      "text": "The first ciphertext block is decrypted, the decryption output is XOR-ed with the Initialization Vector, and the result is the first plaintext block.",
      "ja": "最初の暗号文ブロックが復号化され、復号化出力が初期化ベクトルとXORされ、結果が最初の平文ブロックになります。"
    },
    {
      "indent": 3,
      "text": "For each subsequent block, the ciphertext block is decrypted, the decryption output is XOR-ed with the previous ciphertext block and the result is the plaintext block.",
      "ja": "後続のブロックごとに、暗号文ブロックが復号化され、復号化出力は前の暗号文ブロックとXORされ、結果は平文ブロックになります。"
    },
    {
      "indent": 0,
      "text": "8.2. Elements of the DES Privacy Protocol",
      "section_title": true,
      "ja": "8.2. DESプライバシープロトコルの要素"
    },
    {
      "indent": 3,
      "text": "This section contains definitions required to realize the privacy module defined by this memo.",
      "ja": "このセクションには、このメモで定義されているプラ​​イバシーモジュールを実現するために必要な定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Users",
      "section_title": true,
      "ja": "8.2.1. ユーザー"
    },
    {
      "indent": 3,
      "text": "Data en/decryption using this Symmetric Encryption Protocol makes use of a defined set of userNames. For any user on whose behalf a message must be en/decrypted at a particular SNMP engine, that SNMP engine must have knowledge of that user. An SNMP engine that wishes to communicate with another SNMP engine must also have knowledge of a user known to that SNMP engine, including knowledge of the applicable attributes of that user.",
      "ja": "この対称暗号化プロトコルを使用したデータ暗号化/復号化は、定義された一連のuserNameを利用します。特定のSNMPエンジンでメッセージを暗号化または復号化する必要があるユーザーの場合、そのSNMPエンジンはそのユーザーの知識を持っている必要があります。別のSNMPエンジンとの通信を希望するSNMPエンジンは、そのSNMPエンジンが認識しているユーザーの知識（そのユーザーの適用可能な属性の知識を含む）も持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "A user and its attributes are defined as follows:",
      "ja": "ユーザーとその属性は次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "<userName> An octet string representing the name of the user.",
      "ja": "<userName>ユーザーの名前を表すオクテット文字列。"
    },
    {
      "indent": 3,
      "text": "<privKey> A user's secret key to be used as input for the DES key and IV. The length of this key MUST be 16 octets.",
      "ja": "<privKey> DES鍵およびIVの入力として使用されるユーザーの秘密鍵。このキーの長さは16オクテットでなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.2. msgAuthoritativeEngineID",
      "section_title": true,
      "ja": "8.2.2. msgAuthoritativeEngineID"
    },
    {
      "indent": 3,
      "text": "The msgAuthoritativeEngineID value contained in an authenticated message specifies the authoritative SNMP engine for that particular message (see the definition of SnmpEngineID in the SNMP Architecture document [RFC3411]).",
      "ja": "認証されたメッセージに含まれるmsgAuthoritativeEngineID値は、その特定のメッセージの信頼できるSNMPエンジンを指定します（SNMPアーキテクチャドキュメント[RFC3411]のSnmpEngineIDの定義を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The user's (private) privacy key is normally different at each authoritative SNMP engine and so the snmpEngineID is used to select the proper key for the en/decryption process.",
      "ja": "ユーザーの（プライベート）プライバシーキーは通常、信頼できるSNMPエンジンごとに異なるため、snmpEngineIDを使用して、暗号化/復号化プロセスに適切なキーを選択します。"
    },
    {
      "indent": 0,
      "text": "8.2.3. SNMP Messages Using this Privacy Protocol",
      "section_title": true,
      "ja": "8.2.3. このプライバシープロトコルを使用したSNMPメッセージ"
    },
    {
      "indent": 3,
      "text": "Messages using this privacy protocol carry a msgPrivacyParameters field as part of the msgSecurityParameters. For this protocol, the msgPrivacyParameters field is the serialized OCTET STRING representing the \"salt\" that was used to create the IV.",
      "ja": "Messages using this privacy protocol carry a msgPrivacyParameters field as part of the msgSecurityParameters. For this protocol, the msgPrivacyParameters field is the serialized OCTET STRING representing the \"salt\" that was used to create the IV."
    },
    {
      "indent": 0,
      "text": "8.2.4. Services Provided by the DES Privacy Module",
      "section_title": true,
      "ja": "8.2.4. DESプライバシーモジュールによって提供されるサービス"
    },
    {
      "indent": 3,
      "text": "This section describes the inputs and outputs that the DES Privacy module expects and produces when the User-based Security module invokes the DES Privacy module for services.",
      "ja": "このセクションでは、ユーザーベースのセキュリティモジュールがサービスのためにDESプライバシーモジュールを呼び出すときに、DESプライバシーモジュールが予期し、生成する入出力について説明します。"
    },
    {
      "indent": 0,
      "text": "8.2.4.1. Services for Encrypting Outgoing Data",
      "section_title": true,
      "ja": "8.2.4.1. 送信データを暗号化するためのサービス"
    },
    {
      "indent": 3,
      "text": "This DES privacy protocol assumes that the selection of the privKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "このDESプライバシープロトコルは、privKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the privacy module returns statusInformation and, if the encryption process was successful, the encryptedPDU and the msgPrivacyParameters encoded as an OCTET STRING. The abstract service primitive is: statusInformation = -- success of failure encryptData( IN encryptKey -- secret key for encryption IN dataToEncrypt -- data to encrypt (scopedPDU) OUT encryptedData -- encrypted data (encryptedPDU) OUT privParameters -- filled in by service provider )",
      "ja": "完了すると、プライバシーモジュールはstatusInformationを返し、暗号化プロセスが成功した場合は、encryptedPDUおよびmsgPrivacyParametersがOCTET STRINGとしてエンコードされます。抽象サービスプリミティブは次のとおりです。statusInformation =-失敗の成功encryptData（IN encryptKey-暗号化の秘密鍵IN dataToEncrypt-暗号化するデータ（scopedPDU）OUT encryptedData-暗号化データ（encryptedPDU）OUT privParameters-サービスによって入力プロバイダー）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication of the success or failure of the encryption process. In case of failure, it is an indication of the error.",
      "ja": "statusInformation暗号化プロセスの成功または失敗を示します。失敗した場合は、エラーを示しています。"
    },
    {
      "indent": 3,
      "text": "encryptKey The secret key to be used by the encryption algorithm. The length of this key MUST be 16 octets.",
      "ja": "encryptKey暗号化アルゴリズムで使用される秘密鍵。このキーの長さは16オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "dataToEncrypt The data that must be encrypted.",
      "ja": "dataToEncrypt暗号化する必要があるデータ。"
    },
    {
      "indent": 3,
      "text": "encryptedData The encrypted data upon successful completion.",
      "ja": "encryptedData正常に完了したときの暗号化されたデータ。"
    },
    {
      "indent": 3,
      "text": "privParameters The privParameters encoded as an OCTET STRING.",
      "ja": "privParameters OCTET STRINGとしてエンコードされたprivParameters。"
    },
    {
      "indent": 0,
      "text": "8.2.4.2. Services for Decrypting Incoming Data",
      "section_title": true,
      "ja": "8.2.4.2. 受信データを復号化するためのサービス"
    },
    {
      "indent": 3,
      "text": "This DES privacy protocol assumes that the selection of the privKey is done by the caller and that the caller passes the secret key to be used.",
      "ja": "このDESプライバシープロトコルは、privKeyの選択が呼び出し元によって行われ、呼び出し元が使用する秘密鍵を渡すことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Upon completion the privacy module returns statusInformation and, if the decryption process was successful, the scopedPDU in plain text. The abstract service primitive is:",
      "ja": "完了すると、プライバシーモジュールはstatusInformationを返し、復号化プロセスが成功した場合は、scopedPDUをプレーンテキストで返します。抽象サービスプリミティブは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation = decryptData( IN decryptKey -- secret key for decryption IN privParameters -- as received on the wire IN encryptedData -- encrypted data (encryptedPDU) OUT decryptedData -- decrypted data (scopedPDU) )",
      "ja": "statusInformation = decryptData（IN decodeKey-復号化の秘密鍵IN privParameters-回線で受信したとおりIN encryptedData-暗号化データ（encryptedPDU）OUT復号化データ-復号化データ（scopedPDU））"
    },
    {
      "indent": 3,
      "text": "The abstract data elements are:",
      "ja": "抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation An indication whether the data was successfully decrypted and if not an indication of the error.",
      "ja": "statusInformationデータが正常に復号化されたかどうかを示し、そうでない場合はエラーを示します。"
    },
    {
      "indent": 3,
      "text": "decryptKey The secret key to be used by the decryption algorithm. The length of this key MUST be 16 octets.",
      "ja": "decryptKey復号化アルゴリズムで使用される秘密鍵。このキーの長さは16オクテットでなければなりません。"
    },
    {
      "indent": 3,
      "text": "privParameters The \"salt\" to be used to calculate the IV.",
      "ja": "privParameters IVの計算に使用される「塩」。"
    },
    {
      "indent": 3,
      "text": "encryptedData The data to be decrypted.",
      "ja": "encryptedData復号化されるデータ。"
    },
    {
      "indent": 3,
      "text": "decryptedData The decrypted data.",
      "ja": "解読されたデータ解読されたデータ。"
    },
    {
      "indent": 0,
      "text": "8.3. Elements of Procedure.",
      "ja": "8.3. 手順の要素。"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for the DES privacy protocol.",
      "ja": "このセクションでは、DESプライバシープロトコルの手順について説明します。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Processing an Outgoing Message",
      "section_title": true,
      "ja": "8.3.1. 発信メッセージの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must encrypt part of an outgoing message using the usmDESPrivProtocol.",
      "ja": "This section describes the procedure followed by an SNMP engine whenever it must encrypt part of an outgoing message using the usmDESPrivProtocol."
    },
    {
      "indent": 3,
      "text": "1) The secret cryptKey is used to construct the DES encryption key, the \"salt\" and the DES pre-IV (from which the IV is computed as described in section 8.1.1.1).",
      "ja": "1）シークレットcr​​yptKeyは、DES暗号化キー、「ソルト」、およびDES pre-IV（セクション8.1.1.1で説明されているようにIVが計算される）を構築するために使用されます。"
    },
    {
      "indent": 3,
      "text": "2) The privParameters field is set to the serialization according to the rules in [RFC3417] of an OCTET STRING representing the \"salt\" string.",
      "ja": "2）privParametersフィールドは、「塩」文字列を表すOCTET STRINGの[RFC3417]の規則に従って、シリアル化に設定されます。"
    },
    {
      "indent": 3,
      "text": "3) The scopedPDU is encrypted (as described in section 8.1.1.2) and the encrypted data is serialized according to the rules in [RFC3417] as an OCTET STRING.",
      "ja": "3）scopedPDUは暗号化され（セクション8.1.1.2で説明）、暗号化されたデータは[RFC3417]の規則に従ってOCTET STRINGとしてシリアル化されます。"
    },
    {
      "indent": 3,
      "text": "4) The serialized OCTET STRING representing the encrypted scopedPDU together with the privParameters and statusInformation indicating success is returned to the calling module.",
      "ja": "4）暗号化されたscopedPDUを表すシリアル化されたOCTET STRINGは、成功を示すprivParametersおよびstatusInformationとともに、呼び出し側モジュールに返されます。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Processing an Incoming Message",
      "section_title": true,
      "ja": "8.3.2. Processing an Incoming Message"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by an SNMP engine whenever it must decrypt part of an incoming message using the usmDESPrivProtocol.",
      "ja": "このセクションでは、usmDESPrivProtocolを使用して着信メッセージの一部を復号化する必要がある場合に、SNMPエンジンが従う手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1) If the privParameters field is not an 8-octet OCTET STRING, then an error indication (decryptionError) is returned to the calling module.",
      "ja": "1) If the privParameters field is not an 8-octet OCTET STRING, then an error indication (decryptionError) is returned to the calling module."
    },
    {
      "indent": 3,
      "text": "2) The \"salt\" is extracted from the privParameters field.",
      "ja": "2）「塩」は、privParametersフィールドから抽出されます。"
    },
    {
      "indent": 3,
      "text": "3) The secret cryptKey and the \"salt\" are then used to construct the DES decryption key and pre-IV (from which the IV is computed as described in section 8.1.1.1).",
      "ja": "3）次に、秘密のcryptKeyと「ソルト」を使用して、DES復号鍵とIVより前（IVは8.1.1.1で説明されているように計算される）を構築します。"
    },
    {
      "indent": 3,
      "text": "4) The encryptedPDU is then decrypted (as described in section 8.1.1.3).",
      "ja": "4）次に、暗号化されたPDUが復号化されます（セクション8.1.1.3で説明）。"
    },
    {
      "indent": 3,
      "text": "5) If the encryptedPDU cannot be decrypted, then an error indication (decryptionError) is returned to the calling module.",
      "ja": "5）encryptedPDUを復号化できない場合、エラー表示（decryptionError）が呼び出し側モジュールに返されます。"
    },
    {
      "indent": 3,
      "text": "6) The decrypted scopedPDU and statusInformation indicating success are returned to the calling module.",
      "ja": "6）復号化されたscopedPDUと成功を示すstatusInformationが呼び出しモジュールに返されます。"
    },
    {
      "indent": 0,
      "text": "9. Intellectual Property",
      "section_title": true,
      "ja": "9. Intellectual Property"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるまたは適用されない範囲に関して、いかなる立場も取らない。利用可能。また、そのような権利を特定するために何らかの努力をしたことも表していません。標準化過程および標準化関連文書の権利に関するIETFの手順に関する情報は、BCP-11にあります。公開のために利用可能にされた権利の主張および利用可能にされるライセンスの保証のコピー、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用の許可を得ようとした試みの結果を入手できます。 IETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、この規格を実践するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IETF Executive Directorに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the result of the efforts of the SNMPv3 Working Group. Some special thanks are in order to the following SNMPv3 WG members:",
      "ja": "このドキュメントは、SNMPv3ワーキンググループの努力の成果です。以下のSNMPv3 WGメンバーに感謝します。"
    },
    {
      "indent": 6,
      "text": "Harald Tveit Alvestrand (Maxware) Dave Battle (SNMP Research, Inc.) Alan Beard (Disney Worldwide Services) Paul Berrevoets (SWI Systemware/Halcyon Inc.) Martin Bjorklund (Ericsson) Uri Blumenthal (IBM T.J. Watson Research Center) Jeff Case (SNMP Research, Inc.) John Curran (BBN) Mike Daniele (Compaq Computer Corporation)) T. Max Devlin (Eltrax Systems) John Flick (Hewlett Packard) Rob Frye (MCI) Wes Hardaker (U.C.Davis, Information Technology - D.C.A.S.) David Harrington (Cabletron Systems Inc.) Lauren Heintz (BMC Software, Inc.) N.C. Hien (IBM T.J. Watson Research Center) Michael Kirkham (InterWorking Labs, Inc.) Dave Levi (SNMP Research, Inc.) Louis A Mamakos (UUNET Technologies Inc.) Joe Marzot (Nortel Networks) Paul Meyer (Secure Computing Corporation) Keith McCloghrie (Cisco Systems) Bob Moore (IBM) Russ Mundy (TIS Labs at Network Associates) Bob Natale (ACE*COMM Corporation) Mike O'Dell (UUNET Technologies Inc.) Dave Perkins (DeskTalk) Peter Polkinghorne (Brunel University) Randy Presuhn (BMC Software, Inc.) David Reeder (TIS Labs at Network Associates) David Reid (SNMP Research, Inc.) Aleksey Romanov (Quality Quorum) Shawn Routhier (Epilogue) Juergen Schoenwaelder (TU Braunschweig) Bob Stewart (Cisco Systems) Mike Thatcher (Independent Consultant) Bert Wijnen (IBM T.J. Watson Research Center)",
      "ja": "Harald Tveit Alvestrand（Maxware）Dave Battle（SNMP Research、Inc.）Alan Beard（Disney Worldwide Services）Paul Berrevoets（SWI Systemware / Halcyon Inc.）Martin Bjorklund（Ericsson）Uri Blumenthal（IBM TJ Watson Research Center）Jeff Case（SNMP Research、Inc.）John Curran（BBN）Mike Daniele（Compaq Computer Corporation））T. Max Devlin（Eltrax Systems）John Flick（Hewlett Packard）Rob Frye（MCI）Wes Hardaker（UCDavis、Information Technology-DCAS）David Harrington （Cabletron Systems Inc.）Lauren Heintz（BMC Software、Inc.）NC Hien（IBM TJ Watson Research Center）Michael Kirkham（InterWorking Labs、Inc.）Dave Levi（SNMP Research、Inc.）Louis A Mamakos（UUNET Technologies Inc. ）Joe Marzot（Nortel Networks）Paul Meyer（Secure Computing Corporation）Keith McCloghrie（Cisco Systems）Bob Moore（IBM）Russ Mundy（TIS Labs at Network Associates）Bob Natale（ACE * COMM Corporation）Mike O'Dell（UUNET Technologies Inc） 。）Dave Perkins（DeskTalk）Peter Polkinghorne（Brunel University）Randy Presuhn（BMC Software、Inc.）David Reeder（TIS Labs at Network Associates）David Reid（SNMP Research、Inc.）Aleksey Romanov（Quality Quorum）Shawn Routhier（Epilogue）Juergen Schoenwaelder（TU Braunschweig）Bob Stewart（Cisco Systems）Mikeサッチャー（独立コンサルタント）Bert Wijnen（IBM TJワトソン研究センター）"
    },
    {
      "indent": 3,
      "text": "The document is based on recommendations of the IETF Security and Administrative Framework Evolution for SNMP Advisory Team. Members of that Advisory Team were:",
      "ja": "このドキュメントは、SNMP諮問チームのためのIETFセキュリティおよび管理フレームワークの進化の推奨に基づいています。その諮問チームのメンバーは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "David Harrington (Cabletron Systems Inc.) Jeff Johnson (Cisco Systems) David Levi (SNMP Research Inc.) John Linn (Openvision) Russ Mundy (Trusted Information Systems) chair Shawn Routhier (Epilogue) Glenn Waters (Nortel) Bert Wijnen (IBM T. J. Watson Research Center)",
      "ja": "デビッドハリントン（ケーブルトロンシステムズ社）ジェフジョンソン（シスコシステムズ）デビッドレヴィ（SNMPリサーチ社）ジョンリン（オープンビジョン）ラスマンディ（トラステッドインフォメーションシステムズ）チェアショーンルーティエ（エピローグ）グレンウォーターズ（ノーテル）バートウィネン（IBM TJワトソン研究センター）"
    },
    {
      "indent": 3,
      "text": "As recommended by the Advisory Team and the SNMPv3 Working Group Charter, the design incorporates as much as practical from previous RFCs and drafts. As a result, special thanks are due to the authors of previous designs known as SNMPv2u and SNMPv2*:",
      "ja": "アドバイザリーチームとSNMPv3ワーキンググループチャーターによって推奨されているように、この設計には、以前のRFCとドラフトからの実用的な限りのものが組み込まれています。その結果、SNMPv2uおよびSNMPv2 *として知られている以前の設計の作成者に特に感謝します。"
    },
    {
      "indent": 6,
      "text": "Jeff Case (SNMP Research, Inc.) David Harrington (Cabletron Systems Inc.) David Levi (SNMP Research, Inc.) Keith McCloghrie (Cisco Systems) Brian O'Keefe (Hewlett Packard) Marshall T. Rose (Dover Beach Consulting) Jon Saperia (BGS Systems Inc.) Steve Waldbusser (International Network Services) Glenn W. Waters (Bell-Northern Research Ltd.)",
      "ja": "Jeff Case (SNMP Research, Inc.) David Harrington (Cabletron Systems Inc.) David Levi (SNMP Research, Inc.) Keith McCloghrie (Cisco Systems) Brian O'Keefe (Hewlett Packard) Marshall T. Rose (Dover Beach Consulting) Jon Saperia (BGS Systems Inc.) Steve Waldbusser (International Network Services) Glenn W. Waters (Bell-Northern Research Ltd.)"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Recommended Practices",
      "section_title": true,
      "ja": "11.1. 推奨されるプラクティス"
    },
    {
      "indent": 3,
      "text": "This section describes practices that contribute to the secure, effective operation of the mechanisms defined in this memo.",
      "ja": "This section describes practices that contribute to the secure, effective operation of the mechanisms defined in this memo."
    },
    {
      "indent": 3,
      "text": "- An SNMP engine must discard SNMP Response messages that do not correspond to any currently outstanding Request message. It is the responsibility of the Message Processing module to take care of this. For example it can use a msgID for that.",
      "ja": "- SNMPエンジンは、現在未解決の要求メッセージに対応しないSNMP応答メッセージを破棄する必要があります。これを処理するのはメッセージ処理モジュールの責任です。たとえば、そのためにmsgIDを使用できます。"
    },
    {
      "indent": 5,
      "text": "An SNMP Command Generator Application must discard any Response Class PDU for which there is no currently outstanding Confirmed Class PDU; for example for SNMPv2 [RFC3416] PDUs, the request-id component in the PDU can be used to correlate Responses to outstanding Requests.",
      "ja": "SNMPコマンドジェネレータアプリケーションは、現在未解決の確認済みクラスPDUがない応答クラスPDUを破棄する必要があります。たとえば、SNMPv2 [RFC3416] PDUの場合、PDU内のrequest-idコンポーネントを使用して、応答を未処理の要求に関連付けることができます。"
    },
    {
      "indent": 5,
      "text": "Although it would be typical for an SNMP engine and an SNMP Command Generator Application to do this as a matter of course, when using these security protocols it is significant due to the possibility of message duplication (malicious or otherwise).",
      "ja": "当然のことながら、SNMPエンジンとSNMPコマンドジェネレーターアプリケーションがこれを行うのは一般的ですが、これらのセキュリティプロトコルを使用する場合は、メッセージの重複（悪意のあるものなど）の可能性があるため重要です。"
    },
    {
      "indent": 3,
      "text": "- If an SNMP engine uses a msgID for correlating Response messages to outstanding Request messages, then it MUST use different msgIDs in all such Request messages that it sends out during a Time Window (150 seconds) period.",
      "ja": "- SNMPエンジンが応答メッセージを未処理の要求メッセージに関連付けるためにmsgIDを使用する場合、時間ウィンドウ（150秒）の間に送信するそのようなすべての要求メッセージで異なるmsgIDを使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "A Command Generator or Notification Originator Application MUST use different request-ids in all Request PDUs that it sends out during a TimeWindow (150 seconds) period.",
      "ja": "Command GeneratorまたはNotification Originatorアプリケーションは、TimeWindow（150秒）の期間中に送信するすべてのリクエストPDUで異なるリクエストIDを使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "This must be done to protect against the possibility of message duplication (malicious or otherwise).",
      "ja": "これは、メッセージの重複（悪意のある、またはその他の）の可能性を防ぐために行う必要があります。"
    },
    {
      "indent": 5,
      "text": "For example, starting operations with a msgID and/or request-id value of zero is not a good idea. Initializing them with an unpredictable number (so they do not start out the same after each reboot) and then incrementing by one would be acceptable.",
      "ja": "たとえば、msgIDやrequest-idの値をゼロで操作を開始することはお勧めできません。予測不可能な数でそれらを初期化し（再起動のたびに同じように開始されないようにする）、1ずつ増やしても問題ありません。"
    },
    {
      "indent": 3,
      "text": "- An SNMP engine should perform time synchronization using authenticated messages in order to protect against the possibility of message duplication (malicious or otherwise).",
      "ja": "- SNMPエンジンは、メッセージの重複（悪意のあるものかどうかにかかわらず）の可能性を防ぐために、認証されたメッセージを使用して時刻同期を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "- When sending state altering messages to a managed authoritative SNMP engine, a Command Generator Application should delay sending successive messages to that managed SNMP engine until a positive acknowledgement is received for the previous message or until the previous message expires.",
      "ja": "- 管理された信頼できるSNMPエンジンに状態変更メッセージを送信する場合、コマンドジェネレーターアプリケーションは、前のメッセージの肯定応答が受信されるまで、または前のメッセージの有効期限が切れるまで、その管理SNMPエンジンへの後続のメッセージの送信を遅らせる必要があります。"
    },
    {
      "indent": 5,
      "text": "No message ordering is imposed by the SNMP. Messages may be received in any order relative to their time of generation and each will be processed in the ordered received. Note that when an authenticated message is sent to a managed SNMP engine, it will be valid for a period of time of approximately 150 seconds under normal circumstances, and is subject to replay during this period. Indeed, an SNMP engine and SNMP Command Generator Applications must cope with the loss and re-ordering of messages resulting from anomalies in the network as a matter of course.",
      "ja": "SNMPによるメッセージの順序付けはありません。メッセージは、生成された時間を基準にして任意の順序で受信できます。各メッセージは、受信した順序で処理されます。認証されたメッセージが管理対象のSNMPエンジンに送信されると、通常の状況では約150秒間有効であり、この期間中は再生される可能性があることに注意してください。確かに、SNMPエンジンとSNMPコマンドジェネレーターアプリケーションは、当然ながら、ネットワークの異常によるメッセージの損失と再順序付けに対処する必要があります。"
    },
    {
      "indent": 5,
      "text": "However, a managed object, snmpSetSerialNo [RFC3418], is specifically defined for use with SNMP Set operations in order to provide a mechanism to ensure that the processing of SNMP messages occurs in a specific order.",
      "ja": "ただし、管理対象オブジェクトsnmpSetSerialNo [RFC3418]は、SNMPメッセージの処理が特定の順序で発生することを保証するメカニズムを提供するために、SNMP Set操作で使用するために特別に定義されています。"
    },
    {
      "indent": 3,
      "text": "- The frequency with which the secrets of a User-based Security Model user should be changed is indirectly related to the frequency of their use.",
      "ja": "- The frequency with which the secrets of a User-based Security Model user should be changed is indirectly related to the frequency of their use."
    },
    {
      "indent": 5,
      "text": "Protecting the secrets from disclosure is critical to the overall security of the protocols. Frequent use of a secret provides a continued source of data that may be useful to a cryptanalyst in exploiting known or perceived weaknesses in an algorithm. Frequent changes to the secret avoid this vulnerability.",
      "ja": "秘密を開示から保護することは、プロトコルの全体的なセキュリティにとって重要です。シークレットを頻繁に使用すると、継続的なデータソースが提供されます。これは、暗号解読者がアルゴリズムの既知または認識されている弱点を悪用するのに役立つ場合があります。シークレットを頻繁に変更すると、この脆弱性を回避できます。"
    },
    {
      "indent": 5,
      "text": "Changing a secret after each use is generally regarded as the most secure practice, but a significant amount of overhead may be associated with that approach.",
      "ja": "使用後にシークレットを変更することは、一般的に最も安全な方法と見なされますが、そのアプローチにはかなりのオーバーヘッドが伴う場合があります。"
    },
    {
      "indent": 5,
      "text": "Note, too, in a local environment the threat of disclosure may be less significant, and as such the changing of secrets may be less frequent. However, when public data networks are used as the communication paths, more caution is prudent.",
      "ja": "Note, too, in a local environment the threat of disclosure may be less significant, and as such the changing of secrets may be less frequent. However, when public data networks are used as the communication paths, more caution is prudent."
    },
    {
      "indent": 0,
      "text": "11.2 Defining Users",
      "section_title": true,
      "ja": "11.2 ユーザーの定義"
    },
    {
      "indent": 3,
      "text": "The mechanisms defined in this document employ the notion of users on whose behalf messages are sent. How \"users\" are defined is subject to the security policy of the network administration. For example, users could be individuals (e.g., \"joe\" or \"jane\"), or a particular role (e.g., \"operator\" or \"administrator\"), or a combination (e.g., \"joe-operator\", \"jane-operator\" or \"joe-admin\"). Furthermore, a user may be a logical entity, such as an SNMP Application or a set of SNMP Applications, acting on behalf of an individual or role, or set of individuals, or set of roles, including combinations.",
      "ja": "The mechanisms defined in this document employ the notion of users on whose behalf messages are sent. How \"users\" are defined is subject to the security policy of the network administration. For example, users could be individuals (e.g., \"joe\" or \"jane\"), or a particular role (e.g., \"operator\" or \"administrator\"), or a combination (e.g., \"joe-operator\", \"jane-operator\" or \"joe-admin\"). Furthermore, a user may be a logical entity, such as an SNMP Application or a set of SNMP Applications, acting on behalf of an individual or role, or set of individuals, or set of roles, including combinations."
    },
    {
      "indent": 3,
      "text": "Appendix A describes an algorithm for mapping a user \"password\" to a 16/20 octet value for use as either a user's authentication key or privacy key (or both). Note however, that using the same password (and therefore the same key) for both authentication and privacy is very poor security practice and should be strongly discouraged. Passwords are often generated, remembered, and input by a human. Human-generated passwords may be less than the 16/20 octets required by the authentication and privacy protocols, and brute force attacks can be quite easy on a relatively short ASCII character set. Therefore, the algorithm is Appendix A performs a transformation on the password. If the Appendix A algorithm is used, SNMP implementations (and SNMP configuration applications) must ensure that passwords are at least 8 characters in length. Please note that longer passwords with repetitive strings may result in exactly the same key. For example, a password 'bertbert' will result in exactly the same key as password 'bertbertbert'.",
      "ja": "Appendix A describes an algorithm for mapping a user \"password\" to a 16/20 octet value for use as either a user's authentication key or privacy key (or both). Note however, that using the same password (and therefore the same key) for both authentication and privacy is very poor security practice and should be strongly discouraged. Passwords are often generated, remembered, and input by a human. Human-generated passwords may be less than the 16/20 octets required by the authentication and privacy protocols, and brute force attacks can be quite easy on a relatively short ASCII character set. Therefore, the algorithm is Appendix A performs a transformation on the password. If the Appendix A algorithm is used, SNMP implementations (and SNMP configuration applications) must ensure that passwords are at least 8 characters in length. Please note that longer passwords with repetitive strings may result in exactly the same key. For example, a password 'bertbert' will result in exactly the same key as password 'bertbertbert'."
    },
    {
      "indent": 3,
      "text": "Because the Appendix A algorithm uses such passwords (nearly) directly, it is very important that they not be easily guessed. It is suggested that they be composed of mixed-case alphanumeric and punctuation characters that don't form words or phrases that might be found in a dictionary. Longer passwords improve the security of the system. Users may wish to input multiword phrases to make their password string longer while ensuring that it is memorable.",
      "ja": "付録Aのアルゴリズムはこのようなパスワードを（ほぼ）直接使用するため、簡単に推測できないことが非常に重要です。それらは、大文字と小文字が混在する英数字と句読文字で構成することをお勧めします。これらは、辞書で見つかる可能性のある単語やフレーズを形成しません。パスワードを長くすると、システムのセキュリティが向上します。ユーザーは、覚えやすいようにパスワード文字列を長くするために、マルチワードフレーズを入力したい場合があります。"
    },
    {
      "indent": 3,
      "text": "Since it is infeasible for human users to maintain different passwords for every SNMP engine, but security requirements strongly discourage having the same key for more than one SNMP engine, the User-based Security Model employs a compromise proposed in [Localized-key]. It derives the user keys for the SNMP engines from user's password in such a way that it is practically impossible to either determine the user's password, or user's key for another SNMP engine from any combination of user's keys on SNMP engines.",
      "ja": "人間のユーザーがSNMPエンジンごとに異なるパスワードを維持することは不可能ですが、セキュリティ要件では、複数のSNMPエンジンに同じキーを使用することを強くお勧めしません。ユーザーベースのセキュリティモデルでは、[Localized-key]で提案されている妥協案を採用しています。 SNMPエンジンのユーザーキーは、ユーザーのパスワードから決定することも、SNMPエンジン上のユーザーのキーの組み合わせから別のSNMPエンジンのユーザーのキーを決定することも事実上不可能であるような方法で、ユーザーのパスワードから派生します。"
    },
    {
      "indent": 3,
      "text": "Note however, that if user's password is disclosed, then key localization will not help and network security may be compromised in this case. Therefore a user's password or non-localized key MUST NOT be stored on a managed device/node. Instead the localized key SHALL be stored (if at all), so that, in case a device does get compromised, no other managed or managing devices get compromised.",
      "ja": "ただし、ユーザーのパスワードが開示されている場合、キーのローカライズは役に立たず、この場合ネットワークセキュリティが危険にさらされる可能性があることに注意してください。したがって、ユーザーのパスワードまたはローカライズされていないキーを管理対象デバイス/ノードに保存してはなりません（MUST NOT）。代わりに、ローカライズされたキーを格納する必要があります（存在する場合）。これにより、デバイスが侵害された場合でも、他の管理対象デバイスまたは管理デバイスが侵害されることはありません。"
    },
    {
      "indent": 0,
      "text": "11.3. Conformance",
      "section_title": true,
      "ja": "11.3. 適合"
    },
    {
      "indent": 3,
      "text": "To be termed a \"Secure SNMP implementation\" based on the User-based Security Model, an SNMP implementation MUST:",
      "ja": "ユーザーベースのセキュリティモデルに基づく「セキュアなSNMP実装」と呼ばれるためには、SNMP実装は次の条件を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "- implement one or more Authentication Protocol(s). The HMAC-MD5-96 and HMAC-SHA-96 Authentication Protocols defined in this memo are examples of such protocols.",
      "ja": "- 1つ以上の認証プロトコルを実装します。このメモで定義されているHMAC-MD5-96およびHMAC-SHA-96認証プロトコルは、そのようなプロトコルの例です。"
    },
    {
      "indent": 3,
      "text": "- to the maximum extent possible, prohibit access to the secret(s) of each user about which it maintains information in a Local Configuration Datastore (LCD) under all circumstances except as required to generate and/or validate SNMP messages with respect to that user.",
      "ja": "- 可能な限り、ユーザーに関するSNMPメッセージの生成や検証に必要な場合を除いて、すべての状況でローカル構成データストア（LCD）に情報を保持する各ユーザーのシークレットへのアクセスを禁止します。"
    },
    {
      "indent": 3,
      "text": "- implement the key-localization mechanism.",
      "ja": "- キーローカリゼーションメカニズムを実装します。"
    },
    {
      "indent": 3,
      "text": "- implement the SNMP-USER-BASED-SM-MIB.",
      "ja": "- implement the SNMP-USER-BASED-SM-MIB."
    },
    {
      "indent": 3,
      "text": "In addition, an authoritative SNMP engine SHOULD provide initial configuration in accordance with Appendix A.1.",
      "ja": "さらに、信頼できるSNMPエンジンは、付録A.1に従って初期構成を提供する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Implementation of a Privacy Protocol (the DES Symmetric Encryption Protocol defined in this memo is one such protocol) is optional.",
      "ja": "プライバシープロトコル（このメモで定義されているDES対称暗号化プロトコルはそのようなプロトコルの1つです）の実装はオプションです。"
    },
    {
      "indent": 0,
      "text": "11.4. Use of Reports",
      "section_title": true,
      "ja": "11.4. Use of Reports"
    },
    {
      "indent": 3,
      "text": "The use of unsecure reports (i.e., sending them with a securityLevel of noAuthNoPriv) potentially exposes a non-authoritative SNMP engine to some form of attacks. Some people consider these denial of service attacks, others don't. An installation should evaluate the risk involved before deploying unsecure Report PDUs.",
      "ja": "安全でないレポートの使用（つまり、noAuthNoPrivのsecurityLevelでそれらを送信する）は、権限のないSNMPエンジンを何らかの形の攻撃にさらす可能性があります。これらのサービス拒否攻撃を検討する人もいれば、そうではない人もいます。安全でないレポートPDUを展開する前に、インストールで関連するリスクを評価する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.5 Access to the SNMP-USER-BASED-SM-MIB",
      "section_title": true,
      "ja": "11.5 SNMP-USER-BASED-SM-MIBへのアクセス"
    },
    {
      "indent": 3,
      "text": "The objects in this MIB may be considered sensitive in many environments. Specifically the objects in the usmUserTable contain information about users and their authentication and privacy protocols. It is important to closely control (both read and write) access to these MIB objects by using appropriately configured Access Control models (for example the View-based Access Control Model as specified in [RFC3415]).",
      "ja": "The objects in this MIB may be considered sensitive in many environments. Specifically the objects in the usmUserTable contain information about users and their authentication and privacy protocols. It is important to closely control (both read and write) access to these MIB objects by using appropriately configured Access Control models (for example the View-based Access Control Model as specified in [RFC3415])."
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1 Normative References",
      "section_title": true,
      "ja": "12.1 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"Message Digest Algorithm MD5\", RFC 1321, April 1992.",
      "ja": "[RFC1321] Rivest、R。、「Message Digest Algorithm MD5」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[RFC2578] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M. and S. Waldbusser、 \"Structure of Management Information Version 2（SMIv2）\"、STD 58、RFC 2578、 1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "ja": "[RFC2579] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M. and S. Waldbusser、 \"Textual Conventions for SMIv2\"、STD 58、RFC 2579、April 1999。"
    },
    {
      "indent": 3,
      "text": "[RFC2580] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Conformance Statements for SMIv2\", STD 58, RFC 2580, April 1999.",
      "ja": "[RFC2580] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M. and S. Waldbusser、 \"Conformance Statements for SMIv2\"、STD 58、RFC 2580、April 1999。"
    },
    {
      "indent": 3,
      "text": "[RFC3411] Harrington, D., Presuhn, R. and B. Wijnen, \"An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks\", STD 62, RFC 3411, December 2002.",
      "ja": "[RFC3411] Harrington、D.、Presuhn、R。、およびB. Wijnen、「An Simple Architecture for Describing Simple Network Management Protocol（SNMP）Management Frameworks」、STD 62、RFC 3411、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3412] Case, J., Harrington, D., Presuhn, R. and B. Wijnen, \"Message Processing and Dispatching for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3412, December 2002.",
      "ja": "[RFC3412] Case、J.、Harrington、D.、Presuhn、R。、およびB. Wijnen、「メッセージ処理および簡易ネットワーク管理プロトコル（SNMP）のディスパッチ」、STD 62、RFC 3412、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3415] Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3415, December 2002.",
      "ja": "[RFC3415] Wijnen、B.、Presuhn、R。、およびK. McCloghrie、「簡易ネットワーク管理プロトコル（SNMP）のビューベースアクセスコントロールモデル（VACM）」、STD 62、RFC 3415、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3416] Presuhn, R., Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3416, December 2002.",
      "ja": "[RFC3416] Presuhn、R.、Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「Version 2 of the Protocol Operations for the Simple Network Management Protocol（SNMP）」、STD 62、RFC 3416 、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3417] Presuhn, R., Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Transport Mappings for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3417, December 2002.",
      "ja": "[RFC3417] Presuhn、R.、Case、J.、McCloghrie、K.、Rose、M。、およびS. Waldbusser、「Transport Mappings for the Simple Network Management Protocol（SNMP）」、STD 62、RFC 3417、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3418] Presuhn, R., Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Management Information Base (MIB) for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3418, December 2002.",
      "ja": "[RFC3418] Presuhn、R.、Case、J.、McCloghrie、K.、Rose、M. and S. Waldbusser、 \"Management Information Base（MIB）for the Simple Network Management Protocol（SNMP）\"、STD 62、RFC 3418 、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[DES-NIST] Data Encryption Standard, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 46-1. Supersedes FIPS Publication 46, (January, 1977; reaffirmed January, 1988).",
      "ja": "[DES-NIST] Data Encryption Standard, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 46-1. Supersedes FIPS Publication 46, (January, 1977; reaffirmed January, 1988)."
    },
    {
      "indent": 3,
      "text": "[DESO-NIST] DES Modes of Operation, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 81, (December, 1980).",
      "ja": "[DESO-NIST]国立標準技術研究所のDES Modes of Operation。連邦情報処理標準（FIPS）Publication 81、（1980年12月）。"
    },
    {
      "indent": 3,
      "text": "[SHA-NIST]      Secure Hash Algorithm. NIST FIPS 180-1, (April, 1995)\n                http://csrc.nist.gov/fips/fip180-1.txt (ASCII)\n                http://csrc.nist.gov/fips/fip180-1.ps  (Postscript)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "12.1 Informative References",
      "section_title": true,
      "ja": "12.1 参考引用"
    },
    {
      "indent": 3,
      "text": "[Localized-Key] U. Blumenthal, N. C. Hien, B. Wijnen \"Key Derivation for Network Management Applications\" IEEE Network Magazine, April/May issue, 1997.",
      "ja": "[Localized-Key] U. Blumenthal、N。C. Hien、B。Wijnen「ネットワーク管理アプリケーションのキーの派生」IEEEネットワークマガジン、1997年4月/ 5月号。"
    },
    {
      "indent": 3,
      "text": "[DES-ANSI] Data Encryption Algorithm, American National Standards Institute. ANSI X3.92-1981, (December, 1980).",
      "ja": "[DES-ANSI]データ暗号化アルゴリズム、American National Standards Institute。 ANSI X3.92-1981、（1980年12月）。"
    },
    {
      "indent": 3,
      "text": "[DESO-ANSI] Data Encryption Algorithm - Modes of Operation, American National Standards Institute. ANSI X3.106- 1983, (May 1983).",
      "ja": "[DESO-ANSI] Data Encryption Algorithm-Modes of Operation、American National Standards Institute。 ANSI X3.106- 1983、（1983年5月）。"
    },
    {
      "indent": 3,
      "text": "[DESG-NIST] Guidelines for Implementing and Using the NBS Data Encryption Standard, National Institute of Standards and Technology. Federal Information Processing Standard (FIPS) Publication 74, (April, 1981).",
      "ja": "[DESG-NIST]国立標準技術研究所、NBSデータ暗号化標準の実装と使用に関するガイドライン。連邦情報処理標準（FIPS）Publication 74、（1981年4月）。"
    },
    {
      "indent": 3,
      "text": "[DEST-NIST] Validating the Correctness of Hardware Implementations of the NBS Data Encryption Standard, National Institute of Standards and Technology. Special Publication 500-20.",
      "ja": "[DEST-NIST] Validating the Correctness of Hardware Implementations of the NBS Data Encryption Standard, National Institute of Standards and Technology. Special Publication 500-20."
    },
    {
      "indent": 3,
      "text": "[DESM-NIST] Maintenance Testing for the Data Encryption Standard, National Institute of Standards and Technology. Special Publication 500-61, (August, 1980).",
      "ja": "[DESM-NIST]国立標準技術研究所のデータ暗号化規格のメンテナンステスト。特別刊行物500-61（1980年8月）。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake, D. 3rd and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[RFC3174] Eastlake、D。3rdおよびP. Jones、「US Secure Hash Algorithm 1（SHA1）」、RFC 3174、2001年9月。"
    },
    {
      "indent": 0,
      "text": "APPENDIX A - Installation",
      "ja": "付録A-インストール"
    },
    {
      "indent": 0,
      "text": "A.1. SNMP engine Installation Parameters",
      "section_title": true,
      "ja": "A.1. SNMPエンジンのインストールパラメータ"
    },
    {
      "indent": 3,
      "text": "During installation, an authoritative SNMP engine SHOULD (in the meaning as defined in [RFC2119]) be configured with several initial parameters. These include:",
      "ja": "インストール中に、信頼できるSNMPエンジンは（[RFC2119]で定義されている意味で）、いくつかの初期パラメータを使用して構成する必要があります（SHOULD）。これらには以下が含まれます："
    },
    {
      "indent": 3,
      "text": "1) A Security Posture",
      "ja": "1）セキュリティの姿勢"
    },
    {
      "indent": 6,
      "text": "The choice of security posture determines if initial configuration is implemented and if so how. One of three possible choices is selected:",
      "ja": "セキュリティポスチャの選択により、初期構成が実装されるかどうか、実装される場合はその方法が決まります。次の3つの選択肢から1つを選択します。"
    },
    {
      "indent": 9,
      "text": "minimum-secure, semi-secure, very-secure (i.e., no-initial-configuration)",
      "ja": "最小安全、半安全、非常に安全（つまり、初期設定なし）"
    },
    {
      "indent": 6,
      "text": "In the case of a very-secure posture, there is no initial configuration, and so the following steps are irrelevant.",
      "ja": "非常にセキュアなポスチャの場合、初期設定がないため、次の手順は関係ありません。"
    },
    {
      "indent": 3,
      "text": "2) One or More Secrets",
      "ja": "2）1つ以上の秘密"
    },
    {
      "indent": 6,
      "text": "These are the authentication/privacy secrets for the first user to be configured.",
      "ja": "これらは、最初に設定するユーザーの認証/プライバシーシークレットです。"
    },
    {
      "indent": 6,
      "text": "One way to accomplish this is to have the installer enter a \"password\" for each required secret. The password is then algorithmically converted into the required secret by:",
      "ja": "これを行う1つの方法は、必要な各シークレットの「パスワード」をインストーラーに入力させることです。次に、パスワードはアルゴリズムによって必要なシークレットに変換されます。"
    },
    {
      "indent": 6,
      "text": "- forming a string of length 1,048,576 octets by repeating the value of the password as often as necessary, truncating accordingly, and using the resulting string as the input to the MD5 algorithm [RFC1321]. The resulting digest, termed \"digest1\", is used in the next step.",
      "ja": "- forming a string of length 1,048,576 octets by repeating the value of the password as often as necessary, truncating accordingly, and using the resulting string as the input to the MD5 algorithm [RFC1321]. The resulting digest, termed \"digest1\", is used in the next step."
    },
    {
      "indent": 6,
      "text": "- a second string is formed by concatenating digest1, the SNMP engine's snmpEngineID value, and digest1. This string is used as input to the MD5 algorithm [RFC1321].",
      "ja": "- 2番目の文字列は、digest1、SNMPエンジンのsnmpEngineID値、およびdigest1を連結して形成されます。この文字列は、MD5アルゴリズム[RFC1321]への入力として使用されます。"
    },
    {
      "indent": 8,
      "text": "The resulting digest is the required secret (see Appendix A.2).",
      "ja": "結果のダイジェストは必要な秘密です（付録A.2を参照）。"
    },
    {
      "indent": 6,
      "text": "With these configured parameters, the SNMP engine instantiates the following usmUserEntry in the usmUserTable:",
      "ja": "With these configured parameters, the SNMP engine instantiates the following usmUserEntry in the usmUserTable:"
    },
    {
      "indent": 3,
      "text": "                        no privacy support     privacy support\n                        ------------------     ---------------\nusmUserEngineID         localEngineID          localEngineID\nusmUserName             \"initial\"              \"initial\"\nusmUserSecurityName     \"initial\"              \"initial\"\nusmUserCloneFrom        ZeroDotZero            ZeroDotZero\nusmUserAuthProtocol     usmHMACMD5AuthProtocol usmHMACMD5AuthProtocol\nusmUserAuthKeyChange    \"\"                     \"\"\nusmUserOwnAuthKeyChange \"\"                     \"\"\nusmUserPrivProtocol     none                   usmDESPrivProtocol\nusmUserPrivKeyChange    \"\"                     \"\"\nusmUserOwnPrivKeyChange \"\"                     \"\"\nusmUserPublic           \"\"                     \"\"\nusmUserStorageType      anyValidStorageType    anyValidStorageType\nusmUserStatus           active                 active",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "It is recommended to also instantiate a set of template usmUserEntries which can be used as clone-from users for newly created usmUserEntries. These are the two suggested entries:",
      "ja": "新しく作成されたusmUserEntriesのクローン元ユーザーとして使用できるテンプレートusmUserEntriesのセットをインスタンス化することもお勧めします。これらは、2つの推奨エントリです。"
    },
    {
      "indent": 3,
      "text": "                        no privacy support     privacy support\n                        ------------------     ---------------\nusmUserEngineID         localEngineID          localEngineID\nusmUserName             \"templateMD5\"          \"templateMD5\"\nusmUserSecurityName     \"templateMD5\"          \"templateMD5\"\nusmUserCloneFrom        ZeroDotZero            ZeroDotZero\nusmUserAuthProtocol     usmHMACMD5AuthProtocol usmHMACMD5AuthProtocol\nusmUserAuthKeyChange    \"\"                     \"\"\nusmUserOwnAuthKeyChange \"\"                     \"\"\nusmUserPrivProtocol     none                   usmDESPrivProtocol\nusmUserPrivKeyChange    \"\"                     \"\"\nusmUserOwnPrivKeyChange \"\"                     \"\"\nusmUserPublic           \"\"                     \"\"\nusmUserStorageType      permanent              permanent\nusmUserStatus           active                 active",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                        no privacy support     privacy support\n                        ------------------     ---------------\nusmUserEngineID         localEngineID          localEngineID\nusmUserName             \"templateSHA\"          \"templateSHA\"\nusmUserSecurityName     \"templateSHA\"          \"templateSHA\"\nusmUserCloneFrom        ZeroDotZero            ZeroDotZero\nusmUserAuthProtocol     usmHMACSHAAuthProtocol usmHMACSHAAuthProtocol\nusmUserAuthKeyChange    \"\"                     \"\"\nusmUserOwnAuthKeyChange \"\"                     \"\"\nusmUserPrivProtocol     none                   usmDESPrivProtocol\nusmUserPrivKeyChange    \"\"                     \"\"\nusmUserOwnPrivKeyChange \"\"                     \"\"\nusmUserPublic           \"\"                     \"\"\nusmUserStorageType      permanent              permanent\nusmUserStatus           active                 active",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. Password to Key Algorithm",
      "section_title": true,
      "ja": "A.2. キーアルゴリズムのパスワード"
    },
    {
      "indent": 3,
      "text": "A sample code fragment (section A.2.1) demonstrates the password to key algorithm which can be used when mapping a password to an authentication or privacy key using MD5. The reference source code of MD5 is available in [RFC1321].",
      "ja": "A sample code fragment (section A.2.1) demonstrates the password to key algorithm which can be used when mapping a password to an authentication or privacy key using MD5. The reference source code of MD5 is available in [RFC1321]."
    },
    {
      "indent": 3,
      "text": "Another sample code fragment (section A.2.2) demonstrates the password to key algorithm which can be used when mapping a password to an authentication or privacy key using SHA (documented in SHA-NIST).",
      "ja": "別のサンプルコードフラグメント（セクションA.2.2）は、SHAを使用してパスワードを認証またはプライバシーキーにマッピングするときに使用できるパスワードキーアルゴリズムを示しています（SHA-NISTに文書化されています）。"
    },
    {
      "indent": 3,
      "text": "An example of the results of a correct implementation is provided (section A.3) which an implementor can use to check if his implementation produces the same result.",
      "ja": "正しい実装の結果の例が提供され（セクションA.3）、これを使用して、実装者が自分の実装で同じ結果が得られるかどうかを確認できます。"
    },
    {
      "indent": 0,
      "text": "A.2.1. Password to Key Sample Code for MD5",
      "section_title": true,
      "ja": "A.2.1. MD5の主要なサンプルコードへのパスワード"
    },
    {
      "indent": 3,
      "text": "void password_to_key_md5(\n   u_char *password,    /* IN */\n   u_int   passwordlen, /* IN */\n   u_char *engineID,    /* IN  - pointer to snmpEngineID  */\n   u_int   engineLength,/* IN  - length of snmpEngineID */\n   u_char *key)         /* OUT - pointer to caller 16-octet buffer */\n{\n   MD5_CTX     MD;\n   u_char     *cp, password_buf[64];\n   u_long      password_index = 0;\n   u_long      count = 0, i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "MD5Init (&MD);   /* initialize MD5 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/**********************************************/\n/* Use while loop until we've done 1 Megabyte */\n/**********************************************/\nwhile (count < 1048576) {\n   cp = password_buf;\n   for (i = 0; i < 64; i++) {\n       /*************************************************/\n       /* Take the next octet of the password, wrapping */\n       /* to the beginning of the password as necessary.*/\n       /*************************************************/\n       *cp++ = password[password_index++ % passwordlen];\n   }\n   MD5Update (&MD, password_buf, 64);\n   count += 64;\n}\nMD5Final (key, &MD);          /* tell MD5 we're done */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/*****************************************************/\n/* Now localize the key with the engineID and pass   */\n/* through MD5 to produce final key                  */\n/* May want to ensure that engineLength <= 32,       */\n/* otherwise need to use a buffer larger than 64     */\n/*****************************************************/\nmemcpy(password_buf, key, 16);\nmemcpy(password_buf+16, engineID, engineLength);\nmemcpy(password_buf+16+engineLength, key, 16);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   MD5Init(&MD);\n   MD5Update(&MD, password_buf, 32+engineLength);\n   MD5Final(key, &MD);\n   return;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2.2. Password to Key Sample Code for SHA",
      "section_title": true,
      "ja": "A.2.2. SHAの主要なサンプルコードのパスワード"
    },
    {
      "indent": 3,
      "text": "void password_to_key_sha(\n   u_char *password,    /* IN */\n   u_int   passwordlen, /* IN */\n   u_char *engineID,    /* IN  - pointer to snmpEngineID  */\n   u_int   engineLength,/* IN  - length of snmpEngineID */\n   u_char *key)         /* OUT - pointer to caller 20-octet buffer */\n{\n   SHA_CTX     SH;\n   u_char     *cp, password_buf[72];\n   u_long      password_index = 0;\n   u_long      count = 0, i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "SHAInit (&SH);   /* initialize SHA */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/**********************************************/\n/* Use while loop until we've done 1 Megabyte */\n/**********************************************/\nwhile (count < 1048576) {\n   cp = password_buf;\n   for (i = 0; i < 64; i++) {\n       /*************************************************/\n       /* Take the next octet of the password, wrapping */\n       /* to the beginning of the password as necessary.*/\n       /*************************************************/\n       *cp++ = password[password_index++ % passwordlen];\n   }\n   SHAUpdate (&SH, password_buf, 64);\n   count += 64;\n}\nSHAFinal (key, &SH);          /* tell SHA we're done */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/*****************************************************/\n/* Now localize the key with the engineID and pass   */\n/* through SHA to produce final key                  */\n/* May want to ensure that engineLength <= 32,       */\n/* otherwise need to use a buffer larger than 72     */\n/*****************************************************/\nmemcpy(password_buf, key, 20);\nmemcpy(password_buf+20, engineID, engineLength);\nmemcpy(password_buf+20+engineLength, key, 20);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   SHAInit(&SH);\n   SHAUpdate(&SH, password_buf, 40+engineLength);\n   SHAFinal(key, &SH);\n   return;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. Password to Key Sample Results",
      "section_title": true,
      "ja": "A.3. 主要なサンプル結果へのパスワード"
    },
    {
      "indent": 0,
      "text": "A.3.1. Password to Key Sample Results using MD5",
      "section_title": true,
      "ja": "A.3.1. MD5を使用した主要なサンプル結果へのパスワード"
    },
    {
      "indent": 3,
      "text": "The following shows a sample output of the password to key algorithm for a 16-octet key using MD5.",
      "ja": "以下は、MD5を使用した16オクテットキーのパスワードからキーへのアルゴリズムのサンプル出力を示しています。"
    },
    {
      "indent": 3,
      "text": "With a password of \"maplesyrup\" the output of the password to key algorithm before the key is localized with the SNMP engine's snmpEngineID is:",
      "ja": "「maplesyrup」のパスワードを使用すると、SNMPエンジンのsnmpEngineIDを使用してキーをローカライズする前の、パスワードからキーへのアルゴリズムの出力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "'9f af 32 83 88 4e 92 83 4e bc 98 47 d8 ed d9 63'H",
      "ja": "фяфаф32 83 88ч92 92чебц98чщд8еддяШЗЪХ"
    },
    {
      "indent": 3,
      "text": "After the intermediate key (shown above) is localized with the snmpEngineID value of:",
      "ja": "上記の中間キーがsnmpEngineID値でローカライズされた後："
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 02'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 02'H"
    },
    {
      "indent": 3,
      "text": "the final output of the password to key algorithm is:",
      "ja": "キーアルゴリズムへのパスワードの最終的な出力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'52 6f 5e ed 9f cc e2 6f 89 64 c2 93 07 87 d8 2b'H",
      "ja": "'52 6f 5e ed 9f cc e2 6f 89 64 c2 93 07 87 d8 2b'H"
    },
    {
      "indent": 0,
      "text": "A.3.2. Password to Key Sample Results using SHA",
      "section_title": true,
      "ja": "A.3.2. SHAを使用した主要なサンプル結果のパスワード"
    },
    {
      "indent": 3,
      "text": "The following shows a sample output of the password to key algorithm for a 20-octet key using SHA.",
      "ja": "以下は、SHAを使用した20オクテットキーのパスワードからキーへのアルゴリズムの出力例です。"
    },
    {
      "indent": 3,
      "text": "With a password of \"maplesyrup\" the output of the password to key algorithm before the key is localized with the SNMP engine's snmpEngineID is:",
      "ja": "With a password of \"maplesyrup\" the output of the password to key algorithm before the key is localized with the SNMP engine's snmpEngineID is:"
    },
    {
      "indent": 6,
      "text": "'9f b5 cc 03 81 49 7b 37 93 52 89 39 ff 78 8d 5d 79 14 52 11'H",
      "ja": "'9f b5 cc 03 81 49 7b 37 93 52 89 39 ff 78 8d 5d 79 14 52 11'H"
    },
    {
      "indent": 3,
      "text": "After the intermediate key (shown above) is localized with the snmpEngineID value of:",
      "ja": "上記の中間キーがsnmpEngineID値でローカライズされた後："
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 02'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 02'H"
    },
    {
      "indent": 3,
      "text": "the final output of the password to key algorithm is:",
      "ja": "キーアルゴリズムへのパスワードの最終的な出力は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'66 95 fe bc 92 88 e3 62 82 23 5f c7 15 1f 12 84 97 b3 8f 3f'H",
      "ja": "'66 95 fe bc 92 88 e3 62 82 23 5f c7 15 1f 12 84 97 b3 8f 3f'H"
    },
    {
      "indent": 0,
      "text": "A.4. Sample Encoding of msgSecurityParameters",
      "section_title": true,
      "ja": "A.4. msgSecurityParametersのサンプルエンコーディング"
    },
    {
      "indent": 3,
      "text": "The msgSecurityParameters in an SNMP message are represented as an OCTET STRING. This OCTET STRING should be considered opaque outside a specific Security Model.",
      "ja": "SNMPメッセージのmsgSecurityParametersは、OCTET STRINGとして表されます。このオクテット文字列は、特定のセキュリティモデルの外では不透明と見なされます。"
    },
    {
      "indent": 3,
      "text": "The User-based Security Model defines the contents of the OCTET STRING as a SEQUENCE (see section 2.4).",
      "ja": "The User-based Security Model defines the contents of the OCTET STRING as a SEQUENCE (see section 2.4)."
    },
    {
      "indent": 3,
      "text": "Given these two properties, the following is an example of they msgSecurityParameters for the User-based Security Model, encoded as an OCTET STRING:",
      "ja": "これら2つのプロパティが指定されている場合、以下は、OCTET STRINGとしてエンコードされた、ユーザーベースのセキュリティモデルのmsgSecurityParametersの例です。"
    },
    {
      "indent": 6,
      "text": "04 <length>\n30 <length>\n04 <length> <msgAuthoritativeEngineID>\n02 <length> <msgAuthoritativeEngineBoots>\n02 <length> <msgAuthoritativeEngineTime>\n04 <length> <msgUserName>\n04 0c       <HMAC-MD5-96-digest>\n04 08       <salt>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Here is the example once more, but now with real values (except for the digest in msgAuthenticationParameters and the salt in msgPrivacyParameters, which depend on variable data that we have not defined here):",
      "ja": "ここにもう一度例がありますが、実際の値が含まれています（ここで定義していない変数データに依存するmsgAuthenticationParametersのダイジェストとmsgPrivacyParametersのソルトを除く）。"
    },
    {
      "indent": 6,
      "text": "Hex Data                         Description\n--------------  -----------------------------------------------\n04 39           OCTET STRING,                  length 57\n30 37           SEQUENCE,                      length 55\n04 0c 80000002  msgAuthoritativeEngineID:      IBM\n      01                                       IPv4 address\n      09840301                                 9.132.3.1\n02 01 01        msgAuthoritativeEngineBoots:   1\n02 02 0101      msgAuthoritativeEngineTime:    257\n04 04 62657274  msgUserName:                   bert\n04 0c 01234567  msgAuthenticationParameters:   sample value\n      89abcdef\n      fedcba98\n04 08 01234567  msgPrivacyParameters:          sample value\n      89abcdef",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.5. Sample keyChange Results",
      "section_title": true,
      "ja": "A.5. keyChange結果のサンプル"
    },
    {
      "indent": 0,
      "text": "A.5.1. Sample keyChange Results using MD5",
      "section_title": true,
      "ja": "A.5.1. MD5を使用したkeyChange結果のサンプル"
    },
    {
      "indent": 3,
      "text": "Let us assume that a user has a current password of \"maplesyrup\" as in section A.3.1. and let us also assume the snmpEngineID of 12 octets:",
      "ja": "セクションA.3.1のように、ユーザーが「maplesyrup」の現在のパスワードを持っていると仮定します。また、12オクテットのsnmpEngineIDを想定します。"
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 02'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 02'H"
    },
    {
      "indent": 3,
      "text": "If we now want to change the password to \"newsyrup\", then we first calculate the key for the new password. It is as follows:",
      "ja": "ここでパスワードを「newsyrup」に変更する場合は、最初に新しいパスワードのキーを計算します。以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "'01 ad d2 73 10 7c 4e 59 6b 4b 00 f8 2b 1d 42 a7'H",
      "ja": "'01 ad d2 73 10 7c 4e 59 6b 4b 00 f8 2b 1d 42 a7'H"
    },
    {
      "indent": 3,
      "text": "If we localize it for the above snmpEngineID, then the localized new key becomes:",
      "ja": "上記のsnmpEngineIDにローカライズすると、ローカライズされた新しいキーは次のようになります。"
    },
    {
      "indent": 6,
      "text": "'87 02 1d 7b d9 d1 01 ba 05 ea 6e 3b f9 d9 bd 4a'H",
      "ja": "'87 02 1d 7b d9 d1 01 ba 05 ea 6e 3b f9 d9 bd 4a'H"
    },
    {
      "indent": 3,
      "text": "If we then use a (not so good, but easy to test) random value of:",
      "ja": "次に、（あまり良くないが、テストが簡単な）ランダム値を使用する場合："
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H"
    },
    {
      "indent": 3,
      "text": "Then the value we must send for keyChange is:",
      "ja": "次に、keyChangeに送信する必要がある値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 88 05 61 51 41 67 6c c9 19 61 74 e7 42 a3 25 51'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 88 05 61 51 41 67 6c c9 19 61 74 e7 42 a3 25 51'H"
    },
    {
      "indent": 3,
      "text": "If this were for the privacy key, then it would be exactly the same.",
      "ja": "これがプライバシーキーの場合は、まったく同じです。"
    },
    {
      "indent": 0,
      "text": "A.5.2. Sample keyChange Results using SHA",
      "section_title": true,
      "ja": "A.5.2. SHAを使用したkeyChange結果のサンプル"
    },
    {
      "indent": 3,
      "text": "Let us assume that a user has a current password of \"maplesyrup\" as in section A.3.2. and let us also assume the snmpEngineID of 12 octets:",
      "ja": "Let us assume that a user has a current password of \"maplesyrup\" as in section A.3.2. and let us also assume the snmpEngineID of 12 octets:"
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 02'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 02'H"
    },
    {
      "indent": 3,
      "text": "If we now want to change the password to \"newsyrup\", then we first calculate the key for the new password. It is as follows:",
      "ja": "ここでパスワードを「newsyrup」に変更する場合は、最初に新しいパスワードのキーを計算します。以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "'3a 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H",
      "ja": "'3a 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H"
    },
    {
      "indent": 3,
      "text": "If we localize it for the above snmpEngineID, then the localized new key becomes:",
      "ja": "上記のsnmpEngineIDにローカライズすると、ローカライズされた新しいキーは次のようになります。"
    },
    {
      "indent": 6,
      "text": "'78 e2 dc ce 79 d5 94 03 b5 8c 1b ba a5 bf f4 63 91 f1 cd 25'H",
      "ja": "'78 e2 dc ce 79 d5 94 03 b5 8c 1b ba a5 bf f4 63 91 f1 cd 25'H"
    },
    {
      "indent": 3,
      "text": "If we then use a (not so good, but easy to test) random value of:",
      "ja": "次に、（あまり良くないが、テストが簡単な）ランダム値を使用する場合："
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H"
    },
    {
      "indent": 3,
      "text": "Then the value we must send for keyChange is:",
      "ja": "次に、keyChangeに送信する必要がある値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9c 10 17 f4 fd 48 3d 2d e8 d5 fa db f8 43 92 cb 06 45 70 51'",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 9c 10 17 f4 fd 48 3d 2d e8 d5 fa db f8 43 92 cb 06 45 70 51 '"
    },
    {
      "indent": 3,
      "text": "For the key used for privacy, the new nonlocalized key would be:",
      "ja": "プライバシーに使用されるキーの場合、ローカライズされていない新しいキーは次のようになります。"
    },
    {
      "indent": 6,
      "text": "'3a 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H",
      "ja": "'3a 51 a6 d7 36 aa 34 7b 83 dc 4a 87 e3 e5 5e e4 d6 98 ac 71'H"
    },
    {
      "indent": 3,
      "text": "For the key used for privacy, the new localized key would be (note that they localized key gets truncated to 16 octets for DES):",
      "ja": "プライバシーに使用されるキーの場合、新しいローカライズされたキーは次のようになります（ローカライズされたキーは、DESの場合は16オクテットに切り捨てられることに注意してください）："
    },
    {
      "indent": 6,
      "text": "'78 e2 dc ce 79 d5 94 03 b5 8c 1b ba a5 bf f4 63'H",
      "ja": "'78 e2 dc ce 79 d5 94 03 b5 8c 1b ba a5 bf f4 63'H"
    },
    {
      "indent": 3,
      "text": "If we then use a (not so good, but easy to test) random value of:",
      "ja": "次に、（あまり良くないが、テストが簡単な）ランダム値を使用する場合："
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'H"
    },
    {
      "indent": 3,
      "text": "Then the value we must send for keyChange for the privacy key is:",
      "ja": "次に、プライバシーキーのkeyChangeに送信する必要がある値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 '7e f8 d8 a4 c9 cd b2 6b 47 59 1c d8 52 ff 88 b5'H",
      "ja": "'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 '7e f8 d8 a4 c9 cd b2 6b 47 59 1c d8 52 ff 88 b5'H"
    },
    {
      "indent": 0,
      "text": "B. Change Log",
      "ja": "B.変更ログ"
    },
    {
      "indent": 3,
      "text": "Changes made since RFC2574:",
      "ja": "Changes made since RFC2574:"
    },
    {
      "indent": 3,
      "text": "- Updated references - Updated contact info - Clarifications - to first constraint item 1) on page 6. - to usmUserCloneFrom DESCRIPTION clause - to securityName in section 2.1 - Fixed \"command responder\" into \"command generator\" in last para of DESCRIPTION clause of usmUserTable.",
      "ja": "- 参照の更新-連絡先情報の更新-説明-6ページの最初の制約項目1）へ-usmUserCloneFrom DESCRIPTION句へ-セクション2.1のsecurityNameへ-usmUserTableのDESCRIPTION句の最後のパラグラフで「コマンドレスポンダー」を「コマンドジェネレーター」に修正。"
    },
    {
      "indent": 3,
      "text": "Changes made since RFC2274:",
      "ja": "RFC2274以降に行われた変更："
    },
    {
      "indent": 3,
      "text": "- Fixed msgUserName to allow size of zero and explain that this can be used for snmpEngineID discovery. - Clarified section 3.1 steps 4.b, 5, 6 and 8.b. - Clarified section 3.2 paragraph 2. - Clarified section 3.2 step 7.a last paragraph, step 7.b.1 second bullet and step 7.b.2 third bullet. - Clarified section 4 to indicate that discovery can use a userName of zero length in unAuthenticated messages, whereas a valid userName must be used in authenticated messages. - Added REVISION clauses to MODULE-IDENTITY - Clarified KeyChange TC by adding a note that localized keys must be used when calculating a KeyChange value. - Added clarifying text to the DESCRIPTION clause of usmUserTable. Added text describes a recommended procedure for adding a new user. - Clarified the use of usmUserCloneFrom object.",
      "ja": "- サイズがゼロになるようにmsgUserNameを修正し、これをsnmpEngineIDの検出に使用できることを説明しました。 -セクション3.1のステップ4.b、5、6、および8.bを明確にしました。 -セクション3.2パラグラフ2を明確にしました。-セクション3.2ステップ7.a最後の段落、ステップ7.b.1の2番目の箇条書きとステップ7.b.2の3番目の箇条書きを明確にしました。 -セクション4を明確にして、ディスカバリーでは認証されていないメッセージで長さ0のuserNameを使用できるが、認証されたメッセージでは有効なuserNameを使用する必要があることを示しました。 -REDUION句をMODULE-IDENTITYに追加しました-KeyChange値を計算するときはローカライズされたキーを使用する必要があるというメモを追加して、KeyChange TCを明確にしました。 -usmUserTableのDESCRIPTION句に明確なテキストを追加しました。新しいユーザーを追加するための推奨手順を説明するテキストが追加されました。 -usmUserCloneFromオブジェクトの使用を明確にしました。"
    },
    {
      "indent": 3,
      "text": "- Clarified how and under which conditions the usmUserAuthProtocol and usmUserPrivProtocol can be initialized and/or changed. - Added comment on typical sizes for usmUserAuthKeyChange and usmUserPrivKeyChange. Also for usmUserOwnAuthKeyChange and usmUserOwnPrivKeyChange. - Added clarifications to the DESCRIPTION clauses of usmUserAuthKeyChange, usmUserOwnAuthKeychange, usmUserPrivKeyChange and usmUserOwnPrivKeychange. - Added clarification to DESCRIPTION clause of usmUserStorageType. - Added clarification to DESCRIPTION clause of usmUserStatus. - Clarified IV generation procedure in section 8.1.1.1 and in addition clarified section 8.3.1 step 1 and section 8.3.2. step 3. - Clarified section 11.2 and added a warning that different size passwords with repetitive strings may result in same key. - Added template users to appendix A for cloning process. - Fixed C-code examples in Appendix A. - Fixed examples of generated keys in Appendix A. - Added examples of KeyChange values to Appendix A. - Used PDU Classes instead of RFC1905 PDU types. - Added text in the security section about Reports and Access Control to the MIB. - Removed a incorrect note at the end of section 3.2 step 7. - Added a note in section 3.2 step 3. - Corrected various spelling errors and typos. - Corrected procedure for 3.2 step 2.a) - various clarifications. - Fixed references to new/revised documents - Change to no longer cache data that is not used",
      "ja": "- usmUserAuthProtocolおよびusmUserPrivProtocolを初期化または変更できる方法と条件を明確にしました。 -usmUserAuthKeyChangeおよびusmUserPrivKeyChangeの一般的なサイズに関するコメントを追加しました。また、usmUserOwnAuthKeyChangeおよびusmUserOwnPrivKeyChangeについても同様です。 -usmUserAuthKeyChange、usmUserOwnAuthKeychange、usmUserPrivKeyChange、およびusmUserOwnPrivKeychangeのDESCRIPTION句に説明を追加しました。 -usmUserStorageTypeのDESCRIPTION句に説明が追加されました。 -usmUserStatusのDESCRIPTION句に説明を追加しました。 -セクション8.1.1.1のIV生成手順を明確にし、さらにセクション8.3.1のステップ1とセクション8.3.2を明確にしました。ステップ3.-セクション11.2を明確にし、文字列が繰り返される異なるサイズのパスワードは同じキーになる可能性があるという警告を追加しました。 -クローン作成プロセスのために、テンプレートユーザーを付録Aに追加しました。 -付録AのCコードの例を修正。-付録Aの生成されたキーの例を修正。-KeyChange値の例を付録Aに追加。-RFC1905 PDUタイプの代わりに使用されるPDUクラス。 -レポートのセキュリティセクションに、MIBへのアクセス制御に関するテキストを追加。 -セクション3.2ステップ7の最後にある誤ったメモを削除しました。-セクション3.2ステップ3にメモを追加しました。-さまざまなスペルミスとタイプミスを修正しました。 -3.2ステップ2.a）の手順を修正-さまざまな説明。 -新規/改訂されたドキュメントへの参照を修正-使用されていないデータをキャッシュしないように変更"
    },
    {
      "indent": 0,
      "text": "Editors' Addresses",
      "ja": "編集者のアドレス"
    },
    {
      "indent": 3,
      "text": "Uri Blumenthal Lucent Technologies 67 Whippany Rd. Whippany, NJ 07981 USA",
      "ja": "Uri Blumenthal Lucent Technologies 67 Whippany Rd。 Whippany、NJ 07981 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-973-386-2163\nEMail: uri@lucent.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bert Wijnen Lucent Technologies Schagen 33 3461 GL Linschoten Netherlands",
      "ja": "Bert Wijnen Lucent Technologies Schagen 33 3461 GL Linschotenオランダ"
    },
    {
      "indent": 3,
      "text": "Phone: +31-348-480-685\nEMail: bwijnen@lucent.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "Copyright（C）The Internet Society（2002）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントとその翻訳はコピーして他のユーザーに提供することができ、コメントまたはその他の方法で説明したり、その実装を支援する二次的著作物は、いかなる種類の制限なしに、全体または一部を準備、コピー、公開、および配布することができます。ただし、上記の著作権表示とこの段落は、そのようなすべてのコピーと派生物に含まれています。ただし、この文書自体は、著作権に関する通知を削除したり、インターネットソサエティや他のインターネット組織への参照を削除したりするなど、いかなる方法でも変更できません。ただし、インターネット標準を開発する目的で必要な場合は除きます。インターネット標準のプロセスに従うか、または必要に応じて、それを英語以外の言語に翻訳する必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記で付与された制限付きのアクセス許可は永続的であり、インターネットソサエティまたはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は「現状有姿」で提供され、インターネット社会およびインターネット技術タスクフォースは、明示または黙示を問わず、ここに記載されている情報の使用が保証するものに限定されないいかなる保証も含め、一切の保証を否認します。商品性または特定の目的への適合性に関する権利または黙示の保証を侵害すること。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能への資金提供は、現在Internet Societyから提供されています。"
    }
  ]
}